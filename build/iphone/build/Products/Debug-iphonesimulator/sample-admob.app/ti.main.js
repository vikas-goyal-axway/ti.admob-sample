'use strict';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global_1 =
// eslint-disable-next-line no-undef
check(typeof globalThis == 'object' && globalThis) ||
check(typeof window == 'object' && window) ||
check(typeof self == 'object' && self) ||
check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
// eslint-disable-next-line no-new-func
Function('return this')();

var fails = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var descriptors = !fails(function () {
  return Object.defineProperty({}, 'a', { get: function () {return 7;} }).a != 7;
});

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;

var objectPropertyIsEnumerable = {
  f: f };


var createPropertyDescriptor = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value };

};

var toString = {}.toString;

var classofRaw = function (it) {
  return toString.call(it).slice(8, -1);
};

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var indexedObject = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
var requireObjectCoercible = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};

// toObject with fallback for non-array-like ES3 strings



var toIndexedObject = function (it) {
  return indexedObject(requireObjectCoercible(it));
};

var isObject = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

// `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var toPrimitive = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var hasOwnProperty = {}.hasOwnProperty;

var has = function (it, key) {
  return hasOwnProperty.call(it, key);
};

var document$1 = global_1.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document$1) && isObject(document$1.createElement);

var documentCreateElement = function (it) {
  return EXISTS ? document$1.createElement(it) : {};
};

// Thank's IE8 for his funny defineProperty
var ie8DomDefine = !descriptors && !fails(function () {
  return Object.defineProperty(documentCreateElement('div'), 'a', {
    get: function () {return 7;} }).
  a != 7;
});

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (ie8DomDefine) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) {/* empty */}
  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
};

var objectGetOwnPropertyDescriptor = {
  f: f$1 };


var anObject = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  }return it;
};

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (ie8DomDefine) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var objectDefineProperty = {
  f: f$2 };


var createNonEnumerableProperty = descriptors ? function (object, key, value) {
  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var setGlobal = function (key, value) {
  try {
    createNonEnumerableProperty(global_1, key, value);
  } catch (error) {
    global_1[key] = value;
  }return value;
};

var SHARED = '__core-js_shared__';
var store = global_1[SHARED] || setGlobal(SHARED, {});

var sharedStore = store;

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof sharedStore.inspectSource != 'function') {
  sharedStore.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

var inspectSource = sharedStore.inspectSource;

var WeakMap = global_1.WeakMap;

var nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

var shared = createCommonjsModule(function (module) {
  (module.exports = function (key, value) {
    return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: '3.6.1',
    mode: 'global',
    copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)' });

});

var id = 0;
var postfix = Math.random();

var uid = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

var keys = shared('keys');

var sharedKey = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

var hiddenKeys = {};

var WeakMap$1 = global_1.WeakMap;
var set, get, has$1;

var enforce = function (it) {
  return has$1(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    }return state;
  };
};

if (nativeWeakMap) {
  var store$1 = new WeakMap$1();
  var wmget = store$1.get;
  var wmhas = store$1.has;
  var wmset = store$1.set;
  set = function (it, metadata) {
    wmset.call(store$1, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store$1, it) || {};
  };
  has$1 = function (it) {
    return wmhas.call(store$1, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return has(it, STATE) ? it[STATE] : {};
  };
  has$1 = function (it) {
    return has(it, STATE);
  };
}

var internalState = {
  set: set,
  get: get,
  has: has$1,
  enforce: enforce,
  getterFor: getterFor };


var redefine = createCommonjsModule(function (module) {
  var getInternalState = internalState.get;
  var enforceInternalState = internalState.enforce;
  var TEMPLATE = String(String).split('String');

  (module.exports = function (O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    if (typeof value == 'function') {
      if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
      enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
    if (O === global_1) {
      if (simple) O[key] = value;else
      setGlobal(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet && O[key]) {
      simple = true;
    }
    if (simple) O[key] = value;else
    createNonEnumerableProperty(O, key, value);
    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, 'toString', function toString() {
    return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
  });
});

var path = global_1;

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

var getBuiltIn = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace]) :
  path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
};

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
var toInteger = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
var toLength = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var max = Math.max;
var min$1 = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
var toAbsoluteIndex = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
};

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }return !IS_INCLUDES && -1;
  };
};

var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false) };


var indexOf = arrayIncludes.indexOf;


var objectKeysInternal = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};

// IE8- don't enum bug keys
var enumBugKeys = [
'constructor',
'hasOwnProperty',
'isPrototypeOf',
'propertyIsEnumerable',
'toLocaleString',
'toString',
'valueOf'];


var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return objectKeysInternal(O, hiddenKeys$1);
};

var objectGetOwnPropertyNames = {
  f: f$3 };


var f$4 = Object.getOwnPropertySymbols;

var objectGetOwnPropertySymbols = {
  f: f$4 };


// all object keys, includes non-enumerable and symbols
var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = objectGetOwnPropertyNames.f(anObject(it));
  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

var copyConstructorProperties = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = objectDefineProperty.f;
  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true :
  value == NATIVE ? false :
  typeof detection == 'function' ? fails(detection) :
  !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

var isForced_1 = isForced;

var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






/*
                                                                     options.target      - name of the target object
                                                                     options.global      - target is the global object
                                                                     options.stat        - export as static methods of target
                                                                     options.proto       - export as prototype methods of target
                                                                     options.real        - real prototype method for the `pure` version
                                                                     options.forced      - export even if the native feature is available
                                                                     options.bind        - bind methods to the target, required for the `pure` version
                                                                     options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
                                                                     options.unsafe      - use the simple assignment of property instead of delete + defineProperty
                                                                     options.sham        - add a flag to not completely full polyfills
                                                                     options.enumerable  - export as enumerable property
                                                                     options.noTargetGet - prevent calling a getter on target
                                                                   */
var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global_1;
  } else if (STATIC) {
    target = global_1[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global_1[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor$1(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};

var defineProperty = objectDefineProperty.f;


var NativeSymbol = global_1.Symbol;

if (descriptors && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
// Safari 12 bug
NativeSymbol().description !== undefined))
{
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper ?
    new NativeSymbol(description)
    // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
    : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;

  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    } });


  _export({ global: true, forced: true }, {
    Symbol: SymbolWrapper });

}

var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});

var useSymbolAsUid = nativeSymbol
// eslint-disable-next-line no-undef
&& !Symbol.sham
// eslint-disable-next-line no-undef
&& typeof Symbol.iterator == 'symbol';

var WellKnownSymbolsStore = shared('wks');
var Symbol$1 = global_1.Symbol;
var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

var wellKnownSymbol = function (name) {
  if (!has(WellKnownSymbolsStore, name)) {
    if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];else
    WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
  }return WellKnownSymbolsStore[name];
};

var f$5 = wellKnownSymbol;

var wrappedWellKnownSymbol = {
  f: f$5 };


var defineProperty$1 = objectDefineProperty.f;

var defineWellKnownSymbol = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty$1(Symbol, NAME, {
    value: wrappedWellKnownSymbol.f(NAME) });

};

// `Symbol.asyncIterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.asynciterator
defineWellKnownSymbol('asyncIterator');

// `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray
var isArray = Array.isArray || function isArray(arg) {
  return classofRaw(arg) == 'Array';
};

var aFunction$1 = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  }return it;
};

// optional / simple context binding
var bindContext = function (fn, that, length) {
  aFunction$1(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0:return function () {
        return fn.call(that);
      };
    case 1:return function (a) {
        return fn.call(that, a);
      };
    case 2:return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:return function (a, b, c) {
        return fn.call(that, a, b, c);
      };}

  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

// `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bindContext(mapper, thisArg, 3) : false;
  var element;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};

var flattenIntoArray_1 = flattenIntoArray;

// `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject
var toObject = function (argument) {
  return Object(requireObjectCoercible(argument));
};

var SPECIES = wellKnownSymbol('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
var arraySpeciesCreate = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};

// `Array.prototype.flat` method
// https://github.com/tc39/proposal-flatMap
_export({ target: 'Array', proto: true }, {
  flat: function flat() /* depthArg = 1 */{
    var depthArg = arguments.length ? arguments[0] : undefined;
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  } });


// `Array.prototype.flatMap` method
// https://github.com/tc39/proposal-flatMap
_export({ target: 'Array', proto: true }, {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A;
    aFunction$1(callbackfn);
    A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return A;
  } });


var nativeReverse = [].reverse;
var test = [1, 2];

// `Array.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794
_export({ target: 'Array', proto: true, forced: String(test) === String(test.reverse()) }, {
  reverse: function reverse() {
    // eslint-disable-next-line no-self-assign
    if (isArray(this)) this.length = this.length;
    return nativeReverse.call(this);
  } });


var sloppyArrayMethod = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !method || !fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () {throw 1;}, 1);
  });
};

var test$1 = [];
var nativeSort = test$1.sort;

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test$1.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test$1.sort(null);
});
// Old WebKit
var SLOPPY_METHOD = sloppyArrayMethod('sort');

var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || SLOPPY_METHOD;

// `Array.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-array.prototype.sort
_export({ target: 'Array', proto: true, forced: FORCED }, {
  sort: function sort(comparefn) {
    return comparefn === undefined ?
    nativeSort.call(toObject(this)) :
    nativeSort.call(toObject(this), aFunction$1(comparefn));
  } });


// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
var objectKeys = Object.keys || function keys(O) {
  return objectKeysInternal(O, enumBugKeys);
};

// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
  return O;
};

var html = getBuiltIn('document', 'documentElement');

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () {/* empty */};

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) {/* ignore */}
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create
var objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : objectDefineProperties(result, Properties);
};

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: objectCreate(null) });

}

// add a key to Array.prototype[@@unscopables]
var addToUnscopables = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module


addToUnscopables('flat');

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module


addToUnscopables('flatMap');

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test$2 = {};

test$2[TO_STRING_TAG] = 'z';

var toStringTagSupport = String(test$2) === '[object z]';

var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () {return arguments;}()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) {/* empty */}
};

// getting tag from ES6+ `Object.prototype.toString`
var classof = toStringTagSupport ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
  // @@toStringTag case
  : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag
  // builtinTag case
  : CORRECT_ARGUMENTS ? classofRaw(O)
  // ES3 arguments fallback
  : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

var correctPrototypeGetter = !fails(function () {
  function F() {/* empty */}
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

var IE_PROTO$1 = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }return O instanceof Object ? ObjectPrototype : null;
};

var aPossiblePrototype = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  }return it;
};

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) {/* empty */}
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);else
    O.__proto__ = proto;
    return O;
  };
}() : undefined);

var defineProperty$2 = objectDefineProperty.f;





var DataView = global_1.DataView;
var DataViewPrototype = DataView && DataView.prototype;
var Int8Array$1 = global_1.Int8Array;
var Int8ArrayPrototype = Int8Array$1 && Int8Array$1.prototype;
var Uint8ClampedArray$1 = global_1.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray$1 && Uint8ClampedArray$1.prototype;
var TypedArray = Int8Array$1 && objectGetPrototypeOf(Int8Array$1);
var TypedArrayPrototype = Int8ArrayPrototype && objectGetPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype$1 = Object.prototype;
var isPrototypeOf = ObjectPrototype$1.isPrototypeOf;

var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
var NATIVE_ARRAY_BUFFER = !!(global_1.ArrayBuffer && DataView);
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!objectSetPrototypeOf && classof(global_1.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8 };


var isView = function isView(it) {
  var klass = classof(it);
  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
};

var isTypedArray = function (it) {
  return isObject(it) && has(TypedArrayConstructorsList, classof(it));
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (objectSetPrototypeOf) {
    if (isPrototypeOf.call(TypedArray, C)) return C;
  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {
    var TypedArrayConstructor = global_1[ARRAY];
    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
      return C;
    }
  }throw TypeError('Target is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced) {
  if (!descriptors) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global_1[ARRAY];
    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
      delete TypedArrayConstructor.prototype[KEY];
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    redefine(TypedArrayPrototype, KEY, forced ? property :
    NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
  }
};

var exportTypedArrayStaticMethod = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!descriptors) return;
  if (objectSetPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global_1[ARRAY];
      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
        delete TypedArrayConstructor[KEY];
      }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array$1[KEY] || property);
      } catch (error) {/* empty */}
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global_1[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      redefine(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  if (!global_1[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype$1) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (descriptors && !has(TypedArrayPrototype, TO_STRING_TAG$2)) {
  TYPED_ARRAY_TAG_REQIRED = true;
  defineProperty$2(TypedArrayPrototype, TO_STRING_TAG$2, { get: function () {
      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
    } });
  for (NAME in TypedArrayConstructorsList) if (global_1[NAME]) {
    createNonEnumerableProperty(global_1[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

// WebKit bug - the same parent prototype for typed arrays and data view
if (NATIVE_ARRAY_BUFFER && objectSetPrototypeOf && objectGetPrototypeOf(DataViewPrototype) !== ObjectPrototype$1) {
  objectSetPrototypeOf(DataViewPrototype, ObjectPrototype$1);
}

var arrayBufferViewCore = {
  NATIVE_ARRAY_BUFFER: NATIVE_ARRAY_BUFFER,
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype };


var redefineAll = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};

var anInstance = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  }return it;
};

// `ToIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-toindex
var toIndex = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length or index');
  return length;
};

// IEEE754 conversions based on https://github.com/feross/ieee754
// eslint-disable-next-line no-shadow-restricted-names
var Infinity$1 = 1 / 0;
var abs = Math.abs;
var pow = Math.pow;
var floor$1 = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

var pack = function (number, mantissaLength, bytes) {
  var buffer = new Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare
  if (number != number || number === Infinity$1) {
    // eslint-disable-next-line no-self-compare
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor$1(log(number) / LN2);
    if (number * (c = pow(2, -exponent)) < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
  buffer[--index] |= sign * 128;
  return buffer;
};

var unpack = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity$1 : Infinity$1;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  }return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

var ieee754 = {
  pack: pack,
  unpack: unpack };


// `Array.prototype.fill` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
var arrayFill = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

var defineProperty$3 = objectDefineProperty.f;



var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');

var setToStringTag = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG$3)) {
    defineProperty$3(it, TO_STRING_TAG$3, { configurable: true, value: TAG });
  }
};

var NATIVE_ARRAY_BUFFER$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER;








var getOwnPropertyNames = objectGetOwnPropertyNames.f;
var defineProperty$4 = objectDefineProperty.f;




var getInternalState = internalState.get;
var setInternalState = internalState.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE$1 = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global_1[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var $DataView = global_1[DATA_VIEW];
var RangeError$1 = global_1.RangeError;

var packIEEE754 = ieee754.pack;
var unpackIEEE754 = ieee754.unpack;

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function (Constructor, key) {
  defineProperty$4(Constructor[PROTOTYPE$1], key, { get: function () {return getInternalState(this)[key];} });
};

var get$1 = function (view, count, index, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = bytes.slice(start, start + count);
  return isLittleEndian ? pack : pack.reverse();
};

var set$1 = function (view, count, index, conversion, value, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);
  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};

if (!NATIVE_ARRAY_BUFFER$1) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    setInternalState(this, {
      bytes: arrayFill.call(new Array(byteLength), 0),
      byteLength: byteLength });

    if (!descriptors) this.byteLength = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = getInternalState(buffer).byteLength;
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError$1('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError$1(WRONG_LENGTH);
    setInternalState(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset });

    if (!descriptors) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  if (descriptors) {
    addGetter($ArrayBuffer, 'byteLength');
    addGetter($DataView, 'buffer');
    addGetter($DataView, 'byteLength');
    addGetter($DataView, 'byteOffset');
  }

  redefineAll($DataView[PROTOTYPE$1], {
    getInt8: function getInt8(byteOffset) {
      return get$1(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get$1(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get$1(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set$1(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set$1(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set$1(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set$1(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set$1(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set$1(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set$1(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set$1(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
    } });

} else {
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new NativeArrayBuffer(); // eslint-disable-line no-new
    new NativeArrayBuffer(1.5); // eslint-disable-line no-new
    new NativeArrayBuffer(NaN); // eslint-disable-line no-new
    return NativeArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new NativeArrayBuffer(toIndex(length));
    };
    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE$1] = NativeArrayBuffer[PROTOTYPE$1];
    for (var keys$1 = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys$1.length > j;) {
      if (!((key = keys$1[j++]) in $ArrayBuffer)) {
        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
      }
    }
    ArrayBufferPrototype.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var nativeSetInt8 = $DataView[PROTOTYPE$1].setInt8;
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataView[PROTOTYPE$1], {
    setInt8: function setInt8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    } },
  { unsafe: true });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);

var arrayBuffer = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView };


var SPECIES$1 = wellKnownSymbol('species');

var setSpecies = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = objectDefineProperty.f;

  if (descriptors && Constructor && !Constructor[SPECIES$1]) {
    defineProperty(Constructor, SPECIES$1, {
      configurable: true,
      get: function () {return this;} });

  }
};

var ARRAY_BUFFER$1 = 'ArrayBuffer';
var ArrayBuffer$1 = arrayBuffer[ARRAY_BUFFER$1];
var NativeArrayBuffer$1 = global_1[ARRAY_BUFFER$1];

// `ArrayBuffer` constructor
// https://tc39.github.io/ecma262/#sec-arraybuffer-constructor
_export({ global: true, forced: NativeArrayBuffer$1 !== ArrayBuffer$1 }, {
  ArrayBuffer: ArrayBuffer$1 });


setSpecies(ARRAY_BUFFER$1);

var SPECIES$2 = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor
var speciesConstructor = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES$2]) == undefined ? defaultConstructor : aFunction$1(S);
};

var ArrayBuffer$2 = arrayBuffer.ArrayBuffer;
var DataView$1 = arrayBuffer.DataView;
var nativeArrayBufferSlice = ArrayBuffer$2.prototype.slice;

var INCORRECT_SLICE = fails(function () {
  return !new ArrayBuffer$2(2).slice(1, undefined).byteLength;
});

// `ArrayBuffer.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice
_export({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice !== undefined && end === undefined) {
      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
    }
    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new (speciesConstructor(this, ArrayBuffer$2))(toLength(fin - first));
    var viewSource = new DataView$1(this);
    var viewTarget = new DataView$1(result);
    var index = 0;
    while (first < fin) {
      viewTarget.setUint8(index++, viewSource.getUint8(first++));
    }return result;
  } });


// a string of all valid unicode whitespaces
// eslint-disable-next-line max-len
var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod$1 = function (TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
  start: createMethod$1(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
  end: createMethod$1(2),
  // `String.prototype.trim` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
  trim: createMethod$1(3) };


var trim = stringTrim.trim;


var nativeParseFloat = global_1.parseFloat;
var FORCED$1 = 1 / nativeParseFloat(whitespaces + '-0') !== -Infinity;

// `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string
var _parseFloat = FORCED$1 ? function parseFloat(string) {
  var trimmedString = trim(String(string));
  var result = nativeParseFloat(trimmedString);
  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
} : nativeParseFloat;

// `Number.parseFloat` method
// https://tc39.github.io/ecma262/#sec-number.parseFloat
_export({ target: 'Number', stat: true, forced: Number.parseFloat != _parseFloat }, {
  parseFloat: _parseFloat });


var propertyIsEnumerable = objectPropertyIsEnumerable.f;

// `Object.{ entries, values }` methods implementation
var createMethod$2 = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!descriptors || propertyIsEnumerable.call(O, key)) {
        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

var objectToArray = {
  // `Object.entries` method
  // https://tc39.github.io/ecma262/#sec-object.entries
  entries: createMethod$2(true),
  // `Object.values` method
  // https://tc39.github.io/ecma262/#sec-object.values
  values: createMethod$2(false) };


var $entries = objectToArray.entries;

// `Object.entries` method
// https://tc39.github.io/ecma262/#sec-object.entries
_export({ target: 'Object', stat: true }, {
  entries: function entries(O) {
    return $entries(O);
  } });


var iterators = {};

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype$1 = Array.prototype;

// check on default Array iterator
var isArrayIteratorMethod = function (it) {
  return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR] === it);
};

var ITERATOR$1 = wellKnownSymbol('iterator');

var getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$1] ||
  it['@@iterator'] ||
  iterators[classof(it)];
};

// call something on iterator step with safe closing on error
var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};

var iterate_1 = createCommonjsModule(function (module) {
  var Result = function (stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };

  var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
    var boundFunction = bindContext(fn, that, AS_ENTRIES ? 2 : 1);
    var iterator, iterFn, index, length, result, next, step;

    if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod(iterable);
      if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
      // optimisation for array iterators
      if (isArrayIteratorMethod(iterFn)) {
        for (index = 0, length = toLength(iterable.length); length > index; index++) {
          result = AS_ENTRIES ?
          boundFunction(anObject(step = iterable[index])[0], step[1]) :
          boundFunction(iterable[index]);
          if (result && result instanceof Result) return result;
        }return new Result(false);
      }
      iterator = iterFn.call(iterable);
    }

    next = iterator.next;
    while (!(step = next.call(iterator)).done) {
      result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
      if (typeof result == 'object' && result && result instanceof Result) return result;
    }return new Result(false);
  };

  iterate.stop = function (result) {
    return new Result(true, result);
  };
});

var createProperty = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));else
  object[propertyKey] = value;
};

// `Object.fromEntries` method
// https://github.com/tc39/proposal-object-from-entries
_export({ target: 'Object', stat: true }, {
  fromEntries: function fromEntries(iterable) {
    var obj = {};
    iterate_1(iterable, function (k, v) {
      createProperty(obj, k, v);
    }, undefined, true);
    return obj;
  } });


var $values = objectToArray.values;

// `Object.values` method
// https://tc39.github.io/ecma262/#sec-object.values
_export({ target: 'Object', stat: true }, {
  values: function values(O) {
    return $values(O);
  } });


var nativePromiseConstructor = global_1.Promise;

var ITERATOR$2 = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    } };

  iteratorWithReturn[ITERATOR$2] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(iteratorWithReturn, function () {throw 2;});
} catch (error) {/* empty */}

var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR$2] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        } };

    };
    exec(object);
  } catch (error) {/* empty */}
  return ITERATION_SUPPORT;
};

var userAgent = getBuiltIn('navigator', 'userAgent') || '';

var isIos = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);

var location = global_1.location;
var set$2 = global_1.setImmediate;
var clear = global_1.clearImmediate;
var process$1 = global_1.process;
var MessageChannel = global_1.MessageChannel;
var Dispatch = global_1.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function (id) {
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global_1.postMessage(id + '', location.protocol + '//' + location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set$2 || !clear) {
  set$2 = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (classofRaw(process$1) == 'process') {
    defer = function (id) {
      process$1.nextTick(runner(id));
    };
    // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
    // Browsers with MessageChannel, includes WebWorkers
    // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !isIos) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bindContext(port.postMessage, port, 1);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global_1.addEventListener && typeof postMessage == 'function' && !global_1.importScripts && !fails(post)) {
    defer = post;
    global_1.addEventListener('message', listener, false);
    // IE8-
  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
    defer = function (id) {
      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
    // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

var task = {
  set: set$2,
  clear: clear };


var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;

var macrotask = task.set;


var MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver;
var process$2 = global_1.process;
var Promise$1 = global_1.Promise;
var IS_NODE = classofRaw(process$2) == 'process';
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor$2(global_1, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process$2.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();else
        last = undefined;
        throw error;
      }
    }last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (IS_NODE) {
    notify = function () {
      process$2.nextTick(flush);
    };
    // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  } else if (MutationObserver && !isIos) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
    // environments with maybe non-completely correct, but existent Promise
  } else if (Promise$1 && Promise$1.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise$1.resolve(undefined);
    then = promise.then;
    notify = function () {
      then.call(promise, flush);
    };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global_1, flush);
    };
  }
}

var microtask = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  }last = task;
};

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction$1(resolve);
  this.reject = aFunction$1(reject);
};

// 25.4.1.5 NewPromiseCapability(C)
var f$6 = function (C) {
  return new PromiseCapability(C);
};

var newPromiseCapability = {
  f: f$6 };


var promiseResolve = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

var hostReportErrors = function (a, b) {
  var console = global_1.console;
  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};

var perform = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};

var process$3 = global_1.process;
var versions = process$3 && process$3.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

var v8Version = version && +version;

var task$1 = task.set;










var SPECIES$3 = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState$1 = internalState.get;
var setInternalState$1 = internalState.set;
var getInternalPromiseState = internalState.getterFor(PROMISE);
var PromiseConstructor = nativePromiseConstructor;
var TypeError$1 = global_1.TypeError;
var document$2 = global_1.document;
var process$4 = global_1.process;
var $fetch = getBuiltIn('fetch');
var newPromiseCapability$1 = newPromiseCapability.f;
var newGenericPromiseCapability = newPromiseCapability$1;
var IS_NODE$1 = classofRaw(process$4) == 'process';
var DISPATCH_EVENT = !!(document$2 && document$2.createEvent && global_1.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

var FORCED$2 = isForced_1(PROMISE, function () {
  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
  if (!GLOBAL_CORE_JS_PROMISE) {
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (v8Version === 66) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    if (!IS_NODE$1 && typeof PromiseRejectionEvent != 'function') return true;
  }
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (v8Version >= 51 && /native code/.test(PromiseConstructor)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = PromiseConstructor.resolve(1);
  var FakePromise = function (exec) {
    exec(function () {/* empty */}, function () {/* empty */});
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES$3] = FakePromise;
  return !(promise.then(function () {/* empty */}) instanceof FakePromise);
});

var INCORRECT_ITERATION = FORCED$2 || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () {/* empty */});
});

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify$1 = function (promise, state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var index = 0;
    // variable length - can't use forEach
    while (chain.length > index) {
      var reaction = chain[index++];
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;else
          {
            if (domain) domain.enter();
            result = handler(value); // can throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError$1('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    }
    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(promise, state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document$2.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global_1.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (handler = global_1['on' + name]) handler(event);else
  if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (promise, state) {
  task$1.call(global_1, function () {
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE$1) {
          process$4.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (promise, state) {
  task$1.call(global_1, function () {
    if (IS_NODE$1) {
      process$4.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, promise, state, unwrap) {
  return function (value) {
    fn(promise, state, value, unwrap);
  };
};

var internalReject = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify$1(promise, state, true);
};

var internalResolve = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          then.call(value,
          bind(internalResolve, promise, wrapper, state),
          bind(internalReject, promise, wrapper, state));

        } catch (error) {
          internalReject(promise, wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify$1(promise, state, false);
    }
  } catch (error) {
    internalReject(promise, { done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED$2) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction$1(executor);
    Internal.call(this);
    var state = getInternalState$1(this);
    try {
      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
    } catch (error) {
      internalReject(this, state, error);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    setInternalState$1(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined });

  };
  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE$1 ? process$4.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify$1(this, state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    } });

  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState$1(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, promise, state);
    this.reject = bind(internalReject, promise, state);
  };
  newPromiseCapability.f = newPromiseCapability$1 = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper ?
    new OwnPromiseCapability(C) :
    newGenericPromiseCapability(C);
  };

  if (typeof nativePromiseConstructor == 'function') {
    nativeThen = nativePromiseConstructor.prototype.then;

    // wrap native Promise#then for native async functions
    redefine(nativePromiseConstructor.prototype, 'then', function then(onFulfilled, onRejected) {
      var that = this;
      return new PromiseConstructor(function (resolve, reject) {
        nativeThen.call(that, resolve, reject);
      }).then(onFulfilled, onRejected);
      // https://github.com/zloirock/core-js/issues/640
    }, { unsafe: true });

    // wrap fetch result
    if (typeof $fetch == 'function') _export({ global: true, enumerable: true, forced: true }, {
      // eslint-disable-next-line no-unused-vars
      fetch: function fetch(input /* , init */) {
        return promiseResolve(PromiseConstructor, $fetch.apply(global_1, arguments));
      } });

  }
}

_export({ global: true, wrap: true, forced: FORCED$2 }, {
  Promise: PromiseConstructor });


setToStringTag(PromiseConstructor, PROMISE, false);
setSpecies(PROMISE);

PromiseWrapper = getBuiltIn(PROMISE);

// statics
_export({ target: PROMISE, stat: true, forced: FORCED$2 }, {
  // `Promise.reject` method
  // https://tc39.github.io/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability$1(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  } });


_export({ target: PROMISE, stat: true, forced: FORCED$2 }, {
  // `Promise.resolve` method
  // https://tc39.github.io/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(this, x);
  } });


_export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  // `Promise.all` method
  // https://tc39.github.io/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability$1(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction$1(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate_1(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        $promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.github.io/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability$1(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction$1(C.resolve);
      iterate_1(iterable, function (promise) {
        $promiseResolve.call(C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  } });


// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
var NON_GENERIC = !!nativePromiseConstructor && fails(function () {
  nativePromiseConstructor.prototype['finally'].call({ then: function () {/* empty */} }, function () {/* empty */});
});

// `Promise.prototype.finally` method
// https://tc39.github.io/ecma262/#sec-promise.prototype.finally
_export({ target: 'Promise', proto: true, real: true, forced: NON_GENERIC }, {
  'finally': function (onFinally) {
    var C = speciesConstructor(this, getBuiltIn('Promise'));
    var isFunction = typeof onFinally == 'function';
    return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {return x;});
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {throw e;});
    } : onFinally);

  } });


// patch native Promise.prototype for native async functions
if (typeof nativePromiseConstructor == 'function' && !nativePromiseConstructor.prototype['finally']) {
  redefine(nativePromiseConstructor.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);
}

// `String.prototype.repeat` method implementation
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
var stringRepeat = ''.repeat || function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};

// https://github.com/tc39/proposal-string-pad-start-end




var ceil$1 = Math.ceil;

// `String.prototype.{ padStart, padEnd }` methods implementation
var createMethod$3 = function (IS_END) {
  return function ($this, maxLength, fillString) {
    var S = String(requireObjectCoercible($this));
    var stringLength = S.length;
    var fillStr = fillString === undefined ? ' ' : String(fillString);
    var intMaxLength = toLength(maxLength);
    var fillLen, stringFiller;
    if (intMaxLength <= stringLength || fillStr == '') return S;
    fillLen = intMaxLength - stringLength;
    stringFiller = stringRepeat.call(fillStr, ceil$1(fillLen / fillStr.length));
    if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
    return IS_END ? S + stringFiller : stringFiller + S;
  };
};

var stringPad = {
  // `String.prototype.padStart` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.padstart
  start: createMethod$3(false),
  // `String.prototype.padEnd` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.padend
  end: createMethod$3(true) };


// https://github.com/zloirock/core-js/issues/280


// eslint-disable-next-line unicorn/no-unsafe-regex
var webkitStringPadBug = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

var $padEnd = stringPad.end;


// `String.prototype.padEnd` method
// https://tc39.github.io/ecma262/#sec-string.prototype.padend
_export({ target: 'String', proto: true, forced: webkitStringPadBug }, {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
  } });


var $padStart = stringPad.start;


// `String.prototype.padStart` method
// https://tc39.github.io/ecma262/#sec-string.prototype.padstart
_export({ target: 'String', proto: true, forced: webkitStringPadBug }, {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
  } });


// `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
var regexpFlags = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
// so we use an intermediate function.
function RE(s, f) {
  return RegExp(s, f);
}

var UNSUPPORTED_Y = fails(function () {
  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var re = RE('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

var BROKEN_CARET = fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = RE('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});

var regexpStickyHelpers = {
  UNSUPPORTED_Y: UNSUPPORTED_Y,
  BROKEN_CARET: BROKEN_CARET };


var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
}();

var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;
    var sticky = UNSUPPORTED_Y$1 && re.sticky;
    var flags = regexpFlags.call(re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = flags.replace('y', '');
      if (flags.indexOf('g') === -1) {
        flags += 'g';
      }

      strCopy = String(str).slice(re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = nativeExec.call(sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = match.input.slice(charsAdded);
        match[0] = match[0].slice(charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

var regexpExec = patchedExec;

var SPECIES$4 = wellKnownSymbol('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = function () {
  return 'a'.replace(/./, '$0') === '$0';
}();

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () {return originalExec.apply(this, arguments);};
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

var fixRegexpWellKnownSymbolLogic = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () {return 7;};
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES$4] = function () {return re;};
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () {execCalled = true;return null;};

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
  !DELEGATES_TO_SYMBOL ||
  !DELEGATES_TO_EXEC ||
  KEY === 'replace' && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0) ||
  KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
        }
        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
      }
      return { done: false };
    }, { REPLACE_KEEPS_$0: REPLACE_KEEPS_$0 });
    var stringMethod = methods[0];
    var regexMethod = methods[1];

    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2
    // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {return regexMethod.call(string, this, arg);}
    // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {return regexMethod.call(string, this);});

  }

  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
};

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod$4 = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size ||
    (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ?
    CONVERT_TO_STRING ? S.charAt(position) : first :
    CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$4(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$4(true) };


var charAt = stringMultibyte.charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
var advanceStringIndex = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};

// `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
var regexpExecAbstract = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }

  if (classofRaw(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};

var max$1 = Math.max;
var min$2 = Math.min;
var floor$2 = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
fixRegexpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
  return [
  // `String.prototype.replace` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = requireObjectCoercible(this);
    var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
    return replacer !== undefined ?
    replacer.call(searchValue, O, replaceValue) :
    nativeReplace.call(String(O), searchValue, replaceValue);
  },
  // `RegExp.prototype[@@replace]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
  function (regexp, replaceValue) {
    if (reason.REPLACE_KEEPS_$0 || typeof replaceValue === 'string' && replaceValue.indexOf('$0') === -1) {
      var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
      if (res.done) return res.value;
    }

    var rx = anObject(regexp);
    var S = String(this);

    var functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);

    var global = rx.global;
    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }
    var results = [];
    while (true) {
      var result = regexpExecAbstract(rx, S);
      if (result === null) break;

      results.push(result);
      if (!global) break;

      var matchStr = String(result[0]);
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
    }

    var accumulatedResult = '';
    var nextSourcePosition = 0;
    for (var i = 0; i < results.length; i++) {
      result = results[i];

      var matched = String(result[0]);
      var position = max$1(min$2(toInteger(result.index), S.length), 0);
      var captures = [];
      // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
      for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
      var namedCaptures = result.groups;
      if (functionalReplace) {
        var replacerArgs = [matched].concat(captures, position, S);
        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
        var replacement = String(replaceValue.apply(undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }
      if (position >= nextSourcePosition) {
        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }
    return accumulatedResult + S.slice(nextSourcePosition);
  }];


  // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return nativeReplace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$':return '$';
        case '&':return matched;
        case '`':return str.slice(0, position);
        case "'":return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor$2(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];}

      return capture === undefined ? '' : capture;
    });
  }
});

var non = '\u200B\u0085\u180E';

// check that a method works with the correct list
// of whitespaces and has a correct name
var forcedStringTrimMethod = function (METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};

var $trim = stringTrim.trim;


// `String.prototype.trim` method
// https://tc39.github.io/ecma262/#sec-string.prototype.trim
_export({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
  trim: function trim() {
    return $trim(this);
  } });


var $trimEnd = stringTrim.end;


var FORCED$3 = forcedStringTrimMethod('trimEnd');

var trimEnd = FORCED$3 ? function trimEnd() {
  return $trimEnd(this);
} : ''.trimEnd;

// `String.prototype.{ trimEnd, trimRight }` methods
// https://github.com/tc39/ecmascript-string-left-right-trim
_export({ target: 'String', proto: true, forced: FORCED$3 }, {
  trimEnd: trimEnd,
  trimRight: trimEnd });


var $trimStart = stringTrim.start;


var FORCED$4 = forcedStringTrimMethod('trimStart');

var trimStart = FORCED$4 ? function trimStart() {
  return $trimStart(this);
} : ''.trimStart;

// `String.prototype.{ trimStart, trimLeft }` methods
// https://github.com/tc39/ecmascript-string-left-right-trim
_export({ target: 'String', proto: true, forced: FORCED$4 }, {
  trimStart: trimStart,
  trimLeft: trimStart });


/* eslint-disable no-new */



var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

var ArrayBuffer$3 = global_1.ArrayBuffer;
var Int8Array$2 = global_1.Int8Array;

var typedArraysConstructorsRequiresWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails(function () {
  Int8Array$2(1);
}) || !fails(function () {
  new Int8Array$2(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array$2();
  new Int8Array$2(null);
  new Int8Array$2(1.5);
  new Int8Array$2(iterable);
}, true) || fails(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array$2(new ArrayBuffer$3(2), 1, undefined).length !== 1;
});

var toPositiveInteger = function (it) {
  var result = toInteger(it);
  if (result < 0) throw RangeError("The argument can't be less than 0");
  return result;
};

var toOffset = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw RangeError('Wrong offset');
  return offset;
};

var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;

var typedArrayFrom = function from(source /* , mapfn, thisArg */) {
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator, next;
  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    O = [];
    while (!(step = next.call(iterator)).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bindContext(mapfn, arguments[2], 2);
  }
  length = toLength(O.length);
  result = new (aTypedArrayConstructor$1(this))(length);
  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }
  return result;
};

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
var createMethod$5 = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = indexedObject(O);
    var boundFunction = bindContext(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;
    for (; length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
            case 3:return true; // some
            case 5:return value; // find
            case 6:return index; // findIndex
            case 2:push.call(target, value); // filter
          } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$5(0),
  // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  map: createMethod$5(1),
  // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  filter: createMethod$5(2),
  // `Array.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.some
  some: createMethod$5(3),
  // `Array.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.every
  every: createMethod$5(4),
  // `Array.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  find: createMethod$5(5),
  // `Array.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$5(6) };


// makes subclassing work correct for wrapped built-ins
var inheritIfRequired = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
  // it can work only with native `setPrototypeOf`
  objectSetPrototypeOf &&
  // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
  typeof (NewTarget = dummy.constructor) == 'function' &&
  NewTarget !== Wrapper &&
  isObject(NewTargetPrototype = NewTarget.prototype) &&
  NewTargetPrototype !== Wrapper.prototype)
  objectSetPrototypeOf($this, NewTargetPrototype);
  return $this;
};

var typedArrayConstructor = createCommonjsModule(function (module) {


















  var getOwnPropertyNames = objectGetOwnPropertyNames.f;

  var forEach = arrayIteration.forEach;






  var getInternalState = internalState.get;
  var setInternalState = internalState.set;
  var nativeDefineProperty = objectDefineProperty.f;
  var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  var round = Math.round;
  var RangeError = global_1.RangeError;
  var ArrayBuffer = arrayBuffer.ArrayBuffer;
  var DataView = arrayBuffer.DataView;
  var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
  var TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;
  var TypedArray = arrayBufferViewCore.TypedArray;
  var TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;
  var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
  var isTypedArray = arrayBufferViewCore.isTypedArray;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var WRONG_LENGTH = 'Wrong length';

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = new (aTypedArrayConstructor(C))(length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key) {
    nativeDefineProperty(it, key, { get: function () {
        return getInternalState(this)[key];
      } });
  };

  var isArrayBuffer = function (it) {
    var klass;
    return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
  };

  var isTypedArrayIndex = function (target, key) {
    return isTypedArray(target) &&
    typeof key != 'symbol' &&
    key in target &&
    String(+key) == String(key);
  };

  var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
    return isTypedArrayIndex(target, key = toPrimitive(key, true)) ?
    createPropertyDescriptor(2, target[key]) :
    nativeGetOwnPropertyDescriptor(target, key);
  };

  var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
    if (isTypedArrayIndex(target, key = toPrimitive(key, true)) &&
    isObject(descriptor) &&
    has(descriptor, 'value') &&
    !has(descriptor, 'get') &&
    !has(descriptor, 'set')
    // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable && (
    !has(descriptor, 'writable') || descriptor.writable) && (
    !has(descriptor, 'enumerable') || descriptor.enumerable))
    {
      target[key] = descriptor.value;
      return target;
    }return nativeDefineProperty(target, key, descriptor);
  };

  if (descriptors) {
    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;
      objectDefineProperty.f = wrappedDefineProperty;
      addGetter(TypedArrayPrototype, 'buffer');
      addGetter(TypedArrayPrototype, 'byteOffset');
      addGetter(TypedArrayPrototype, 'byteLength');
      addGetter(TypedArrayPrototype, 'length');
    }

    _export({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
      getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
      defineProperty: wrappedDefineProperty });


    module.exports = function (TYPE, wrapper, CLAMPED) {
      var BYTES = TYPE.match(/\d+$/)[0] / 8;
      var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
      var GETTER = 'get' + TYPE;
      var SETTER = 'set' + TYPE;
      var NativeTypedArrayConstructor = global_1[CONSTRUCTOR_NAME];
      var TypedArrayConstructor = NativeTypedArrayConstructor;
      var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
      var exported = {};

      var getter = function (that, index) {
        var data = getInternalState(that);
        return data.view[GETTER](index * BYTES + data.byteOffset, true);
      };

      var setter = function (that, index, value) {
        var data = getInternalState(that);
        if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
        data.view[SETTER](index * BYTES + data.byteOffset, value, true);
      };

      var addElement = function (that, index) {
        nativeDefineProperty(that, index, {
          get: function () {
            return getter(this, index);
          },
          set: function (value) {
            return setter(this, index, value);
          },
          enumerable: true });

      };

      if (!NATIVE_ARRAY_BUFFER_VIEWS) {
        TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
          anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
          var index = 0;
          var byteOffset = 0;
          var buffer, byteLength, length;
          if (!isObject(data)) {
            length = toIndex(data);
            byteLength = length * BYTES;
            buffer = new ArrayBuffer(byteLength);
          } else if (isArrayBuffer(data)) {
            buffer = data;
            byteOffset = toOffset(offset, BYTES);
            var $len = data.byteLength;
            if ($length === undefined) {
              if ($len % BYTES) throw RangeError(WRONG_LENGTH);
              byteLength = $len - byteOffset;
              if (byteLength < 0) throw RangeError(WRONG_LENGTH);
            } else {
              byteLength = toLength($length) * BYTES;
              if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
            }
            length = byteLength / BYTES;
          } else if (isTypedArray(data)) {
            return fromList(TypedArrayConstructor, data);
          } else {
            return typedArrayFrom.call(TypedArrayConstructor, data);
          }
          setInternalState(that, {
            buffer: buffer,
            byteOffset: byteOffset,
            byteLength: byteLength,
            length: length,
            view: new DataView(buffer) });

          while (index < length) addElement(that, index++);
        });

        if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
        TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate(TypedArrayPrototype);
      } else if (typedArraysConstructorsRequiresWrappers) {
        TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
          anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
          return inheritIfRequired(function () {
            if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
            if (isArrayBuffer(data)) return $length !== undefined ?
            new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) :
            typedArrayOffset !== undefined ?
            new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) :
            new NativeTypedArrayConstructor(data);
            if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
            return typedArrayFrom.call(TypedArrayConstructor, data);
          }(), dummy, TypedArrayConstructor);
        });

        if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
        forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
          if (!(key in TypedArrayConstructor)) {
            createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
          }
        });
        TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
      }

      if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
      }

      if (TYPED_ARRAY_TAG) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
      }

      exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

      _export({
        global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS },
      exported);

      if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
        createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
      }

      if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
      }

      setSpecies(CONSTRUCTOR_NAME);
    };
  } else module.exports = function () {/* empty */};
});

// `Float32Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Float32', function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

// `Float64Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Float64', function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

// `Int8Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Int8', function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

// `Int16Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Int16', function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

// `Int32Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Int32', function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

// `Uint8Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Uint8', function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

// `Uint8ClampedArray` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Uint8', function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

// `Uint16Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Uint16', function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

// `Uint32Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Uint32', function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var exportTypedArrayStaticMethod$1 = arrayBufferViewCore.exportTypedArrayStaticMethod;


// `%TypedArray%.from` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.from
exportTypedArrayStaticMethod$1('from', typedArrayFrom, typedArraysConstructorsRequiresWrappers);

var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayStaticMethod$2 = arrayBufferViewCore.exportTypedArrayStaticMethod;

// `%TypedArray%.of` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.of
exportTypedArrayStaticMethod$2('of', function of() /* ...items */{
  var index = 0;
  var length = arguments.length;
  var result = new (aTypedArrayConstructor$2(this))(length);
  while (length > index) result[index] = arguments[index++];
  return result;
}, typedArraysConstructorsRequiresWrappers);

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
    args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true });

  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

// Copyright Node.js contributors. All rights reserved.
var kNodeModulesRE = /^(.*)[\\/]node_modules[\\/]/;
var customInspectSymbol = Symbol.for('nodejs.util.inspect.custom');
var isBuffer = Symbol.for('titanium.buffer.isBuffer');
var colorRegExp = /\u001b\[\d\d?m/g; // eslint-disable-line no-control-regex

function removeColors(str) {
  return str.replace(colorRegExp, '');
}
function isError(e) {
  // An error could be an instance of Error while not being a native error
  // or could be from a different realm and not be instance of Error but still
  // be a native error.
  return isNativeError(e) || e instanceof Error;
}
var getStructuredStack;

class StackTraceError extends Error {}

StackTraceError.prepareStackTrace = (err, trace) => trace;

StackTraceError.stackTraceLimit = Infinity;
function isInsideNodeModules() {
  if (getStructuredStack === undefined) {
    getStructuredStack = () => new StackTraceError().stack;
  }

  var stack = getStructuredStack(); // stack is only an array on v8, try to convert manually if string

  if (typeof stack === 'string') {
    var stackFrames = [];
    var lines = stack.split(/\n/);

    for (var line of lines) {
      var lineInfo = line.match(/(.*)@(.*):(\d+):(\d+)/);

      if (lineInfo) {
        (function () {
          var filename = lineInfo[2].replace('file://', '');
          stackFrames.push({
            getFileName: () => filename });

        })();
      }
    }

    stack = stackFrames;
  } // Iterate over all stack frames and look for the first one not coming
  // from inside Node.js itself:


  if (Array.isArray(stack)) {
    for (var frame of stack) {
      var filename = frame.getFileName(); // If a filename does not start with / or contain \,
      // it's likely from Node.js core.

      if (!/^\/|\\/.test(filename)) {
        continue;
      }

      return kNodeModulesRE.test(filename);
    }
  }

  return false;
}
function join(output, separator) {
  var str = '';

  if (output.length !== 0) {
    var lastIndex = output.length - 1;

    for (var i = 0; i < lastIndex; i++) {
      // It is faster not to use a template string here
      str += output[i];
      str += separator;
    }

    str += output[lastIndex];
  }

  return str;
}
function uncurryThis(f) {
  return function () {
    return f.call.apply(f, arguments);
  };
}
var ALL_PROPERTIES = 0;
var ONLY_ENUMERABLE = 2;
var propertyFilter = {
  ALL_PROPERTIES,
  ONLY_ENUMERABLE };

function getOwnNonIndexProperties(obj, filter) {
  var props = [];
  var keys = filter === ONLY_ENUMERABLE ? Object.keys(obj) : Object.getOwnPropertyNames(obj);

  for (var i = 0; i < keys.length; ++i) {
    var key = keys[i];

    if (!isAllDigits(key)) {
      props.push(key);
    }
  }

  return props;
}

function isAllDigits(s) {
  if (s.length === 0) {
    return false;
  }

  for (var i = 0; i < s.length; ++i) {
    var code = s.charCodeAt(i);

    if (code < 48 || code > 57) {
      return false;
    }
  }

  return true;
}

// Copyright Node.js contributors. All rights reserved.
var TypedArrayPrototype$1 = Object.getPrototypeOf(Uint8Array.prototype);
var TypedArrayProto_toStringTag = uncurryThis(Object.getOwnPropertyDescriptor(TypedArrayPrototype$1, Symbol.toStringTag).get);

function checkPrototype(value, name) {
  if (typeof value !== 'object') {
    return false;
  }

  return Object.prototype.toString.call(value) === "[object ".concat(name, "]");
}

function isAnyArrayBuffer(value) {
  if (isArrayBuffer(value)) {
    return true;
  }

  return isSharedArrayBuffer(value);
}
function isArgumentsObject(value) {
  return checkPrototype(value, 'Arguments');
}
function isArrayBuffer(value) {
  return checkPrototype(value, 'ArrayBuffer');
} // Cached to make sure no userland code can tamper with it.

var isArrayBufferView = ArrayBuffer.isView;
function isAsyncFunction(value) {
  return checkPrototype(value, 'AsyncFunction');
}
function isBigInt64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'BigInt64Array';
}
function isBigUint64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'BigUint64Array';
}
function isBooleanObject(value) {
  return checkPrototype(value, 'Boolean');
}
function isBoxedPrimitive(value) {
  if (typeof value !== 'object') {
    return false;
  }

  return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) // || isBigIntObject(value)
  || isSymbolObject(value);
}
function isDataView(value) {
  return checkPrototype(value, 'DataView');
}
function isDate(value) {
  return checkPrototype(value, 'Date');
} // @todo isExternal

function isFloat32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Float32Array';
}
function isFloat64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Float64Array';
}
function isGeneratorFunction(value) {
  return checkPrototype(value, 'GeneratorFunction');
}
function isGeneratorObject(value) {
  return checkPrototype(value, 'GeneratorObject');
}
function isInt8Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int8Array';
}
function isInt16Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int16Array';
}
function isInt32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int32Array';
}
function isMap(value) {
  return checkPrototype(value, 'Map');
}
function isMapIterator(value) {
  if (typeof value !== 'object') {
    return false;
  }

  var prototype = Object.getPrototypeOf(value);
  return prototype && prototype[Symbol.toStringTag] === 'Map Iterator';
} // @todo isModuleNamespaceObject

function isNativeError(value) {
  // if not an instance of an Error, definitely not a native error
  if (!(value instanceof Error)) {
    return false;
  }

  if (!value || !value.constructor) {
    return false;
  }

  return ['Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError'].includes(value.constructor.name);
}
function isNumberObject(value) {
  return checkPrototype(value, 'Number');
}
function isPromise(value) {
  return checkPrototype(value, 'Promise');
} // @todo isProxy

function isRegExp(value) {
  return checkPrototype(value, 'RegExp');
}
function isSet(value) {
  return checkPrototype(value, 'Set');
}
function isSetIterator(value) {
  if (typeof value !== 'object') {
    return false;
  }

  var prototype = Object.getPrototypeOf(value);
  return prototype && prototype[Symbol.toStringTag] === 'Set Iterator';
}
function isSharedArrayBuffer(value) {
  if (!global.SharedArrayBuffer) {
    return false;
  }

  return checkPrototype(value, 'SharedArrayBuffer');
}
function isStringObject(value) {
  return checkPrototype(value, 'String');
}
function isSymbolObject(value) {
  return checkPrototype(value, 'Symbol');
}
function isTypedArray$1(value) {
  var isBuiltInTypedArray = TypedArrayProto_toStringTag(value) !== undefined;

  if (isBuiltInTypedArray) {
    return true;
  }

  return value[isBuffer] === true;
}
function isUint8Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint8Array';
}
function isUint8ClampedArray(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint8ClampedArray';
}
function isUint16Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint16Array';
}
function isUint32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint32Array';
}
function isWeakMap(value) {
  return checkPrototype(value, 'WeakMap');
}
function isWeakSet(value) {
  return checkPrototype(value, 'WeakSet');
} // @todo isWebAssemblyCompiledModule

var types = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isAnyArrayBuffer: isAnyArrayBuffer,
  isArgumentsObject: isArgumentsObject,
  isArrayBuffer: isArrayBuffer,
  isArrayBufferView: isArrayBufferView,
  isAsyncFunction: isAsyncFunction,
  isBigInt64Array: isBigInt64Array,
  isBigUint64Array: isBigUint64Array,
  isBooleanObject: isBooleanObject,
  isBoxedPrimitive: isBoxedPrimitive,
  isDataView: isDataView,
  isDate: isDate,
  isFloat32Array: isFloat32Array,
  isFloat64Array: isFloat64Array,
  isGeneratorFunction: isGeneratorFunction,
  isGeneratorObject: isGeneratorObject,
  isInt8Array: isInt8Array,
  isInt16Array: isInt16Array,
  isInt32Array: isInt32Array,
  isMap: isMap,
  isMapIterator: isMapIterator,
  isNativeError: isNativeError,
  isNumberObject: isNumberObject,
  isPromise: isPromise,
  isRegExp: isRegExp,
  isSet: isSet,
  isSetIterator: isSetIterator,
  isSharedArrayBuffer: isSharedArrayBuffer,
  isStringObject: isStringObject,
  isSymbolObject: isSymbolObject,
  isTypedArray: isTypedArray$1,
  isUint8Array: isUint8Array,
  isUint8ClampedArray: isUint8ClampedArray,
  isUint16Array: isUint16Array,
  isUint32Array: isUint32Array,
  isWeakMap: isWeakMap,
  isWeakSet: isWeakSet });


// Copyright Node.js contributors. All rights reserved.
var error;

function lazyError() {
  if (!error) {
    // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
    // error = require('./errors').codes.ERR_INTERNAL_ASSERTION;
    error = codes.ERR_INTERNAL_ASSERTION;
  }

  return error;
}

function assert(value, message) {
  if (!value) {
    var ERR_INTERNAL_ASSERTION = lazyError();
    throw new ERR_INTERNAL_ASSERTION(message);
  }
}

function fail(message) {
  var ERR_INTERNAL_ASSERTION = lazyError();
  throw new ERR_INTERNAL_ASSERTION(message);
}

assert.fail = fail;

// Copyright Node.js contributors. All rights reserved.
var messages = new Map();
var codes = {}; // @todo implement this once needed

class SystemError extends Error {} // Utility function for registering the error codes.


function E(sym, val, def, ...otherClasses) {
  // Special case for SystemError that formats the error message differently
  // The SystemErrors only have SystemError as their base classes.
  messages.set(sym, val);

  if (def === SystemError) {
    throw new Error('Node compatible SystemError not yet implemented.');
  } else {
    def = makeNodeErrorWithCode(def, sym);
  }

  if (otherClasses.length !== 0) {
    otherClasses.forEach(clazz => {
      def[clazz.name] = makeNodeErrorWithCode(clazz, sym);
    });
  }

  codes[sym] = def;
}

function makeNodeErrorWithCode(Base, key) {
  return class NodeError extends Base {
    constructor(...args) {
      super();
      var message = getMessage(key, args, this);
      Object.defineProperty(this, 'message', {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true });

      addCodeToName(this, super.name, key);
    }

    get code() {
      return key;
    }

    set code(value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true });

    }

    toString() {
      return "".concat(this.name, " [").concat(key, "]: ").concat(this.message);
    }};


}

function getMessage(key, args, self) {
  var msg = messages.get(key);
  /*
                               // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
                               if (assert === undefined) {
                               	assert = require('./internal/assert');
                               }
                               */

  if (typeof msg === 'function') {
    assert(msg.length <= args.length, // Default options do not count.
    "Code: ".concat(key, "; The provided arguments length (").concat(args.length, ") does not ") + "match the required ones (".concat(msg.length, ")."));
    return msg.apply(self, args);
  }

  var expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
  assert(expectedLength === args.length, "Code: ".concat(key, "; The provided arguments length (").concat(args.length, ") does not ") + "match the required ones (".concat(expectedLength, ")."));

  if (args.length === 0) {
    return msg;
  }

  args.unshift(msg);
  return format.apply(null, args); // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
  // return lazyInternalUtilInspect().format.apply(null, args);
}

function addCodeToName(err, name, code) {
  // Add the error code to the name to include it in the stack trace.
  err.name = "".concat(name, " [").concat(code, "]"); // Access the stack to generate the error message including the error code
  // from the name.
  // @fixme: This only works on V8/Android, iOS/JSC has a different Error structure.
  // should we try to make errors behave the same across platforms?
  // eslint-disable-next-line no-unused-expressions

  err.stack; // Reset the name to the actual name.

  if (name === 'SystemError') {
    Object.defineProperty(err, 'name', {
      value: name,
      enumerable: false,
      writable: true,
      configurable: true });

  } else {
    delete err.name;
  }
}

E('ERR_INTERNAL_ASSERTION', message => {
  var suffix = 'This is caused by either a bug in Titanium ' + 'or incorrect usage of Titanium internals.\n' + 'Please open an issue with this stack trace at ' + 'https://jira.appcelerator.org\n';
  return message === undefined ? suffix : "".concat(message, "\n").concat(suffix);
}, Error);
E('ERR_INVALID_ARG_TYPE', (name, expected, actual) => {
  assert(typeof name === 'string', '\'name\' must be a string'); // determiner: 'must be' or 'must not be'

  var determiner;

  if (typeof expected === 'string' && expected.startsWith('not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (name.endsWith(' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = name.includes('.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } // TODO(BridgeAR): Improve the output by showing `null` and similar.


  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
var maxStack_ErrorName;
var maxStack_ErrorMessage;
/**
                            * Returns true if `err.name` and `err.message` are equal to engine-specific
                            * values indicating max call stack size has been exceeded.
                            * "Maximum call stack size exceeded" in V8.
                            *
                            * @param {Error} err The error to check
                            * @returns {boolean}
                            */

function isStackOverflowError(err) {
  if (maxStack_ErrorMessage === undefined) {
    try {
      function overflowStack() {
        overflowStack();
      }

      overflowStack();
    } catch (e) {
      maxStack_ErrorMessage = e.message;
      maxStack_ErrorName = e.name;
    }
  }

  return err.name === maxStack_ErrorName && err.message === maxStack_ErrorMessage;
}

function oneOf(expected, thing) {
  assert(typeof thing === 'string', '`thing` has to be of type string');

  if (Array.isArray(expected)) {
    var len = expected.length;
    assert(len > 0, 'At least one expected value needs to be specified');
    expected = expected.map(i => String(i));

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}

var {
  ALL_PROPERTIES: ALL_PROPERTIES$1,
  ONLY_ENUMERABLE: ONLY_ENUMERABLE$1 } =
propertyFilter; // https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings

var TI_CODEC_MAP = new Map();
TI_CODEC_MAP.set('utf-8', Ti.Codec.CHARSET_UTF8);
TI_CODEC_MAP.set('utf8', Ti.Codec.CHARSET_UTF8);
TI_CODEC_MAP.set('utf-16le', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('utf16le', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('ucs2', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('ucs-2', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('latin1', Ti.Codec.CHARSET_ISO_LATIN_1);
TI_CODEC_MAP.set('binary', Ti.Codec.CHARSET_ISO_LATIN_1);
TI_CODEC_MAP.set('ascii', Ti.Codec.CHARSET_ASCII); // We have no equivalents of base64 or hex, so we convert them internally here

var VALID_ENCODINGS = ['hex', 'utf8', 'utf-8', 'ascii', 'latin1', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le']; // Used to cheat for read/writes of doubles

var doubleArray = new Float64Array(1);
var uint8DoubleArray = new Uint8Array(doubleArray.buffer); // Used to cheat to read/write floats

var floatArray = new Float32Array(1);
var uint8FloatArray = new Uint8Array(floatArray.buffer);
var INSPECT_MAX_BYTES = 50;

class Buffer$1 {
  /**
                 * Constructs a new buffer.
                 *
                 * Primarily used internally in this module together with `newBuffer` to
                 * create a new Buffer instance wrapping a Ti.Buffer.
                 *
                 * Also supports the deprecated Buffer() constructors which are safe
                 * to use outside of this module.
                 *
                 * @param {integer[]|Buffer|integer|string|Ti.Buffer} arg
                 * @param {string|integer} encodingOrOffset
                 * @param {integer} length
                 */
  constructor(arg, encodingOrOffset, length) {
    if (typeof arg !== 'object' || arg.apiName !== 'Ti.Buffer') {
      showFlaggedDeprecation();

      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new TypeError("The \"string\" argument must be of type \"string\". Received type ".concat(typeof arg));
        }

        return Buffer$1.alloc(arg);
      }

      return Buffer$1.from(arg, encodingOrOffset, length);
    }

    var tiBuffer = arg;
    var start = encodingOrOffset;

    if (start === undefined) {
      start = 0;
    }

    if (length === undefined) {
      length = tiBuffer.length - start;
    }

    Object.defineProperties(this, {
      byteOffset: {
        value: start },

      length: {
        value: length },

      _tiBuffer: {
        value: tiBuffer } });

    // FIXME: Support .buffer property that holds an ArrayBuffer!
  }
  /**
     * 0 is returned if target is the same as buf
     * 1 is returned if target should come before buf when sorted.
     * -1 is returned if target should come after buf when sorted.
     * @param {Buffer} target Buffer to compare against
     * @param {integer} [targetStart=0] index to start in target
     * @param {integer} [targetEnd=target.length] index to end in target
     * @param {integer} [sourceStart=0] index to start in this Buffer
     * @param {integer} [sourceEnd=this.length] index to end in this Buffer
     * @returns {integer}
     */


  compare(target, targetStart, targetEnd, sourceStart, sourceEnd) {
    if (!Buffer$1.isBuffer(target)) {
      throw new TypeError("The \"target\" argument must be one of type Buffer or Uint8Array. Received type ".concat(typeof buf1));
    }

    if (targetStart === undefined) {
      targetStart = 0;
    }

    if (sourceStart === undefined) {
      sourceStart = 0;
    }

    if (targetEnd === undefined) {
      targetEnd = target.length;
    }

    if (sourceEnd === undefined) {
      sourceEnd = this.length;
    } // ERR_OUT_OF_RANGE is thrown if targetStart < 0, sourceStart < 0, targetEnd > target.byteLength, or sourceEnd > source.byteLength


    if (targetStart < 0 || sourceStart < 0 || targetEnd > target.length || sourceEnd > this.length) {
      throw new RangeError('Index out of range'); // FIXME: set "code" to ERR_INDEX_OUT_OF_RANGE
    } // Use slices to make the loop easier


    var source = this.slice(sourceStart, sourceEnd);
    var sourceLength = source.length;
    var dest = target.slice(targetStart, targetEnd);
    var destLength = dest.length;
    var length = Math.min(sourceLength, destLength);

    for (var i = 0; i < length; i++) {
      var targetValue = getAdjustedIndex(dest, i);
      var sourceValue = getAdjustedIndex(source, i);

      if (targetValue !== sourceValue) {
        // No match! Return 1 or -1 based on what is greater!
        if (sourceValue < targetValue) {
          return -1;
        }

        return 1;
      }
    } // sort based on length!


    if (sourceLength < destLength) {
      return -1;
    }

    if (sourceLength > destLength) {
      return 1;
    }

    return 0;
  }
  /**
     * Copies from this to target
     * @param {Buffer} target destination we're copying into
     * @param {integer} [targetStart=0] start index to copy into in destination Buffer
     * @param {integer} [sourceStart=0] start index to copy from within `this`
     * @param {integer} [sourceEnd=this.length] end index to copy from within `this`
     * @returns {integer} number of bytes copied
     */


  copy(target, targetStart, sourceStart, sourceEnd) {
    if (targetStart === undefined) {
      targetStart = 0;
    }

    if (sourceStart === undefined) {
      sourceStart = 0;
    }

    if (sourceEnd === undefined) {
      sourceEnd = this.length;
    }

    if (sourceStart === sourceEnd) {
      return 0;
    }

    if (target.length === 0 || this.length === 0) {
      return 0;
    } // TODO: check for out of bounds?


    var length = sourceEnd - sourceStart; // Cap length to remaining bytes in target!

    var remaining = target.length - targetStart;

    if (length > remaining) {
      length = remaining;
    } // TODO: handle overlap when target === this!
    // TODO: Do we need to take target or this.byteOffset into account here?


    target._tiBuffer.copy(this._tiBuffer, targetStart, sourceStart, length);

    return length;
  }
  /**
     * Creates and returns an iterator of [index, byte] pairs from the contents of buf.
     * @returns {Iterator}
     */


  entries() {
    var buffer = this;
    var nextIndex = 0;
    var end = this.length;
    var entryIterator = {
      next: function () {
        if (nextIndex < end) {
          var result = {
            value: [nextIndex, getAdjustedIndex(buffer, nextIndex)],
            done: false };

          nextIndex++;
          return result;
        }

        return {
          value: undefined,
          done: true };

      },
      [Symbol.iterator]: function () {
        return this;
      } };

    return entryIterator;
  }

  equals(otherBuffer) {
    if (!Buffer$1.isBuffer(otherBuffer)) {
      throw new TypeError('argument must be a Buffer');
    }

    if (otherBuffer === this) {
      return true;
    }

    return this.compare(otherBuffer) === 0;
  }
  /**
     * @param {string|Buffer|UInt8Array|integer} value The value with which to fill `buf`.
     * @param {integer} [offset=0] Number of bytes to skip before starting to fill `buf`
     * @param {integer} [end] Where to stop filling buf (not inclusive). `buf.length` by default
     * @param {string} [encoding='utf8'] The encoding for `value` if `value` is a string.
     * @returns {this}
     */


  fill(value, offset, end, encoding) {
    var offsetType = typeof offset;

    if (offsetType === 'undefined') {
      // value supplied
      offset = 0;
      end = this.length;
      encoding = 'utf8';
    } else if (offsetType === 'string') {
      // value, encoding supplied
      encoding = offset;
      offset = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      // value, offset, encoding supplied
      encoding = end;
      end = this.length;
    }

    var valueType = typeof value;

    if (valueType === 'string') {
      var bufToFillWith = Buffer$1.from(value, encoding);
      var fillBufLength = bufToFillWith.length;

      if (fillBufLength === 0) {
        throw new Error('no valid fill data');
      } // If the buffer length === 1, we can just do this._tiBuffer.fill(value, offset, end);


      if (fillBufLength === 1) {
        this._tiBuffer.fill(bufToFillWith._tiBuffer[0], offset, end);

        return this;
      } // multiple byte fill!


      var length = end - offset;

      for (var i = 0; i < length; i++) {
        // TODO: Do we need to account for byteOffset here (on `this`, not on the buffer we just created)?
        var fillChar = bufToFillWith._tiBuffer[i % fillBufLength];
        this._tiBuffer[i + offset] = fillChar;
      }

      return this;
    } // if the value is a number (or a buffer with a single byte) we can use tiBuffer.fill();


    this._tiBuffer.fill(value, offset, end);

    return this;
  }

  includes(value, byteOffset, encoding) {
    return this.indexOf(value, byteOffset, encoding) !== -1;
  }
  /**
     * @param {string|Buffer|integer} value What to search for
     * @param {integer} [byteOffset=0] Where to begin searching in buf. If negative, then offset is calculated from the end of buf
     * @param {string} [encoding='utf8'] If value is a string, this is the encoding used to determine the binary representation of the string that will be searched for in buf
     * @returns {integer} The index of the first occurrence of value in buf, or -1 if buf does not contain value.
     */


  indexOf(value, byteOffset, encoding) {
    if (this.length === 0) {
      // empty buffer? can't find anything!
      return -1;
    } // if byteOffset is undefined, make it 0


    if (typeof byteOffset === 'undefined') {
      byteOffset = 0;
    } else if (typeof byteOffset === 'string') {
      // if it's a string, that's actually encoding
      encoding = byteOffset;
      byteOffset = 0;
    } // if we don't have an encoding yet, use utf8


    if (typeof encoding !== 'string') {
      encoding = 'utf8';
    }

    if (byteOffset < 0) {
      // convert negative indices
      byteOffset = this.length + byteOffset;

      if (byteOffset < 0) {
        // still negative? start at 0
        byteOffset = 0;
      }
    } else if (byteOffset >= this.length) {
      return -1; // can't find past end of buffer!
    }

    if (typeof value === 'number') {
      value &= 0xFF; // clamp to 255
      // This is a simpler case, we have a single byte we need to search for
      // so just loop through and try to find it

      return indexOf$1(this, value, byteOffset);
    } // coerce a string to a Buffer


    if (typeof value === 'string') {
      value = Buffer$1.from(value, encoding);
    } // value is now a Buffer...


    var matchLength = value.length;

    if (matchLength === 0) {
      return -1; // never find empty value!
    }

    if (matchLength === 1) {
      // simple case, match one byte!
      return indexOf$1(this, value[0], byteOffset);
    }

    var currentIndex = byteOffset;
    var thisLength = this.length;

    if (matchLength > thisLength) {
      return -1; // can't match if the value is longer than this Buffer!
    } // FIXME: Can we rewrite this in a less funky way?
    // FIXME: Can stop earlier based on matchLength!


    firstMatch: while (currentIndex < thisLength) {
      // eslint-disable-line no-labels
      // match first byte!
      var firstByteMatch = indexOf$1(this, value[0], currentIndex);

      if (firstByteMatch === -1) {
        // couldn't even match the very first byte, so no match overall!
        return -1;
      } // ok, we found the first byte, now we need to see if the next consecutive bytes match!


      for (var x = 1; x < matchLength; x++) {
        if (firstByteMatch + x >= thisLength) {
          currentIndex = firstByteMatch + 1; // move past our first match

          continue firstMatch; // eslint-disable-line no-labels
        }

        if (this[firstByteMatch + x] !== value[x]) {
          // didn't match!
          currentIndex = firstByteMatch + 1; // move past our first match

          continue firstMatch; // eslint-disable-line no-labels
        }
      }

      return firstByteMatch; // the rest matched, hurray!
    }

    return -1;
  }

  keys() {
    var nextIndex = 0;
    var end = this.length;
    var myIterator = {
      next: function () {
        if (nextIndex < end) {
          var result = {
            value: nextIndex,
            done: false };

          nextIndex++;
          return result;
        }

        return {
          value: undefined,
          done: true };

      },
      [Symbol.iterator]: function () {
        return this;
      } };

    return myIterator;
  }
  /**
     * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 8
     * @returns {double} Reads a 64-bit double from buf at the specified offset with specified endian format
     */


  readDoubleBE(offset = 0) {
    checkOffset(this, offset, 8); // Node cheats and uses a Float64Array and UInt8Array backed by the same buffer
    // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float64Array
    // FIXME: This assumes LE system byteOrder

    uint8DoubleArray[7] = this[offset++];
    uint8DoubleArray[6] = this[offset++];
    uint8DoubleArray[5] = this[offset++];
    uint8DoubleArray[4] = this[offset++];
    uint8DoubleArray[3] = this[offset++];
    uint8DoubleArray[2] = this[offset++];
    uint8DoubleArray[1] = this[offset++];
    uint8DoubleArray[0] = this[offset++];
    return doubleArray[0];
  }
  /**
     * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 8
     * @returns {double} Reads a 64-bit double from buf at the specified offset with specified endian format
     */


  readDoubleLE(offset = 0) {
    checkOffset(this, offset, 8); // Node cheats and uses a Float64Array and UInt8Array backed by the same buffer
    // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float64Array
    // FIXME: This assumes LE system byteOrder

    uint8DoubleArray[0] = this[offset++];
    uint8DoubleArray[1] = this[offset++];
    uint8DoubleArray[2] = this[offset++];
    uint8DoubleArray[3] = this[offset++];
    uint8DoubleArray[4] = this[offset++];
    uint8DoubleArray[5] = this[offset++];
    uint8DoubleArray[6] = this[offset++];
    uint8DoubleArray[7] = this[offset++];
    return doubleArray[0];
  }
  /**
     * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4
     * @returns {float} Reads a 32-bit float from buf at the specified offset with specified endian format
     */


  readFloatBE(offset = 0) {
    checkOffset(this, offset, 4); // Node cheats and uses a Float32Array and UInt8Array backed by the same buffer
    // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float32Array
    // FIXME: This assumes LE system byteOrder

    uint8FloatArray[3] = this[offset++];
    uint8FloatArray[2] = this[offset++];
    uint8FloatArray[1] = this[offset++];
    uint8FloatArray[0] = this[offset++];
    return floatArray[0];
  }
  /**
     * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4
     * @returns {float} Reads a 32-bit float from buf at the specified offset with specified endian format
     */


  readFloatLE(offset = 0) {
    checkOffset(this, offset, 4); // Node cheats and uses a Float32Array and UInt8Array backed by the same buffer
    // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float32Array
    // FIXME: This assumes LE system byteOrder

    uint8FloatArray[0] = this[offset++];
    uint8FloatArray[1] = this[offset++];
    uint8FloatArray[2] = this[offset++];
    uint8FloatArray[3] = this[offset++];
    return floatArray[0];
  }
  /**
     * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 1.
     * @returns {integer}
     */


  readInt8(offset = 0) {
    var unsignedValue = this.readUInt8(offset);
    return unsignedToSigned(unsignedValue, 1);
  }
  /**
     * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
     * @returns {integer}
     */


  readInt16BE(offset) {
    var unsignedValue = this.readUInt16BE(offset);
    return unsignedToSigned(unsignedValue, 2);
  }
  /**
     * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
     * @returns {integer}
     */


  readInt16LE(offset = 0) {
    var unsignedValue = this.readUInt16LE(offset);
    return unsignedToSigned(unsignedValue, 2);
  }
  /**
     * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
     * @returns {integer}
     */


  readInt32BE(offset = 0) {
    var unsignedValue = this.readUInt32BE(offset);
    return unsignedToSigned(unsignedValue, 4);
  }
  /**
     * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
     * @returns {integer}
     */


  readInt32LE(offset = 0) {
    var unsignedValue = this.readUInt32LE(offset);
    return unsignedToSigned(unsignedValue, 4);
  }
  /**
     * Reads byteLength number of bytes from buf at the specified offset and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy.
     * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
     * @param {integer} byteLength umber of bytes to read. Must satisfy 0 < byteLength <= 6.
     * @returns {integer}
     */


  readIntBE(offset, byteLength) {
    var unsignedValue = this.readUIntBE(offset, byteLength);
    return unsignedToSigned(unsignedValue, byteLength);
  }
  /**
     * Reads byteLength number of bytes from buf at the specified offset and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy.
     * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
     * @param {integer} byteLength umber of bytes to read. Must satisfy 0 < byteLength <= 6.
     * @returns {integer}
     */


  readIntLE(offset, byteLength) {
    var unsignedValue = this.readUIntLE(offset, byteLength);
    return unsignedToSigned(unsignedValue, byteLength);
  }
  /**
     * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 1.
     * @returns {integer}
     */


  readUInt8(offset = 0) {
    checkOffset(this, offset, 1);
    return this[offset];
  }
  /**
     * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
     * @returns {integer}
     */


  readUInt16BE(offset = 0) {
    checkOffset(this, offset, 2); // first byte shifted and OR'd with second byte

    return this[offset] << 8 | this[offset + 1];
  }
  /**
     * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
     * @returns {integer}
     */


  readUInt16LE(offset = 0) {
    checkOffset(this, offset, 2); // first byte OR'd with second byte shifted

    return this[offset] | this[offset + 1] << 8;
  }
  /**
     * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
     * @returns {integer}
     */


  readUInt32BE(offset = 0) {
    checkOffset(this, offset, 4);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]); // rather than shifting by << 24, multiply the first byte and add it in so we don't retain the "sign bit"
    // (because bit-wise operators assume a 32-bit number)
  }
  /**
     * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
     * @returns {integer}
     */


  readUInt32LE(offset = 0) {
    checkOffset(this, offset, 4);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000; // rather than shifting by << 24, multiply the last byte and add it in so we don't retain the "sign bit"
  }
  /**
     * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
     * @param {integer} byteLength Number of bytes to read. Must satisfy 0 < byteLength <= 6.
     * @returns {integer}
     */


  readUIntBE(offset, byteLength) {
    if (byteLength <= 0 || byteLength > 6) {
      throw new RangeError('Index out of range');
    }

    checkOffset(this, offset, byteLength);
    var result = 0;
    var multiplier = 1; // we use a multipler for each byte
    // we're doing the same loop as #readUIntLE, just backwards!

    for (var i = byteLength - 1; i >= 0; i--) {
      result += getAdjustedIndex(this, offset + i) * multiplier;
      multiplier *= 0x100; // move multiplier to next byte
    }

    return result;
  }
  /**
     * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
     * @param {integer} byteLength Number of bytes to read. Must satisfy 0 < byteLength <= 6.
     * @returns {integer}
     */


  readUIntLE(offset, byteLength) {
    if (byteLength <= 0 || byteLength > 6) {
      throw new RangeError('Index out of range');
    }

    checkOffset(this, offset, byteLength);
    var result = 0;
    var multiplier = 1; // we use a multipler for each byte

    for (var i = 0; i < byteLength; i++) {
      result += getAdjustedIndex(this, offset + i) * multiplier;
      multiplier *= 0x100; // move multiplier to next byte
    }

    return result;
  }
  /**
     * @param {integer} [start=0] Where the new `Buffer` will start.
     * @param {integer} [end=this.length] Where the new Buffer will end (not inclusive). Default: `buf.length`.
     * @returns {Buffer}
     */


  slice(start, end) {
    var thisLength = this.length;

    if (typeof start === 'undefined') {
      start = 0;
    } else if (start < 0) {
      start = thisLength + start;

      if (start < 0) {
        // if this is still negative, use 0 (that matches Node)
        start = 0;
      }
    }

    if (typeof end === 'undefined') {
      end = thisLength;
    } else if (end < 0) {
      end = thisLength + end;
    } // Specifying end greater than buf.length will return the same result as that of end equal to buf.length.


    if (end > thisLength) {
      end = thisLength;
    } // What if end is less than start?


    var length = end - start;

    if (length <= 0) {
      length = 0; // return empty view of Buffer! retain byte offset, set length to 0
    } // Wrap the same Ti.Buffer object but specify the start/end to "crop" with


    return newBuffer(this._tiBuffer, this.byteOffset + start, length);
  }
  /**
     * @param {integer} [start=0] Where the new `Buffer` will start.
     * @param {integer} [end=this.length] Where the new Buffer will end (not inclusive). Default: `buf.length`.
     * @returns {Buffer}
     */


  subarray(start, end) {
    return this.slice(start, end);
  }
  /**
     * Interprets buf as an array of unsigned 16-bit integers and swaps the byte order in-place.
     * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 2.
     * @returns {Buffer}
     */


  swap16() {
    var length = this.length;

    if (length % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits');
    }

    for (var i = 0; i < length; i += 2) {
      var first = getAdjustedIndex(this, i);
      var second = getAdjustedIndex(this, i + 1);
      setAdjustedIndex(this, i, second);
      setAdjustedIndex(this, i + 1, first);
    }

    return this;
  }
  /**
     * Interprets buf as an array of unsigned 32-bit integers and swaps the byte order in-place.
     * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 4.
     * @returns {Buffer}
     */


  swap32() {
    var length = this.length;

    if (length % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits');
    }

    for (var i = 0; i < length; i += 4) {
      var first = getAdjustedIndex(this, i);
      var second = getAdjustedIndex(this, i + 1);
      var third = getAdjustedIndex(this, i + 2);
      var fourth = getAdjustedIndex(this, i + 3);
      setAdjustedIndex(this, i, fourth);
      setAdjustedIndex(this, i + 1, third);
      setAdjustedIndex(this, i + 2, second);
      setAdjustedIndex(this, i + 3, first);
    }

    return this;
  }
  /**
     * Interprets buf as an array of unsigned 64-bit integers and swaps the byte order in-place.
     * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 8.
     * @returns {Buffer}
     */


  swap64() {
    var length = this.length;

    if (length % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits');
    }

    for (var i = 0; i < length; i += 8) {
      var first = getAdjustedIndex(this, i);
      var second = getAdjustedIndex(this, i + 1);
      var third = getAdjustedIndex(this, i + 2);
      var fourth = getAdjustedIndex(this, i + 3);
      var fifth = getAdjustedIndex(this, i + 4);
      var sixth = getAdjustedIndex(this, i + 5);
      var seventh = getAdjustedIndex(this, i + 6);
      var eighth = getAdjustedIndex(this, i + 7);
      setAdjustedIndex(this, i, eighth);
      setAdjustedIndex(this, i + 1, seventh);
      setAdjustedIndex(this, i + 2, sixth);
      setAdjustedIndex(this, i + 3, fifth);
      setAdjustedIndex(this, i + 4, fourth);
      setAdjustedIndex(this, i + 5, third);
      setAdjustedIndex(this, i + 6, second);
      setAdjustedIndex(this, i + 7, first);
    }

    return this;
  }
  /**
     * @returns {object}
     */


  toJSON() {
    return {
      type: 'Buffer',
      // Take advantage of slice working on "Array-like" objects (juts like `arguments`)
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Array-like_objects
      data: [].slice.call(this) };

  }
  /**
     * @param {string} [encoding='utf8'] The character encoding to use
     * @param {integer} [start=0] The byte offset to start decoding at
     * @param {integer} [end] The byte offset to stop decoding at (not inclusive). `buf.length` default
     * @returns {string}
     */


  toString(encoding, start, end) {
    // fast case of no args
    if (arguments.length === 0) {
      return this._tiBuffer.toString();
    }

    var length = this.length;

    if (start >= length) {
      return ''; // start is past end of buffer, return empty string
    }

    if (start < 0 || typeof start !== 'number') {
      start = 0;
    }

    if (end > length || typeof end !== 'number') {
      // no end specified, or past end of buffer, use length of buffer
      end = length;
    } // else keep end as passed in


    if (end <= start) {
      return ''; // if end is before start return empty string
    } // If start !== 0 and end !== length, maybe we should do a Buffer.subarray/slice over the range and call toString() on that?


    if (start !== 0 || end !== length) {
      return this.slice(start, end).toString(encoding);
    } // base case, start is 0, end is length


    if (encoding === undefined) {
      encoding = 'utf8';
    } else {
      encoding = encoding.toLowerCase(); // Throw if bad encoding!

      if (!Buffer$1.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: ".concat(encoding));
      }
    }

    if (encoding === 'utf8' || encoding === 'utf-8') {
      // if this is the original underlying buffer just return it's toString() value
      if (this.byteOffset === 0 && this.length === this._tiBuffer.length) {
        return this._tiBuffer.toString(); // we return utf-8 by default natively
      } // if we're offset or cropping in nay way, clone the range and return that buffer's toString()


      return this._tiBuffer.clone(this.byteOffset, this.length).toString();
    }

    if (encoding === 'base64') {
      var blob; // if this is the original underlying buffer just return it's toString() value

      if (this.byteOffset === 0 && this.length === this._tiBuffer.length) {
        blob = Ti.Utils.base64encode(this._tiBuffer.toBlob());
      } else {
        // if we're offset or cropping in any way, clone the range and return that buffer's toString()
        blob = Ti.Utils.base64encode(this._tiBuffer.clone(this.byteOffset, this.length).toBlob());
      }

      return blob.toString();
    }

    if (encoding === 'hex') {
      var hexStr = '';

      for (var i = 0; i < length; i++) {
        // each one is a "byte"
        var hex = (getAdjustedIndex(this, i) & 0xff).toString(16);
        hex = hex.length === 1 ? '0' + hex : hex;
        hexStr += hex;
      }

      return hexStr;
    }

    if (encoding === 'latin1' || encoding === 'binary') {
      var latin1String = '';

      for (var _i = 0; _i < length; _i++) {
        // each one is a "byte"
        latin1String += String.fromCharCode(getAdjustedIndex(this, _i));
      }

      return latin1String;
    }

    if (encoding === 'ascii') {
      var ascii = '';

      for (var _i2 = 0; _i2 < length; _i2++) {
        // we store bytes (8-bit), but ascii is 7-bit. Node "masks" the last bit off, so let's do the same
        ascii += String.fromCharCode(getAdjustedIndex(this, _i2) & 0x7F);
      }

      return ascii;
    } // UCS2/UTF16


    return bufferToUTF16String(this._tiBuffer, this.byteOffset, this.length);
  }
  /**
     * Provides a conversion method for interacting with Ti APIs taht require a Ti.Buffer
     * @returns {Ti.Buffer} the underlying Ti.Buffer backing this Buffer instance
     */


  toTiBuffer() {
    return this._tiBuffer;
  }
  /**
     * Creates and returns an iterator for buf values (bytes)
     * @returns {Iterator}
     */


  values() {
    var buffer = this;
    var nextIndex = 0;
    var end = this.length;
    var myIterator = {
      next: function () {
        if (nextIndex < end) {
          var result = {
            value: getAdjustedIndex(buffer, nextIndex),
            done: false };

          nextIndex++;
          return result;
        }

        return {
          value: undefined,
          done: true };

      },
      [Symbol.iterator]: function () {
        return this;
      } };

    return myIterator;
  }
  /**
     * Called when buffer is used in a for..of loop. Delegates to #values()
     * @returns {Iterator}
     */


  [Symbol.iterator]() {
    return this.values();
  }
  /**
     * Writes string to buf at offset according to the character encoding in encoding.
     * The length parameter is the number of bytes to write. If buf did not contain enough space to
     * fit the entire string, only part of string will be written. However, partially encoded
     * characters will not be written.
     * @param {string} string String to write to `buf`.
     * @param {integer} [offset=0] Number of bytes to skip before starting to write string
     * @param {integer} [length=buf.length - offset] Number of bytes to write
     * @param {string} [encoding='utf8'] The character encoding of string
     * @returns {integer}
     */


  write(string, offset, length, encoding) {
    if (typeof offset === 'string') {
      encoding = offset;
      offset = 0;
      length = this.length;
    } else if (typeof length === 'string') {
      encoding = length;
      length = this.length - offset;
    } else {
      // we cap `length` at the length of our buffer
      var remaining = this.length - offset;

      if (length > remaining) {
        length = remaining;
      }
    }

    encoding = encoding || 'utf8'; // so we need to convert `remaining` bytes of our string into a byte array/buffer

    var src = Buffer$1.from(string, encoding); // FIXME: Can we let it know to only convert `remaining` bytes?
    // then stick that into our buffer starting at `offset`!

    return copyBuffer(src._tiBuffer, this._tiBuffer, offset, length);
  }

  writeDoubleBE(value, offset = 0) {
    checkOffset(this, offset, 8);
    doubleArray[0] = value;
    setAdjustedIndex(this, offset++, uint8DoubleArray[7]);
    setAdjustedIndex(this, offset++, uint8DoubleArray[6]);
    setAdjustedIndex(this, offset++, uint8DoubleArray[5]);
    setAdjustedIndex(this, offset++, uint8DoubleArray[4]);
    setAdjustedIndex(this, offset++, uint8DoubleArray[3]);
    setAdjustedIndex(this, offset++, uint8DoubleArray[2]);
    setAdjustedIndex(this, offset++, uint8DoubleArray[1]);
    setAdjustedIndex(this, offset++, uint8DoubleArray[0]);
    return offset; // at this point, we should have already added 8 to offset
  }

  writeDoubleLE(value, offset = 0) {
    checkOffset(this, offset, 8);
    doubleArray[0] = value;
    setAdjustedIndex(this, offset++, uint8DoubleArray[0]);
    setAdjustedIndex(this, offset++, uint8DoubleArray[1]);
    setAdjustedIndex(this, offset++, uint8DoubleArray[2]);
    setAdjustedIndex(this, offset++, uint8DoubleArray[3]);
    setAdjustedIndex(this, offset++, uint8DoubleArray[4]);
    setAdjustedIndex(this, offset++, uint8DoubleArray[5]);
    setAdjustedIndex(this, offset++, uint8DoubleArray[6]);
    setAdjustedIndex(this, offset++, uint8DoubleArray[7]);
    return offset; // at this point, we should have already added 8 to offset
  }

  writeFloatBE(value, offset = 0) {
    checkOffset(this, offset, 4);
    floatArray[0] = value;
    setAdjustedIndex(this, offset++, uint8FloatArray[3]);
    setAdjustedIndex(this, offset++, uint8FloatArray[2]);
    setAdjustedIndex(this, offset++, uint8FloatArray[1]);
    setAdjustedIndex(this, offset++, uint8FloatArray[0]);
    return offset; // at this point, we should have already added 4 to offset
  }

  writeFloatLE(value, offset = 0) {
    checkOffset(this, offset, 4);
    floatArray[0] = value;
    setAdjustedIndex(this, offset++, uint8FloatArray[0]);
    setAdjustedIndex(this, offset++, uint8FloatArray[1]);
    setAdjustedIndex(this, offset++, uint8FloatArray[2]);
    setAdjustedIndex(this, offset++, uint8FloatArray[3]);
    return offset; // at this point, we should have already added 4 to offset
  }
  /**
     * @param {integer} value Number to be written to buf.
     * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 1.
     * @returns {integer}
     */


  writeInt8(value, offset = 0) {
    checkOffset(this, offset, 1);
    checkValue(value, -128, 127);

    if (value >= 0) {
      // just write it normally
      setAdjustedIndex(this, offset, value);
    } else {
      // convert from signed to 2's complement bits
      setAdjustedIndex(this, offset, 0xFF + value + 1); // max value, plus the negative number, add one
    }

    return offset + 1;
  }
  /**
     * @param {integer} value Number to be written to buf.
     * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
     * @returns {integer}
     */


  writeInt16BE(value, offset = 0) {
    checkOffset(this, offset, 2);
    checkValue(value, -32768, 32767);
    setAdjustedIndex(this, offset, value >>> 8); // just shift over a byte

    setAdjustedIndex(this, offset + 1, value & 0xFF); // mask to first byte

    return offset + 2;
  }
  /**
     * @param {integer} value Number to be written to buf.
     * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
     * @returns {integer}
     */


  writeInt16LE(value, offset = 0) {
    checkOffset(this, offset, 2);
    checkValue(value, -32768, 32767);
    setAdjustedIndex(this, offset, value & 0xFF);
    setAdjustedIndex(this, offset + 1, value >>> 8);
    return offset + 2;
  }
  /**
     * @param {integer} value Number to be written to buf.
     * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
     * @returns {integer}
     */


  writeInt32BE(value, offset = 0) {
    checkOffset(this, offset, 4);
    checkValue(value, -2147483648, 2147483647);
    setAdjustedIndex(this, offset, value >>> 24);
    setAdjustedIndex(this, offset + 1, value >>> 16);
    setAdjustedIndex(this, offset + 2, value >>> 8);
    setAdjustedIndex(this, offset + 3, value & 0xFF);
    return offset + 4;
  }
  /**
     * @param {integer} value Number to be written to buf.
     * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
     * @returns {integer}
     */


  writeInt32LE(value, offset = 0) {
    checkOffset(this, offset, 4);
    checkValue(value, -2147483648, 2147483647);
    setAdjustedIndex(this, offset, value & 0xFF);
    setAdjustedIndex(this, offset + 1, value >>> 8);
    setAdjustedIndex(this, offset + 2, value >>> 16);
    setAdjustedIndex(this, offset + 3, value >>> 24);
    return offset + 4;
  }
  /**
     * @param {integer} value Number to be written to buf.
     * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
     * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
     * @returns {integer}
     */


  writeIntBE(value, offset, byteLength) {
    if (byteLength <= 0 || byteLength > 6) {
      throw new RangeError('Index out of range');
    }

    checkOffset(this, offset, byteLength);
    var minMaxBase = Math.pow(2, 8 * byteLength - 1);
    checkValue(value, -minMaxBase, minMaxBase - 1);

    if (value < 0) {
      value = minMaxBase * 2 + value;
    }

    var multiplier = 1;

    for (var i = byteLength - 1; i >= 0; i--) {
      var byteValue = value / multiplier & 0xFF;
      setAdjustedIndex(this, offset + i, byteValue);
      multiplier *= 0x100;
    }

    return offset + byteLength;
  }
  /**
     * @param {integer} value Number to be written to buf.
     * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
     * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
     * @returns {integer}
     */


  writeIntLE(value, offset, byteLength) {
    if (byteLength <= 0 || byteLength > 6) {
      throw new RangeError('Index out of range');
    }

    checkOffset(this, offset, byteLength);
    var minMaxBase = Math.pow(2, 8 * byteLength - 1);
    checkValue(value, -minMaxBase, minMaxBase - 1);

    if (value < 0) {
      value = minMaxBase * 2 + value;
    }

    var multiplier = 1;

    for (var i = 0; i < byteLength; i++) {
      var byteValue = value / multiplier & 0xFF;
      setAdjustedIndex(this, offset + i, byteValue);
      multiplier *= 0X100;
    }

    return offset + byteLength;
  }
  /**
     * @param {integer} value Number to be written to buf.
     * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 1.
     * @returns {integer}
     */


  writeUInt8(value, offset = 0) {
    checkOffset(this, offset, 1);
    checkValue(value, 0, 255);
    setAdjustedIndex(this, offset, value);
    return offset + 1;
  }
  /**
     * @param {integer} value Number to be written to buf.
     * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
     * @returns {integer}
     */


  writeUInt16BE(value, offset = 0) {
    checkOffset(this, offset, 2);
    checkValue(value, 0, 65535);
    setAdjustedIndex(this, offset, value >>> 8);
    setAdjustedIndex(this, offset + 1, value & 0xff);
    return offset + 2;
  }
  /**
     * @param {integer} value Number to be written to buf.
     * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
     * @returns {integer}
     */


  writeUInt16LE(value, offset = 0) {
    checkOffset(this, offset, 2);
    checkValue(value, 0, 65535);
    setAdjustedIndex(this, offset, value & 0xff);
    setAdjustedIndex(this, offset + 1, value >>> 8);
    return offset + 2;
  }
  /**
     * @param {integer} value Number to be written to buf.
     * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
     * @returns {integer}
     */


  writeUInt32BE(value, offset = 0) {
    checkOffset(this, offset, 4);
    checkValue(value, 0, 4294967295);
    setAdjustedIndex(this, offset, value >>> 24);
    setAdjustedIndex(this, offset + 1, value >>> 16);
    setAdjustedIndex(this, offset + 2, value >>> 8);
    setAdjustedIndex(this, offset + 3, value & 0xff);
    return offset + 4;
  }
  /**
     * @param {integer} value Number to be written to buf.
     * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
     * @returns {integer}
     */


  writeUInt32LE(value, offset = 0) {
    checkOffset(this, offset, 4);
    checkValue(value, 0, 4294967295);
    setAdjustedIndex(this, offset, value & 0xff);
    setAdjustedIndex(this, offset + 1, value >>> 8);
    setAdjustedIndex(this, offset + 2, value >>> 16);
    setAdjustedIndex(this, offset + 3, value >>> 24);
    return offset + 4;
  }
  /**
     * @param {integer} value Number to be written to buf.
     * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
     * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
     * @returns {integer}
     */


  writeUIntBE(value, offset, byteLength) {
    if (byteLength <= 0 || byteLength > 6) {
      throw new RangeError('Index out of range');
    }

    checkOffset(this, offset, byteLength);
    checkValue(value, 0, Math.pow(2, 8 * byteLength) - 1);
    var multiplier = 1;

    for (var i = byteLength - 1; i >= 0; i--) {
      var byteValue = value / multiplier & 0xFF;
      setAdjustedIndex(this, offset + i, byteValue);
      multiplier *= 0X100;
    }

    return offset + byteLength;
  }
  /**
     * @param {integer} value Number to be written to buf.
     * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
     * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
     * @returns {integer}
     */


  writeUIntLE(value, offset, byteLength) {
    if (byteLength <= 0 || byteLength > 6) {
      throw new RangeError('Index out of range');
    }

    checkOffset(this, offset, byteLength);
    checkValue(value, 0, Math.pow(2, 8 * byteLength) - 1);
    var multiplier = 1;

    for (var i = 0; i < byteLength; i++) {
      var byteValue = value / multiplier & 0xFF;
      setAdjustedIndex(this, offset + i, byteValue);
      multiplier *= 0X100;
    }

    return offset + byteLength;
  } // TODO: Implement remaining instance methods:
  // buf.lastIndexOf(value[, byteOffset][, encoding])
  // buf.readBigInt64BE([offset])
  // buf.readBigInt64LE([offset])
  // buf.readBigUInt64BE([offset])
  // buf.readBigUInt64LE([offset])
  // buf.writeBigInt64BE(value[, offset])
  // buf.writeBigInt64LE(value[, offset])
  // buf.writeBigUInt64BE(value[, offset])
  // buf.writeBigUInt64LE(value[, offset])


  static allocUnsafe(length) {
    return newBuffer(Ti.createBuffer({
      length }));

  }

  static allocUnsafeSlow(length) {
    return Buffer$1.allocUnsafe(length);
  }

  static alloc(length, fill = 0, encoding = 'utf8') {
    var buf = Buffer$1.allocUnsafe(length);
    buf.fill(fill, encoding);
    return buf;
  }
  /**
     * @param {string|Buffer|TypedArray|DataView|ArrayBuffer|SharedArrayBuffer} string original string
     * @param {string} [encoding='utf8'] encoding whose byte length we need to grab
     * @returns {integer}
     */


  static byteLength(string, encoding = 'utf8') {
    if (typeof string !== 'string') {
      if (Buffer$1.isBuffer(string)) {
        return string.length; // return Buffer's length
      }

      return string.byteLength; // TypedArray, ArrayBuffer, SharedArrayBuffer, DataView
    }

    var length = string.length;

    switch (encoding.toLowerCase()) {
      case 'utf8':
      case 'utf-8':
        return utf8ByteLength(string);

      case 'latin1':
      case 'binary':
      case 'ascii':
        return length;

      case 'ucs-2':
      case 'ucs2':
      case 'utf16le':
      case 'utf16-le':
        return 2 * length;

      case 'hex':
        return length / 2;

      case 'base64':
        // Subtract up to two padding chars from end of string!
        if (length > 1 && string.charAt(length - 1) === '=') {
          length--;
        }

        if (length > 1 && string.charAt(length - 1) === '=') {
          length--;
        }

        return Math.floor(length * 3 / 4);
      // drop fractional value
    }

    return utf8ByteLength(string);
  }

  static compare(buf1, buf2) {
    if (!Buffer$1.isBuffer(buf1)) {
      throw new TypeError("The \"buf1\" argument must be one of type Buffer or Uint8Array. Received type ".concat(typeof buf1));
    } // TODO: Wrap UInt8Array args in buffers?


    return buf1.compare(buf2);
  }
  /**
     * @param {Buffer[]|UInt8Array[]} list list of Buffers to concatenate
     * @param {integer} [totalLength] Total length of the Buffer instances in list when concatenated.
     * @returns {Buffer}
     */


  static concat(list, totalLength) {
    if (!Array.isArray(list)) {
      throw new TypeError('list argument must be an Array');
    }

    if (list.length === 0) {
      return Buffer$1.alloc(0); // one empty Buffer!
    } // allocate one Buffer of `totalLength`? Cap at totalLength?


    if (totalLength === undefined) {
      totalLength = 0; // generate the total length from each buffer's length?

      for (var i = 0; i < list.length; i++) {
        totalLength += list[i].length;
      }
    }

    var result = Buffer$1.allocUnsafe(totalLength);
    var position = 0;

    for (var _i3 = 0; _i3 < list.length; _i3++) {
      var buf = list[_i3];
      buf.copy(result, position);
      position += buf.length;

      if (position >= totalLength) {
        break;
      }
    }

    return result;
  }
  /**
     * @param {integer[]|Buffer|string} value value we're wrapping
     * @param {string} [encoding='utf8'] The encoding of string.
     * @returns {Buffer}
     */


  static from(value, encoding = 'utf8') {
    var valueType = typeof value;

    if (valueType === 'string') {
      if (!Buffer$1.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: ".concat(encoding));
      }

      encoding = encoding.toLowerCase();

      if (encoding === 'base64') {
        var blob = Ti.Utils.base64decode(value);
        var blobStream = Ti.Stream.createStream({
          source: blob,
          mode: Ti.Stream.MODE_READ });

        var buffer = Ti.Stream.readAll(blobStream);
        blobStream.close();
        return newBuffer(buffer);
      }

      if (encoding === 'hex') {
        return Buffer$1.from(stringToHexBytes(value));
      }

      return newBuffer(Ti.createBuffer({
        value: value,
        type: getTiCodecCharset(encoding) }));

    } else if (valueType === 'object') {
      if (Buffer$1.isBuffer(value)) {
        var length = value.length;

        var _buffer = Buffer$1.allocUnsafe(length);

        if (length === 0) {
          return _buffer;
        }

        value.copy(_buffer, 0, 0, length);
        return _buffer;
      }

      if (Array.isArray(value) || value instanceof Uint8Array) {
        var _length = value.length;

        if (_length === 0) {
          return Buffer$1.allocUnsafe(0);
        }

        var tiBuffer = Ti.createBuffer({
          length: _length });


        for (var i = 0; i < _length; i++) {
          tiBuffer[i] = value[i] & 0xFF; // mask to one byte
        }

        return newBuffer(tiBuffer);
      }

      if (value.apiName && value.apiName === 'Ti.Buffer') {
        return newBuffer(value);
      }
    }

    throw new TypeError('The \'value\' argument must be one of type: \'string\', \'Array\', \'Buffer\', \'Ti.Buffer\'');
  }
  /**
     * @param {string} encoding possible encoding name
     * @returns {boolean}
     */


  static isEncoding(encoding) {
    if (typeof encoding !== 'string') {
      return false;
    }

    return VALID_ENCODINGS.includes(encoding.toLowerCase());
  }
  /**
     * @param {*} obj possible Buffer instance
     * @returns {boolean}
     */


  static isBuffer(obj) {
    return obj !== null && obj !== undefined && obj[isBuffer] === true;
  } // Override how buffers are presented by util.inspect().


  [customInspectSymbol](recurseTimes, ctx) {
    var max = INSPECT_MAX_BYTES;
    var actualMax = Math.min(max, this.length);
    var remaining = this.length - max;
    var str = this.slice(0, actualMax).toString('hex').replace(/(.{2})/g, '$1 ').trim();

    if (remaining > 0) {
      str += " ... ".concat(remaining, " more byte").concat(remaining > 1 ? 's' : '');
    } // Inspect special properties as well, if possible.


    if (ctx) {
      var extras = false;
      var filter = ctx.showHidden ? ALL_PROPERTIES$1 : ONLY_ENUMERABLE$1;
      var obj = getOwnNonIndexProperties(this, filter).reduce((obj, key) => {
        extras = true;
        obj[key] = this[key];
        return obj;
      }, Object.create(null));

      if (extras) {
        if (this.length !== 0) {
          str += ', ';
        } // '[Object: null prototype] {'.length === 26
        // This is guarded with a test.


        str += inspect(obj, _objectSpread2({}, ctx, {
          breakLength: Infinity,
          compact: true })).
        slice(27, -2);
      }
    }

    return "<".concat(this.constructor.name, " ").concat(str, ">");
  }}



Buffer$1.prototype.inspect = Buffer$1.prototype[customInspectSymbol];
Buffer$1.poolSize = 8192;
var BufferModule = {
  Buffer: Buffer$1,
  // TODO: Implement transcode()!
  transcode: (_source, _fromEncoding, _toEncoding) => {},
  INSPECT_MAX_BYTES: 50,
  kMaxLength: 2147483647,
  kStringMaxLength: 1073741799,
  constants: {
    MAX_LENGTH: 2147483647,
    MAX_STRING_LENGTH: 1073741799 } };


/**
                                        * Searches a Buffer for the index of a single byte.
                                        * @param {Buffer} buffer buffer to search
                                        * @param {integer} singleByte byte we're looking for
                                        * @param {integer} offset start offset we search at
                                        * @returns {integer}
                                        */

function indexOf$1(buffer, singleByte, offset) {
  var length = buffer.length;

  for (var i = offset; i < length; i++) {
    if (getAdjustedIndex(buffer, i) === singleByte) {
      return i;
    }
  }

  return -1;
}
/**
   * This function explicitly avoids bitwise operations because JS assumes 32-bit sequences for those.
   * It's possible we may be able to use them when byteLength < 4 if that's faster.
   *
   * @param {integer} unsignedValue value before converting back to signed
   * @param {integer} byteLength number of bytes
   * @returns {integer} the signed value that is represented by the unsigned value's bytes
   */


function unsignedToSigned(unsignedValue, byteLength) {
  var bitLength = byteLength * 8;
  var maxPositiveValue = Math.pow(2, bitLength - 1);

  if (unsignedValue < maxPositiveValue) {
    return unsignedValue;
  }

  var maxUnsignedValue = Math.pow(2, bitLength);
  unsignedValue -= maxUnsignedValue;
  return unsignedValue;
}
/**
   * @param {Ti.Buffer} src source Buffer we're copying from
   * @param {Ti.Buffer} dest destination Buffer we're copying into
   * @param {integer} offset start offset we're copying to in destination
   * @param {integer} length number of bytes to copy
   * @returns {integer} actual number of bytes copied
   */


function copyBuffer(src, dest, offset, length) {
  var srcLength = src.length;
  var destLength = dest.length;
  var i = 0;

  for (; i < length; i++) {
    var destIndex = i + offset; // are we trying to write past end of destination? Or read past end of source? Stop!

    if (destIndex >= destLength || i >= srcLength) {
      break;
    }

    dest[destIndex] = src[i];
  }

  return i;
}
/**
   * @param {string} string utf-8 string
   * @returns {integer}
   */


function utf8ByteLength(string) {
  // Just convert to a Ti.Buffer and let it tell us the length
  var buf = Ti.createBuffer({
    value: string,
    type: Ti.Codec.CHARSET_UTF8 });

  var length = buf.length;
  buf.release(); // release the buffer since we just needed the length

  return length;
}
/**
   * @param {string} encoding desired encoding name
   * @returns {integer} Ti.Codec constant that maps to the encoding
   */


function getTiCodecCharset(encoding) {
  return TI_CODEC_MAP.get(encoding);
}

function bufferToUTF16String(tiBuffer, start, length) {
  var out = '';
  var i = start;

  while (i < length) {
    // utf-16/ucs-2 is 2-bytes per character
    var byte1 = tiBuffer[i++];
    var byte2 = tiBuffer[i++];
    var code_unit = (byte2 << 8) + byte1; // we mash together the two bytes

    out += String.fromCodePoint(code_unit);
  }

  return out;
}
/**
   * loop over input, every 2 characters, parse as an int
   * basically each two characters are a "byte" or an 8-bit uint
   * we append them all together to form a single buffer holding all the values
   * @param {string} value string we're encoding in hex
   * @returns {integer[]} array of encoded bytes
   */


function stringToHexBytes(value) {
  var length = value.length / 2;
  var byteArray = [];

  for (var i = 0; i < length; i++) {
    var numericValue = parseInt(value.substr(i * 2, 2), 16);

    if (!Number.isNaN(numericValue)) {
      // drop bad hex characters
      byteArray.push(numericValue);
    }
  }

  return byteArray;
} // Use a Proxy to hack array style index accessors


var arrayIndexHandler = {
  get(target, propKey, receiver) {
    if (typeof propKey === 'string') {
      var num = Number(propKey);

      if (Number.isSafeInteger(num)) {
        return getAdjustedIndex(target, num);
      }
    } else if (propKey === isBuffer) {
      return true;
    }

    return Reflect.get(target, propKey, receiver);
  },

  set(target, propKey, value, receiver) {
    if (typeof propKey === 'string') {
      var num = Number(propKey);

      if (Number.isSafeInteger(num)) {
        return setAdjustedIndex(target, num, value);
      }
    }

    return Reflect.set(target, propKey, value, receiver);
  },

  has(target, key) {
    if (typeof key === 'string') {
      var num = Number(key);

      if (Number.isSafeInteger(num)) {
        // ensure it's a positive "safe" integer within the range of the buffer
        return num >= 0 && num < target._tiBuffer.length;
      }
    }

    return key in target;
  } };



function getAdjustedIndex(buf, index) {
  if (index < 0 || index >= buf._tiBuffer.length) {
    return undefined;
  }

  return buf._tiBuffer[index + buf.byteOffset];
}

function setAdjustedIndex(buf, index, value) {
  if (index >= 0 || index < buf._tiBuffer.length) {
    buf._tiBuffer[index + buf.byteOffset] = value;
  }

  return value;
}
/**
   * Wraps creation of a Buffer instance inside a Proxy so we can handle array index access
   * @param  {...any} args argunents ot Buffer constructor
   * @returns {Buffer} wrapped inside a Proxy
   */


function newBuffer(...args) {
  return new Proxy(new Buffer$1(...args), arrayIndexHandler); // eslint-disable-line security/detect-new-buffer
}
/**
   * Throws a RangeError if offset is out of bounds
   * @param {Buffer} buffer buffer we're operating on
   * @param {integer} offset user supplied offset
   * @param {integer} byteLength number of bytes needed in range
   * @throws {RangeError}
   */


function checkOffset(buffer, offset, byteLength) {
  var endOffset = buffer.length - byteLength;

  if (offset < 0 || offset > endOffset) {
    throw new RangeError("The value of \"offset\" is out of range. It must be >= 0 and <= ".concat(endOffset, ". Received ").concat(offset));
  }
}
/**
   * @param {integer} value user-supplied value
   * @param {integer} min minimum valid value
   * @param {integer} max maximum valid value
   * @throws {RangeError}
   */


function checkValue(value, min, max) {
  if (value < min || value > max) {
    throw new RangeError("The value of \"value\" is out of range. It must be >= ".concat(min, " and <= ").concat(max, ". Received ").concat(value));
  }
}

var bufferWarningAlreadyEmitted = false;
var nodeModulesCheckCounter = 0;
var bufferWarning = 'Buffer() is deprecated due to security and usability ' + 'issues. Please use the Buffer.alloc(), ' + 'Buffer.allocUnsafe(), or Buffer.from() methods instead.';

function showFlaggedDeprecation() {
  if (bufferWarningAlreadyEmitted || ++nodeModulesCheckCounter > 10000 || isInsideNodeModules()) {
    // We don't emit a warning, because we either:
    // - Already did so, or
    // - Already checked too many times whether a call is coming
    //   from node_modules and want to stop slowing down things, or
    // - The code is inside `node_modules`.
    return;
  }

  process.emitWarning(bufferWarning, 'DeprecationWarning', 'DEP0005');
  bufferWarningAlreadyEmitted = true;
}

var {
  ALL_PROPERTIES: ALL_PROPERTIES$2,
  ONLY_ENUMERABLE: ONLY_ENUMERABLE$2 } =
propertyFilter;
var BooleanPrototype = Boolean.prototype;
var DatePrototype = Date.prototype;
var ErrorPrototype = Error.prototype;
var NumberPrototype = Number.prototype;
var MapPrototype = Map.prototype;
var RegExpPrototype = RegExp.prototype;
var StringPrototype = String.prototype;
var SetPrototype = Set.prototype;
var SymbolPrototype = Symbol.prototype;
var isIos$1 = ['ipad', 'iphone'].includes(Ti.Platform.osname);
var {
  ERR_INVALID_ARG_TYPE } =
codes;
var hasOwnProperty$1 = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable$1 = uncurryThis(Object.prototype.propertyIsEnumerable);
var hexSlice = uncurryThis(BufferModule.Buffer.prototype.hexSlice);
var builtInObjects = new Set(Object.getOwnPropertyNames(global).filter(e => /^([A-Z][a-z]+)+$/.test(e)));
var inspectDefaultOptions = Object.seal({
  showHidden: false,
  depth: 2,
  colors: false,
  customInspect: true,
  showProxy: false,
  maxArrayLength: 100,
  breakLength: 80,
  compact: 3,
  sorted: false,
  getters: false });

var kObjectType = 0;
var kArrayType = 1;
var kArrayExtrasType = 2;
/* eslint-disable no-control-regex */

var strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c]/;
var strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c]/g;
var strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c]/;
var strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c]/g;
/* eslint-enable no-control-regex */

var keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
var numberRegExp = /^(0|[1-9][0-9]*)$/;
var nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
var kMinLineLength = 16; // Constants to map the iterator state.

var kWeak = 0;
var kIterator = 1;
var kMapEntries = 2; // Escaped special characters. Use empty strings to fill up unused entries.

/* eslint-disable quotes */

var meta = ['\\u0000', '\\u0001', '\\u0002', '\\u0003', '\\u0004', '\\u0005', '\\u0006', '\\u0007', '\\b', '\\t', '\\n', '\\u000b', '\\f', '\\r', '\\u000e', '\\u000f', '\\u0010', '\\u0011', '\\u0012', '\\u0013', '\\u0014', '\\u0015', '\\u0016', '\\u0017', '\\u0018', '\\u0019', '\\u001a', '\\u001b', '\\u001c', '\\u001d', '\\u001e', '\\u001f', '', '', '', '', '', '', '', "\\'", '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '\\\\'];
/* eslint-enable quotes */

function getUserOptions(ctx) {
  var obj = {
    stylize: ctx.stylize };


  for (var key of Object.keys(inspectDefaultOptions)) {
    obj[key] = ctx[key];
  }

  if (ctx.userOptions === undefined) {
    return obj;
  }

  return _objectSpread2({}, obj, {}, ctx.userOptions);
}
/**
   * Echos the value of any input. Tries to print the value out
   * in the best way possible given the different types.
   *
   * @param {any} value The value to print out.
   * @param {Object} opts Optional options object that alters the output.
   * @return {string} The string representation of `value`
   */


function inspect(value, opts) {
  // Default options
  var ctx = {
    budget: {},
    indentationLvl: 0,
    seen: [],
    currentDepth: 0,
    stylize: stylizeNoColor,
    showHidden: inspectDefaultOptions.showHidden,
    depth: inspectDefaultOptions.depth,
    colors: inspectDefaultOptions.colors,
    customInspect: inspectDefaultOptions.customInspect,
    showProxy: inspectDefaultOptions.showProxy,
    maxArrayLength: inspectDefaultOptions.maxArrayLength,
    breakLength: inspectDefaultOptions.breakLength,
    compact: inspectDefaultOptions.compact,
    sorted: inspectDefaultOptions.sorted,
    getters: inspectDefaultOptions.getters };


  if (arguments.length > 1) {
    // Legacy...
    if (arguments.length > 2) {
      if (arguments[2] !== undefined) {
        ctx.depth = arguments[2];
      }

      if (arguments.length > 3 && arguments[3] !== undefined) {
        ctx.colors = arguments[3];
      }
    } // Set user-specified options


    if (typeof opts === 'boolean') {
      ctx.showHidden = opts;
    } else if (opts) {
      var optKeys = Object.keys(opts);

      for (var key of optKeys) {
        // TODO(BridgeAR): Find a solution what to do about stylize. Either make
        // this function public or add a new API with a similar or better
        // functionality.
        if (hasOwnProperty$1(inspectDefaultOptions, key) || key === 'stylize') {
          ctx[key] = opts[key];
        } else if (ctx.userOptions === undefined) {
          // This is required to pass through the actual user input.
          ctx.userOptions = opts;
        }
      }
    }
  }

  if (ctx.colors) {
    ctx.stylize = stylizeWithColor;
  }

  if (ctx.maxArrayLength === null) {
    ctx.maxArrayLength = Infinity;
  }

  return formatValue(ctx, value, 0);
}
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, 'defaultOptions', {
  get() {
    return inspectDefaultOptions;
  },

  set(options) {
    if (options === null || typeof options !== 'object') {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }

    return Object.assign(inspectDefaultOptions, options);
  } });

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = Object.assign(Object.create(null), {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39] });
// Don't use 'blue' not visible on cmd.exe

inspect.styles = Object.assign(Object.create(null), {
  special: 'cyan',
  number: 'yellow',
  bigint: 'yellow',
  boolean: 'yellow',
  undefined: 'grey',
  null: 'bold',
  string: 'green',
  symbol: 'green',
  date: 'magenta',
  // "name": intentionally not styling
  regexp: 'red',
  module: 'underline' });


function addQuotes(str, quotes) {
  if (quotes === -1) {
    return "\"".concat(str, "\"");
  }

  if (quotes === -2) {
    return "`".concat(str, "`");
  }

  return "'".concat(str, "'");
}

var escapeFn = str => meta[str.charCodeAt(0)]; // Escape control characters, single quotes and the backslash.
// This is similar to JSON stringify escaping.


function strEscape(str) {
  var escapeTest = strEscapeSequencesRegExp;
  var escapeReplace = strEscapeSequencesReplacer;
  var singleQuote = 39; // Check for double quotes. If not present, do not escape single quotes and
  // instead wrap the text in double quotes. If double quotes exist, check for
  // backticks. If they do not exist, use those as fallback instead of the
  // double quotes.
  // eslint-disable-next-line quotes

  if (str.includes("'")) {
    // This invalidates the charCode and therefore can not be matched for
    // anymore.
    if (!str.includes('"')) {
      singleQuote = -1;
    } else if (!str.includes('`') && !str.includes('${')) {
      singleQuote = -2;
    }

    if (singleQuote !== 39) {
      escapeTest = strEscapeSequencesRegExpSingle;
      escapeReplace = strEscapeSequencesReplacerSingle;
    }
  } // Some magic numbers that worked out fine while benchmarking with v8 6.0


  if (str.length < 5000 && !escapeTest.test(str)) {
    return addQuotes(str, singleQuote);
  }

  if (str.length > 100) {
    str = str.replace(escapeReplace, escapeFn);
    return addQuotes(str, singleQuote);
  }

  var result = '';
  var last = 0;
  var lastIndex = str.length;

  for (var i = 0; i < lastIndex; i++) {
    var point = str.charCodeAt(i);

    if (point === singleQuote || point === 92 || point < 32) {
      if (last === i) {
        result += meta[point];
      } else {
        result += "".concat(str.slice(last, i)).concat(meta[point]);
      }

      last = i + 1;
    }
  }

  if (last !== lastIndex) {
    result += str.slice(last);
  }

  return addQuotes(result, singleQuote);
}

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style !== undefined) {
    var color = inspect.colors[style];
    return "\x1B[".concat(color[0], "m").concat(str, "\x1B[").concat(color[1], "m");
  }

  return str;
}

function stylizeNoColor(str) {
  return str;
} // Return a new empty array to push in the results of the default formatter.


function getEmptyFormatArray() {
  return [];
}

function getConstructorName(obj, _ctx) {
  var firstProto; // const tmp = obj;

  while (obj) {
    var descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');

    if (descriptor !== undefined && typeof descriptor.value === 'function' && descriptor.value.name !== '') {
      return descriptor.value.name;
    }

    obj = Object.getPrototypeOf(obj);

    if (firstProto === undefined) {
      firstProto = obj;
    }
  }

  if (firstProto === null) {
    return null;
  }
  /*
     @todo this calls into native, can we replace this somehow?
    return `${internalGetConstructorName(tmp)} <${inspect(firstProto, {
    	...ctx,
    	customInspect: false
    })}>`;
    */


  return null;
}

function getPrefix(constructor, tag, fallback) {
  if (constructor === null) {
    if (tag !== '') {
      return "[".concat(fallback, ": null prototype] [").concat(tag, "] ");
    }

    return "[".concat(fallback, ": null prototype] ");
  }

  if (tag !== '' && constructor !== tag) {
    return "".concat(constructor, " [").concat(tag, "] ");
  }

  return "".concat(constructor, " ");
} // Look up the keys of the object.


function getKeys(value, showHidden) {
  var keys;
  var symbols = Object.getOwnPropertySymbols(value);

  if (showHidden) {
    keys = Object.getOwnPropertyNames(value);

    if (symbols.length !== 0) {
      keys.push(...symbols);
    }
  } else {
    // This might throw if `value` is a Module Namespace Object from an
    // unevaluated module, but we don't want to perform the actual type
    // check because it's expensive.
    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209
    // and modify this logic as needed.
    try {
      keys = Object.keys(value);
    } catch (err) {
      // @fixme how to du isModuleNamespaceObject?

      /*
      assert(isNativeError(err) && err.name === 'ReferenceError' &&
      			 isModuleNamespaceObject(value));
      */
      keys = Object.getOwnPropertyNames(value);
    }

    if (symbols.length !== 0) {
      keys.push(...symbols.filter(key => propertyIsEnumerable$1(value, key)));
    }
  }

  return keys;
}

function getCtxStyle(value, constructor, tag) {
  var fallback = '';

  if (constructor === null) {
    fallback = 'Object';
  }

  return getPrefix(constructor, tag, fallback);
}

function findTypedConstructor(value) {
  for (var [check, clazz] of [[isUint8Array, Uint8Array], [isUint8ClampedArray, Uint8ClampedArray], [isUint16Array, Uint16Array], [isUint32Array, Uint32Array], [isInt8Array, Int8Array], [isInt16Array, Int16Array], [isInt32Array, Int32Array], [isFloat32Array, Float32Array], [isFloat64Array, Float64Array]]) {
    if (check(value)) {
      return clazz;
    }
  }
}

var lazyNullPrototypeCache; // Creates a subclass and name
// the constructor as `${clazz} : null prototype`

function clazzWithNullPrototype(clazz, name) {
  if (lazyNullPrototypeCache === undefined) {
    lazyNullPrototypeCache = new Map();
  } else {
    var cachedClass = lazyNullPrototypeCache.get(clazz);

    if (cachedClass !== undefined) {
      return cachedClass;
    }
  }

  class NullPrototype extends clazz {
    get [Symbol.toStringTag]() {
      return '';
    }}



  Object.defineProperty(NullPrototype.prototype.constructor, 'name', {
    value: "[".concat(name, ": null prototype]") });

  lazyNullPrototypeCache.set(clazz, NullPrototype);
  return NullPrototype;
}

function noPrototypeIterator(ctx, value, recurseTimes) {
  var newVal;

  if (isSet(value)) {
    var clazz = clazzWithNullPrototype(Set, 'Set');
    newVal = new clazz(SetPrototype.values(value));
  } else if (isMap(value)) {
    var _clazz = clazzWithNullPrototype(Map, 'Map');

    newVal = new _clazz(MapPrototype.entries(value));
  } else if (Array.isArray(value)) {
    var _clazz2 = clazzWithNullPrototype(Array, 'Array');

    newVal = new _clazz2(value.length);
  } else if (isTypedArray$1(value)) {
    var _constructor = findTypedConstructor(value);

    var _clazz3 = clazzWithNullPrototype(_constructor, _constructor.name);

    newVal = new _clazz3(value);
  }

  if (newVal !== undefined) {
    Object.defineProperties(newVal, Object.getOwnPropertyDescriptors(value));
    return formatRaw(ctx, newVal, recurseTimes);
  }
}

function formatValue(ctx, value, recurseTimes, typedArray) {
  // Primitive types cannot have properties.
  if (typeof value !== 'object' && typeof value !== 'function') {
    return formatPrimitive(ctx.stylize, value, ctx);
  }

  if (value === null) {
    return ctx.stylize('null', 'null');
  } // Memorize the context for custom inspection on proxies.


  var context = value;
  /*
                       @fixme check for proxies
                       // Always check for proxies to prevent side effects and to prevent triggering
                       // any proxy handlers.
                       const proxy = getProxyDetails(value);
                       if (proxy !== undefined) {
                       	if (ctx.showProxy) {
                       		return formatProxy(ctx, proxy, recurseTimes);
                       	}
                       	value = proxy[0];
                       }
                       */
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it.

  if (ctx.customInspect) {
    var maybeCustom = value[customInspectSymbol];

    if (typeof maybeCustom === 'function' // Filter out the util module, its inspect function is special.
    && maybeCustom !== inspect // Also filter out any prototype objects using the circular check.
    && !(value.constructor && value.constructor.prototype === value)) {
      // This makes sure the recurseTimes are reported as before while using
      // a counter internally.
      var depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
      var ret = maybeCustom.call(context, depth, getUserOptions(ctx)); // If the custom inspection method returned `this`, don't go into
      // infinite recursion.

      if (ret !== context) {
        if (typeof ret !== 'string') {
          return formatValue(ctx, ret, recurseTimes);
        }

        return ret.replace(/\n/g, "\n".concat(' '.repeat(ctx.indentationLvl)));
      }
    }
  } // Using an array here is actually better for the average case than using
  // a Set. `seen` will only check for the depth and will never grow too large.


  if (ctx.seen.includes(value)) {
    var index = 1;

    if (ctx.circular === undefined) {
      ctx.circular = new Map([[value, index]]);
    } else {
      index = ctx.circular.get(value);

      if (index === undefined) {
        index = ctx.circular.size + 1;
        ctx.circular.set(value, index);
      }
    }

    return ctx.stylize("[Circular *".concat(index, "]"), 'special');
  }

  return formatRaw(ctx, value, recurseTimes, typedArray);
}

function formatRaw(ctx, value, recurseTimes, typedArray) {
  var keys;
  var constructor = getConstructorName(value);
  var tag = value[Symbol.toStringTag]; // Only list the tag in case it's non-enumerable / not an own property.
  // Otherwise we'd print this twice.

  if (typeof tag !== 'string' || tag !== '' && (ctx.showHidden ? hasOwnProperty$1 : propertyIsEnumerable$1)(value, Symbol.toStringTag)) {
    tag = '';
  }

  var base = '';
  var formatter = getEmptyFormatArray;
  var braces;
  var noIterator = true;
  var i = 0;
  var filter = ctx.showHidden ? ALL_PROPERTIES$2 : ONLY_ENUMERABLE$2;
  var extrasType = kObjectType; // Iterators and the rest are split to reduce checks.

  if (value[Symbol.iterator]) {
    noIterator = false;

    if (Array.isArray(value)) {
      keys = getOwnNonIndexProperties(value, filter); // Only set the constructor for non ordinary ("Array [...]") arrays.

      var prefix = getPrefix(constructor, tag, 'Array');
      braces = ["".concat(prefix === 'Array ' ? '' : prefix, "["), ']'];

      if (value.length === 0 && keys.length === 0) {
        return "".concat(braces[0], "]");
      }

      extrasType = kArrayExtrasType;
      formatter = formatArray;
    } else if (isSet(value)) {
      keys = getKeys(value, ctx.showHidden);

      var _prefix = getPrefix(constructor, tag, 'Set');

      if (value.size === 0 && keys.length === 0) {
        return "".concat(_prefix, "{}");
      }

      braces = ["".concat(_prefix, "{"), '}'];
      formatter = formatSet;
    } else if (isMap(value)) {
      keys = getKeys(value, ctx.showHidden);

      var _prefix2 = getPrefix(constructor, tag, 'Map');

      if (value.size === 0 && keys.length === 0) {
        return "".concat(_prefix2, "{}");
      }

      braces = ["".concat(_prefix2, "{"), '}'];
      formatter = formatMap;
    } else if (isTypedArray$1(value)) {
      keys = getOwnNonIndexProperties(value, filter);

      var _prefix3 = constructor !== null ? getPrefix(constructor, tag) : getPrefix(constructor, tag, findTypedConstructor(value).name);

      braces = ["".concat(_prefix3, "["), ']'];

      if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
        return "".concat(braces[0], "]");
      }

      formatter = formatTypedArray;
      extrasType = kArrayExtrasType;
    } else if (isMapIterator(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces('Map', tag);
      formatter = formatIterator;
    } else if (isSetIterator(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces('Set', tag);
      formatter = formatIterator;
    } else {
      noIterator = true;
    }
  }

  if (noIterator) {
    keys = getKeys(value, ctx.showHidden);
    braces = ['{', '}'];

    if (constructor === 'Object') {
      if (isArgumentsObject(value)) {
        braces[0] = '[Arguments] {';
      } else if (tag !== '') {
        braces[0] = "".concat(getPrefix(constructor, tag, 'Object'), "{");
      }

      if (keys.length === 0) {
        return "".concat(braces[0], "}");
      }
    } else if (typeof value === 'function') {
      base = getFunctionBase(value, constructor, tag);

      if (keys.length === 0) {
        return ctx.stylize(base, 'special');
      }
    } else if (isRegExp(value)) {
      // Make RegExps say that they are RegExps
      // eslint-disable-next-line security/detect-non-literal-regexp
      var regExp = constructor !== null ? value : new RegExp(value);
      base = RegExpPrototype.toString.call(regExp);

      var _prefix4 = getPrefix(constructor, tag, 'RegExp');

      if (_prefix4 !== 'RegExp ') {
        base = "".concat(_prefix4).concat(base);
      }

      if (keys.length === 0 || recurseTimes > ctx.depth && ctx.depth !== null) {
        return ctx.stylize(base, 'regexp');
      }
    } else if (isDate(value)) {
      // Make dates with properties first say the date
      base = Number.isNaN(DatePrototype.getTime.call(value)) ? DatePrototype.toString.call(value) : DatePrototype.toISOString.call(value);

      var _prefix5 = getPrefix(constructor, tag, 'Date');

      if (_prefix5 !== 'Date ') {
        base = "".concat(_prefix5).concat(base);
      }

      if (keys.length === 0) {
        return ctx.stylize(base, 'date');
      }
    } else if (isError(value)) {
      base = formatError(value, constructor, tag, ctx);

      if (keys.length === 0) {
        return base;
      } else if (isIos$1) {
        var nativeErrorProps = ['line', 'column', 'sourceURL'];

        if (keys.every(key => nativeErrorProps.includes(key))) {
          return base;
        }
      }
    } else if (isAnyArrayBuffer(value)) {
      // Fast path for ArrayBuffer and SharedArrayBuffer.
      // Can't do the same for DataView because it has a non-primitive
      // .buffer property that we need to recurse for.
      var arrayType = isArrayBuffer(value) ? 'ArrayBuffer' : 'SharedArrayBuffer';

      var _prefix6 = getPrefix(constructor, tag, arrayType);

      if (typedArray === undefined) {
        formatter = formatArrayBuffer;
      } else if (keys.length === 0) {
        return "".concat(_prefix6, "{ byteLength: ").concat(formatNumber(ctx.stylize, value.byteLength), " }");
      }

      braces[0] = "".concat(_prefix6, "{");
      keys.unshift('byteLength');
    } else if (isDataView(value)) {
      braces[0] = "".concat(getPrefix(constructor, tag, 'DataView'), "{"); // .buffer goes last, it's not a primitive like the others.

      keys.unshift('byteLength', 'byteOffset', 'buffer');
    } else if (isPromise(value)) {
      braces[0] = "".concat(getPrefix(constructor, tag, 'Promise'), "{");
      formatter = formatPromise;
    } else if (isWeakSet(value)) {
      braces[0] = "".concat(getPrefix(constructor, tag, 'WeakSet'), "{");
      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
    } else if (isWeakMap(value)) {
      braces[0] = "".concat(getPrefix(constructor, tag, 'WeakMap'), "{");
      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
      /*
                                                                          * @fixme how to do isModuleNamespaceObject?
                                                                         } else if (isModuleNamespaceObject(value)) {
                                                                         	braces[0] = `[${tag}] {`;
                                                                         	formatter = formatNamespaceObject;
                                                                         */
    } else if (isBoxedPrimitive(value)) {
      base = getBoxedBase(value, ctx, keys, constructor, tag);

      if (keys.length === 0) {
        return base;
      }
    } else {
      // The input prototype got manipulated. Special handle these. We have to
      // rebuild the information so we are able to display everything.
      if (constructor === null) {
        var specialIterator = noPrototypeIterator(ctx, value, recurseTimes);

        if (specialIterator) {
          return specialIterator;
        }
      }

      if (isMapIterator(value)) {
        braces = getIteratorBraces('Map', tag);
        formatter = formatIterator;
      } else if (isSetIterator(value)) {
        braces = getIteratorBraces('Set', tag);
        formatter = formatIterator; // Handle other regular objects again.
      } else {
        if (keys.length === 0) {
          return "".concat(getCtxStyle(value, constructor, tag), "{}");
        }

        braces[0] = "".concat(getCtxStyle(value, constructor, tag), "{");
      }
    }
  }

  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    var constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);

    if (constructor !== null) {
      constructorName = "[".concat(constructorName, "]");
    }

    return ctx.stylize(constructorName, 'special');
  }

  recurseTimes += 1;
  ctx.seen.push(value);
  ctx.currentDepth = recurseTimes;
  var output;
  var indentationLvl = ctx.indentationLvl;

  try {
    output = formatter(ctx, value, recurseTimes, keys, braces);

    for (i = 0; i < keys.length; i++) {
      output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));
    }
  } catch (err) {
    var _constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);

    return handleMaxCallStackSize(ctx, err, _constructorName, indentationLvl);
  }

  if (ctx.circular !== undefined) {
    var index = ctx.circular.get(value);

    if (index !== undefined) {
      var reference = ctx.stylize("<ref *".concat(index, ">"), 'special'); // Add reference always to the very beginning of the output.

      if (ctx.compact !== true) {
        base = base === '' ? reference : "".concat(reference, " ").concat(base);
      } else {
        braces[0] = "".concat(reference, " ").concat(braces[0]);
      }
    }
  }

  ctx.seen.pop();

  if (ctx.sorted) {
    var comparator = ctx.sorted === true ? undefined : ctx.sorted;

    if (extrasType === kObjectType) {
      output = output.sort(comparator);
    } else if (keys.length > 1) {
      var sorted = output.slice(output.length - keys.length).sort(comparator);
      output.splice(output.length - keys.length, keys.length, ...sorted);
    }
  }

  var res = reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value);
  var budget = ctx.budget[ctx.indentationLvl] || 0;
  var newLength = budget + res.length;
  ctx.budget[ctx.indentationLvl] = newLength; // If any indentationLvl exceeds this limit, limit further inspecting to the
  // minimum. Otherwise the recursive algorithm might continue inspecting the
  // object even though the maximum string size (~2 ** 28 on 32 bit systems and
  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at
  // exactly 2 ** 27 but a bit higher. This depends on the object shape.
  // This limit also makes sure that huge objects don't block the event loop
  // significantly.

  if (newLength > Math.pow(2, 27)) {
    ctx.depth = -1;
  }

  return res;
}

function getIteratorBraces(type, tag) {
  if (tag !== "".concat(type, " Iterator")) {
    if (tag !== '') {
      tag += '] [';
    }

    tag += "".concat(type, " Iterator");
  }

  return ["[".concat(tag, "] {"), '}'];
}

function getBoxedBase(value, ctx, keys, constructor, tag) {
  var fn;
  var type;

  if (isNumberObject(value)) {
    fn = NumberPrototype;
    type = 'Number';
  } else if (isStringObject(value)) {
    fn = StringPrototype;
    type = 'String'; // For boxed Strings, we have to remove the 0-n indexed entries,
    // since they just noisy up the output and are redundant
    // Make boxed primitive Strings look like such

    keys.splice(0, value.length);
  } else if (isBooleanObject(value)) {
    fn = BooleanPrototype;
    type = 'Boolean';
  } else {
    fn = SymbolPrototype;
    type = 'Symbol';
  }

  var base = "[".concat(type);

  if (type !== constructor) {
    if (constructor === null) {
      base += ' (null prototype)';
    } else {
      base += " (".concat(constructor, ")");
    }
  }

  base += ": ".concat(formatPrimitive(stylizeNoColor, fn.valueOf(value), ctx), "]");

  if (tag !== '' && tag !== constructor) {
    base += " [".concat(tag, "]");
  }

  if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
    return base;
  }

  return ctx.stylize(base, type.toLowerCase());
}

function getFunctionBase(value, constructor, tag) {
  var type = 'Function';

  if (isGeneratorFunction(value)) {
    type = "Generator".concat(type);
  }

  if (isAsyncFunction(value)) {
    type = "Async".concat(type);
  }

  var base = "[".concat(type);

  if (constructor === null) {
    base += ' (null prototype)';
  }

  if (value.name === '') {
    base += ' (anonymous)';
  } else {
    base += ": ".concat(value.name);
  }

  base += ']';

  if (constructor !== type && constructor !== null) {
    base += " ".concat(constructor);
  }

  if (tag !== '' && constructor !== tag) {
    base += " [".concat(tag, "]");
  }

  return base;
}

function formatError(err, constructor, tag, ctx) {
  var stack = err.stack || ErrorPrototype.toString.call(err); // try to normalize JavaScriptCore stack to match v8

  if (isIos$1) {
    var lines = stack.split('\n');
    stack = "".concat(err.name, ": ").concat(err.message);

    if (lines.length > 0) {
      stack += lines.map(stackLine => {
        var atSymbolIndex = stackLine.indexOf('@');
        var source = stackLine.slice(atSymbolIndex + 1);
        var sourcePattern = /(.*):(\d+):(\d+)/;
        var symbolName = 'unknown';

        if (atSymbolIndex !== -1) {
          symbolName = stackLine.slice(0, atSymbolIndex);
        }

        var sourceMatch = source.match(sourcePattern);

        if (sourceMatch) {
          var filePath = sourceMatch[1];
          var lineNumber = sourceMatch[2];
          var column = sourceMatch[3];

          if (filePath.startsWith('file:')) {
            filePath = filePath.replace("file://".concat(Ti.Filesystem.resourcesDirectory), '');
          }

          return "\n    at ".concat(symbolName, " (").concat(filePath, ":").concat(lineNumber, ":").concat(column, ")");
        } else {
          return "\n    at ".concat(symbolName, " (").concat(source, ")");
        }
      }).join('');
    }
  } // A stack trace may contain arbitrary data. Only manipulate the output
  // for "regular errors" (errors that "look normal") for now.


  var name = err.name || 'Error';
  var len = name.length;

  if (constructor === null || name.endsWith('Error') && stack.startsWith(name) && (stack.length === len || stack[len] === ':' || stack[len] === '\n')) {
    var fallback = 'Error';

    if (constructor === null) {
      var start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
      fallback = start && start[1] || '';
      len = fallback.length;
      fallback = fallback || 'Error';
    }

    var prefix = getPrefix(constructor, tag, fallback).slice(0, -1);

    if (name !== prefix) {
      if (prefix.includes(name)) {
        if (len === 0) {
          stack = "".concat(prefix, ": ").concat(stack);
        } else {
          stack = "".concat(prefix).concat(stack.slice(len));
        }
      } else {
        stack = "".concat(prefix, " [").concat(name, "]").concat(stack.slice(len));
      }
    }
  } // Ignore the error message if it's contained in the stack.


  var pos = err.message && stack.indexOf(err.message) || -1;

  if (pos !== -1) {
    pos += err.message.length;
  } // Wrap the error in brackets in case it has no stack trace.


  var stackStart = stack.indexOf('\n    at', pos);

  if (stackStart === -1) {
    stack = "[".concat(stack, "]");
  } else if (ctx.colors) {
    // Highlight userland code and node modules.
    var newStack = stack.slice(0, stackStart);

    var _lines = stack.slice(stackStart + 1).split('\n');

    for (var line of _lines) {
      // This adds underscores to all node_modules to quickly identify them.
      var nodeModule = void 0;
      newStack += '\n';
      var _pos = 0;

      while (nodeModule = nodeModulesRegExp.exec(line)) {
        // '/node_modules/'.length === 14
        newStack += line.slice(_pos, nodeModule.index + 14);
        newStack += ctx.stylize(nodeModule[1], 'module');
        _pos = nodeModule.index + nodeModule[0].length;
      }

      newStack += _pos === 0 ? line : line.slice(_pos);
    }

    stack = newStack;
  } // The message and the stack have to be indented as well!


  if (ctx.indentationLvl !== 0) {
    var indentation = ' '.repeat(ctx.indentationLvl);
    stack = stack.replace(/\n/g, "\n".concat(indentation));
  }

  return stack;
}

function formatPromise(ctx, _value, _recurseTimes) {
  // Node calls into native to get promise details which we can't do
  return [ctx.stylize('<unknown>', 'special')];
}

function formatProperty(ctx, value, recurseTimes, key, type) {
  var name, str;
  var extra = ' ';
  var desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key],
    enumerable: true };


  if (desc.value !== undefined) {
    var diff = type !== kObjectType || ctx.compact !== true ? 2 : 3;
    ctx.indentationLvl += diff;
    str = formatValue(ctx, desc.value, recurseTimes);

    if (diff === 3) {
      var len = ctx.colors ? removeColors(str).length : str.length;

      if (ctx.breakLength < len) {
        extra = "\n".concat(' '.repeat(ctx.indentationLvl));
      }
    }

    ctx.indentationLvl -= diff;
  } else if (desc.get !== undefined) {
    var label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';
    var s = ctx.stylize;
    var sp = 'special';

    if (ctx.getters && (ctx.getters === true || ctx.getters === 'get' && desc.set === undefined || ctx.getters === 'set' && desc.set !== undefined)) {
      try {
        var tmp = value[key];
        ctx.indentationLvl += 2;

        if (tmp === null) {
          str = "".concat(s("[".concat(label, ":"), sp), " ").concat(s('null', 'null')).concat(s(']', sp));
        } else if (typeof tmp === 'object') {
          str = "".concat(s("[".concat(label, "]"), sp), " ").concat(formatValue(ctx, tmp, recurseTimes));
        } else {
          var primitive = formatPrimitive(s, tmp, ctx);
          str = "".concat(s("[".concat(label, ":"), sp), " ").concat(primitive).concat(s(']', sp));
        }

        ctx.indentationLvl -= 2;
      } catch (err) {
        var message = "<Inspection threw (".concat(err.message, ")>");
        str = "".concat(s("[".concat(label, ":"), sp), " ").concat(message).concat(s(']', sp));
      }
    } else {
      str = ctx.stylize("[".concat(label, "]"), sp);
    }
  } else if (desc.set !== undefined) {
    str = ctx.stylize('[Setter]', 'special');
  } else {
    str = ctx.stylize('undefined', 'undefined');
  }

  if (type === kArrayType) {
    return str;
  }

  if (typeof key === 'symbol') {
    var _tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);

    name = "[".concat(ctx.stylize(_tmp, 'symbol'), "]");
  } else if (desc.enumerable === false) {
    name = "[".concat(key.replace(strEscapeSequencesReplacer, escapeFn), "]");
  } else if (keyStrRegExp.test(key)) {
    name = ctx.stylize(key, 'name');
  } else {
    name = ctx.stylize(strEscape(key), 'string');
  }

  return "".concat(name, ":").concat(extra).concat(str);
}

function groupArrayElements(ctx, output, value) {
  var totalLength = 0;
  var maxLength = 0;
  var i = 0;
  var outputLength = output.length;

  if (ctx.maxArrayLength < output.length) {
    // This makes sure the "... n more items" part is not taken into account.
    outputLength--;
  }

  var separatorSpace = 2; // Add 1 for the space and 1 for the separator.

  var dataLen = new Array(outputLength); // Calculate the total length of all output entries and the individual max
  // entries length of all output entries. We have to remove colors first,
  // otherwise the length would not be calculated properly.

  for (; i < outputLength; i++) {
    var len = ctx.colors ? removeColors(output[i]).length : output[i].length;
    dataLen[i] = len;
    totalLength += len + separatorSpace;

    if (maxLength < len) {
      maxLength = len;
    }
  } // Add two to `maxLength` as we add a single whitespace character plus a comma
  // in-between two entries.


  var actualMax = maxLength + separatorSpace; // Check if at least three entries fit next to each other and prevent grouping
  // of arrays that contains entries of very different length (i.e., if a single
  // entry is longer than 1/5 of all other entries combined). Otherwise the
  // space in-between small entries would be enormous.

  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
    var approxCharHeights = 2.5;
    var averageBias = Math.sqrt(actualMax - totalLength / output.length);
    var biasedMax = Math.max(actualMax - 3 - averageBias, 1); // Dynamically check how many columns seem possible.

    var columns = Math.min( // Ideally a square should be drawn. We expect a character to be about 2.5
    // times as high as wide. This is the area formula to calculate a square
    // which contains n rectangles of size `actualMax * approxCharHeights`.
    // Divide that by `actualMax` to receive the correct number of columns.
    // The added bias increases the columns for short entries.
    Math.round(Math.sqrt(approxCharHeights * biasedMax * outputLength) / biasedMax), // Do not exceed the breakLength.
    Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), // Limit array grouping for small `compact` modes as the user requested
    // minimal grouping.
    ctx.compact * 4, // Limit the columns to a maximum of fifteen.
    15); // Return with the original output if no grouping should happen.

    if (columns <= 1) {
      return output;
    }

    var tmp = [];
    var maxLineLength = [];

    for (var _i = 0; _i < columns; _i++) {
      var lineMaxLength = 0;

      for (var j = _i; j < output.length; j += columns) {
        if (dataLen[j] > lineMaxLength) {
          lineMaxLength = dataLen[j];
        }
      }

      lineMaxLength += separatorSpace;
      maxLineLength[_i] = lineMaxLength;
    }

    var order = 'padStart';

    if (value !== undefined) {
      for (var _i2 = 0; _i2 < output.length; _i2++) {
        if (typeof value[_i2] !== 'number') {
          order = 'padEnd';
          break;
        }
      }
    } // Each iteration creates a single line of grouped entries.


    for (var _i3 = 0; _i3 < outputLength; _i3 += columns) {
      // The last lines may contain less entries than columns.
      var max = Math.min(_i3 + columns, outputLength);
      var str = '';
      var _j = _i3;

      for (; _j < max - 1; _j++) {
        // Calculate extra color padding in case it's active. This has to be
        // done line by line as some lines might contain more colors than
        // others.
        var padding = maxLineLength[_j - _i3] + output[_j].length - dataLen[_j];
        str += "".concat(output[_j], ", ")[order](padding, ' ');
      }

      if (order === 'padStart') {
        var _padding = maxLineLength[_j - _i3] + output[_j].length - dataLen[_j] - separatorSpace;

        str += output[_j].padStart(_padding, ' ');
      } else {
        str += output[_j];
      }

      tmp.push(str);
    }

    if (ctx.maxArrayLength < output.length) {
      tmp.push(output[outputLength]);
    }

    output = tmp;
  }

  return output;
}

function handleMaxCallStackSize(ctx, err, constructorName, indentationLvl) {
  if (isStackOverflowError(err)) {
    ctx.seen.pop();
    ctx.indentationLvl = indentationLvl;
    return ctx.stylize("[".concat(constructorName, ": Inspection interrupted 'prematurely. Maximum call stack size exceeded.]"), 'special');
  }

  throw err;
}

function formatNumber(fn, value) {
  // Format -0 as '-0'. Checking `value === -0` won't distinguish 0 from -0.
  return fn(Object.is(value, -0) ? '-0' : "".concat(value), 'number');
}

function formatBigInt(fn, value) {
  return fn("".concat(value, "n"), 'bigint');
}

function formatPrimitive(fn, value, ctx) {
  if (typeof value === 'string') {
    if (ctx.compact !== true && value.length > kMinLineLength && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
      return value.split(/\n/).map(line => fn(strEscape(line), 'string')).join(" +\n".concat(' '.repeat(ctx.indentationLvl + 2)));
    }

    return fn(strEscape(value), 'string');
  }

  if (typeof value === 'number') {
    return formatNumber(fn, value);
  }
  /*
    if (typeof value === 'bigint') {
    	return formatBigInt(fn, value);
    }
    */


  if (typeof value === 'boolean') {
    return fn("".concat(value), 'boolean');
  }

  if (typeof value === 'undefined') {
    return fn('undefined', 'undefined');
  } // es6 symbol primitive


  return fn(SymbolPrototype.toString.call(value), 'symbol');
} // The array is sparse and/or has extra keys


function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {
  var keys = Object.keys(value);
  var index = i;

  for (; i < keys.length && output.length < maxLength; i++) {
    var key = keys[i];
    var tmp = +key; // Arrays can only have up to 2^32 - 1 entries

    if (tmp > Math.pow(2, 32) - 2) {
      break;
    }

    if ("".concat(index) !== key) {
      if (!numberRegExp.test(key)) {
        break;
      }

      var emptyItems = tmp - index;
      var ending = emptyItems > 1 ? 's' : '';
      var message = "<".concat(emptyItems, " empty item").concat(ending, ">");
      output.push(ctx.stylize(message, 'undefined'));
      index = tmp;

      if (output.length === maxLength) {
        break;
      }
    }

    output.push(formatProperty(ctx, value, recurseTimes, key, kArrayType));
    index++;
  }

  var remaining = value.length - index;

  if (output.length !== maxLength) {
    if (remaining > 0) {
      var _ending = remaining > 1 ? 's' : '';

      var _message = "<".concat(remaining, " empty item").concat(_ending, ">");

      output.push(ctx.stylize(_message, 'undefined'));
    }
  } else if (remaining > 0) {
    output.push("... ".concat(remaining, " more item").concat(remaining > 1 ? 's' : ''));
  }

  return output;
}

function formatArrayBuffer(ctx, value) {
  var buffer = new Uint8Array(value);
  /*
                                      // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
                                      if (hexSlice === undefined) {
                                      	hexSlice = uncurryThis(require('../../buffer').default.Buffer.prototype.hexSlice);
                                      }
                                      */

  var str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, '$1 ').trim();
  var remaining = buffer.length - ctx.maxArrayLength;

  if (remaining > 0) {
    str += " ... ".concat(remaining, " more byte").concat(remaining > 1 ? 's' : '');
  }

  return ["".concat(ctx.stylize('[Uint8Contents]', 'special'), ": <").concat(str, ">")];
}

function formatArray(ctx, value, recurseTimes) {
  var valLen = value.length;
  var len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
  var remaining = valLen - len;
  var output = [];

  for (var i = 0; i < len; i++) {
    // Special handle sparse arrays.
    if (!hasOwnProperty$1(value, i)) {
      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
    }

    output.push(formatProperty(ctx, value, recurseTimes, i, kArrayType));
  }

  if (remaining > 0) {
    output.push("... ".concat(remaining, " more item").concat(remaining > 1 ? 's' : ''));
  }

  return output;
}

function formatTypedArray(ctx, value, recurseTimes) {
  var maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);
  var remaining = value.length - maxLength;
  var output = new Array(maxLength);
  var elementFormatter = value.length > 0 && typeof value[0] === 'number' ? formatNumber : formatBigInt;

  for (var i = 0; i < maxLength; ++i) {
    output[i] = elementFormatter(ctx.stylize, value[i]);
  }

  if (remaining > 0) {
    output[maxLength] = "... ".concat(remaining, " more item").concat(remaining > 1 ? 's' : '');
  }

  if (ctx.showHidden) {
    // .buffer goes last, it's not a primitive like the others.
    ctx.indentationLvl += 2;

    for (var key of ['BYTES_PER_ELEMENT', 'length', 'byteLength', 'byteOffset', 'buffer']) {
      var str = formatValue(ctx, value[key], recurseTimes, true);
      output.push("[".concat(key, "]: ").concat(str));
    }

    ctx.indentationLvl -= 2;
  }

  return output;
}

function formatSet(ctx, value, recurseTimes) {
  var output = [];
  ctx.indentationLvl += 2;

  for (var v of value) {
    output.push(formatValue(ctx, v, recurseTimes));
  }

  ctx.indentationLvl -= 2; // With `showHidden`, `length` will display as a hidden property for
  // arrays. For consistency's sake, do the same for `size`, even though this
  // property isn't selected by Object.getOwnPropertyNames().

  if (ctx.showHidden) {
    output.push("[size]: ".concat(ctx.stylize("".concat(value.size), 'number')));
  }

  return output;
}

function formatMap(ctx, value, recurseTimes) {
  var output = [];
  ctx.indentationLvl += 2;

  for (var [k, v] of value) {
    output.push("".concat(formatValue(ctx, k, recurseTimes), " => ").concat(formatValue(ctx, v, recurseTimes)));
  }

  ctx.indentationLvl -= 2; // See comment in formatSet

  if (ctx.showHidden) {
    output.push("[size]: ".concat(ctx.stylize("".concat(value.size), 'number')));
  }

  return output;
}

function formatSetIterInner(ctx, recurseTimes, entries, state) {
  var maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  var maxLength = Math.min(maxArrayLength, entries.length);
  var output = new Array(maxLength);
  ctx.indentationLvl += 2;

  for (var i = 0; i < maxLength; i++) {
    output[i] = formatValue(ctx, entries[i], recurseTimes);
  }

  ctx.indentationLvl -= 2;

  if (state === kWeak && !ctx.sorted) {
    // Sort all entries to have a halfway reliable output (if more entries than
    // retrieved ones exist, we can not reliably return the same output) if the
    // output is not sorted anyway.
    output = output.sort();
  }

  var remaining = entries.length - maxLength;

  if (remaining > 0) {
    output.push("... ".concat(remaining, " more item").concat(remaining > 1 ? 's' : ''));
  }

  return output;
}

function formatMapIterInner(ctx, recurseTimes, entries, state) {
  var maxArrayLength = Math.max(ctx.maxArrayLength, 0); // Entries exist as [key1, val1, key2, val2, ...]

  var len = entries.length / 2;
  var remaining = len - maxArrayLength;
  var maxLength = Math.min(maxArrayLength, len);
  var output = new Array(maxLength);
  var i = 0;
  ctx.indentationLvl += 2;

  if (state === kWeak) {
    for (; i < maxLength; i++) {
      var pos = i * 2;
      output[i] = "".concat(formatValue(ctx, entries[pos], recurseTimes)) + " => ".concat(formatValue(ctx, entries[pos + 1], recurseTimes));
    } // Sort all entries to have a halfway reliable output (if more entries than
    // retrieved ones exist, we can not reliably return the same output) if the
    // output is not sorted anyway.


    if (!ctx.sorted) {
      output = output.sort();
    }
  } else {
    for (; i < maxLength; i++) {
      var _pos2 = i * 2;

      var res = [formatValue(ctx, entries[_pos2], recurseTimes), formatValue(ctx, entries[_pos2 + 1], recurseTimes)];
      output[i] = reduceToSingleString(ctx, res, '', ['[', ']'], kArrayExtrasType, recurseTimes);
    }
  }

  ctx.indentationLvl -= 2;

  if (remaining > 0) {
    output.push("... ".concat(remaining, " more item").concat(remaining > 1 ? 's' : ''));
  }

  return output;
}

function formatWeakCollection(ctx) {
  return [ctx.stylize('<items unknown>', 'special')];
}

function formatWeakSet(ctx, _value, _recurseTimes) {
  // Node calls into native to get a preview of actual values which we can't do
  return formatWeakCollection(ctx);
}

function formatWeakMap(ctx, _value, _recurseTimes) {
  // Node calls into native to get a preview of actual values which we can't do
  return formatWeakCollection(ctx);
}

function formatIterator(ctx, value, recurseTimes, _keys, braces) {
  var entries = [];
  var isKeyValue = false;
  var result = value.next();

  while (!result.done) {
    var currentEntry = result.value;
    entries.push(currentEntry);

    if (currentEntry[0] !== currentEntry[1]) {
      isKeyValue = true;
    }

    result = value.next();
  }

  if (isKeyValue) {
    // Mark entry iterators as such.
    braces[0] = braces[0].replace(/ Iterator] {$/, ' Entries] {');
    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);
  }

  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);
}

function isBelowBreakLength(ctx, output, start, base) {
  // Each entry is separated by at least a comma. Thus, we start with a total
  // length of at least `output.length`. In addition, some cases have a
  // whitespace in-between each other that is added to the total as well.
  var totalLength = output.length + start;

  if (totalLength + output.length > ctx.breakLength) {
    return false;
  }

  for (var i = 0; i < output.length; i++) {
    if (ctx.colors) {
      totalLength += removeColors(output[i]).length;
    } else {
      totalLength += output[i].length;
    }

    if (totalLength > ctx.breakLength) {
      return false;
    }
  } // Do not line up properties on the same line if `base` contains line breaks.


  return base === '' || !base.includes('\n');
}

function reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value) {
  if (ctx.compact !== true) {
    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {
      // Memorize the original output length. In case the the output is grouped,
      // prevent lining up the entries on a single line.
      var entries = output.length; // Group array elements together if the array contains at least six
      // separate entries.

      if (extrasType === kArrayExtrasType && entries > 6) {
        output = groupArrayElements(ctx, output, value);
      } // `ctx.currentDepth` is set to the most inner depth of the currently
      // inspected object part while `recurseTimes` is the actual current depth
      // that is inspected.
      //
      // Example:
      //
      // const a = { first: [ 1, 2, 3 ], second: { inner: [ 1, 2, 3 ] } }
      //
      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max
      // depth of 1.
      //
      // Consolidate all entries of the local most inner depth up to
      // `ctx.compact`, as long as the properties are smaller than
      // `ctx.breakLength`.


      if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
        // Line up all entries on a single line in case the entries do not
        // exceed `breakLength`. Add 10 as constant to start next to all other
        // factors that may reduce `breakLength`.
        var start = output.length + ctx.indentationLvl + braces[0].length + base.length + 10;

        if (isBelowBreakLength(ctx, output, start, base)) {
          return "".concat(base ? "".concat(base, " ") : '').concat(braces[0], " ").concat(join(output, ', '), " ").concat(braces[1]);
        }
      }
    } // Line up each entry on an individual line.


    var _indentation = "\n".concat(' '.repeat(ctx.indentationLvl));

    return "".concat(base ? "".concat(base, " ") : '').concat(braces[0]).concat(_indentation, "  ") + "".concat(join(output, ",".concat(_indentation, "  "))).concat(_indentation).concat(braces[1]);
  } // Line up all entries on a single line in case the entries do not exceed
  // `breakLength`.


  if (isBelowBreakLength(ctx, output, 0, base)) {
    return "".concat(braces[0]).concat(base ? " ".concat(base) : '', " ").concat(join(output, ', '), " ") + braces[1];
  }

  var indentation = ' '.repeat(ctx.indentationLvl); // If the opening "brace" is too large, like in the case of "Set {",
  // we need to force the first item to be on the next line or the
  // items will not line up correctly.

  var ln = base === '' && braces[0].length === 1 ? ' ' : "".concat(base ? " ".concat(base) : '', "\n").concat(indentation, "  "); // Line up each entry on an individual line.

  return "".concat(braces[0]).concat(ln).concat(join(output, ",\n".concat(indentation, "  ")), " ").concat(braces[1]);
}

function format(...args) {
  return formatWithOptions(undefined, ...args);
}

var firstErrorLine = error => error.message.split('\n')[0];

var CIRCULAR_ERROR_MESSAGE;

function tryStringify(arg) {
  try {
    return JSON.stringify(arg);
  } catch (err) {
    // Populate the circular error message lazily
    if (!CIRCULAR_ERROR_MESSAGE) {
      try {
        var a = {};
        a.a = a;
        JSON.stringify(a);
      } catch (e) {
        CIRCULAR_ERROR_MESSAGE = firstErrorLine(e);
      }
    }

    if (err.name === 'TypeError' && firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {
      return '[Circular]';
    }

    throw err;
  }
}
/* eslint-disable max-depth */


function formatWithOptions(inspectOptions, ...args) {
  var first = args[0];
  var a = 0;
  var str = '';
  var join = '';

  if (typeof first === 'string') {
    if (args.length === 1) {
      return first;
    }

    var tempStr;
    var lastPos = 0;

    for (var i = 0; i < first.length - 1; i++) {
      if (first.charCodeAt(i) === 37) {
        // '%'
        var nextChar = first.charCodeAt(++i);

        if (a + 1 !== args.length) {
          switch (nextChar) {
            case 115:
              // 's'
              var tempArg = args[++a];

              if (typeof tempArg === 'number') {
                tempStr = formatNumber(stylizeNoColor, tempArg);
                /*
                                                                 } else if (typeof tempArg === 'bigint') {
                                                                 	tempStr = `${tempArg}n`;
                                                                 */
              } else {
                var constr = void 0;

                if (typeof tempArg !== 'object' || tempArg === null || typeof tempArg.toString === 'function' && (hasOwnProperty$1(tempArg, 'toString') // A direct own property on the constructor prototype in
                // case the constructor is not an built-in object.
                || (constr = tempArg.constructor) && !builtInObjects.has(constr.name) && constr.prototype && hasOwnProperty$1(constr.prototype, 'toString'))) {
                  tempStr = String(tempArg);
                } else {
                  tempStr = inspect(tempArg, _objectSpread2({}, inspectOptions, {
                    compact: 3,
                    colors: false,
                    depth: 0 }));

                }
              }

              break;

            case 106:
              // 'j'
              tempStr = tryStringify(args[++a]);
              break;

            case 100:
              // 'd'
              var tempNum = args[++a];
              /*
                                       if (typeof tempNum === 'bigint') {
                                       	tempStr = `${tempNum}n`;
                                       } else
                                       */

              if (typeof tempNum === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, Number(tempNum));
              }

              break;

            case 79:
              // 'O'
              tempStr = inspect(args[++a], inspectOptions);
              break;

            case 111:
              // 'o'
              {
                tempStr = inspect(args[++a], _objectSpread2({}, inspectOptions, {
                  showHidden: true,
                  showProxy: true,
                  depth: 4 }));

                break;
              }

            case 105:
              // 'i'
              var tempInteger = args[++a];
              /*
                                           if (typeof tempInteger === 'bigint') {
                                           	tempStr = `${tempInteger}n`;
                                           } else */

              if (typeof tempInteger === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, parseInt(tempInteger));
              }

              break;

            case 102:
              // 'f'
              var tempFloat = args[++a];

              if (typeof tempFloat === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, parseFloat(tempFloat));
              }

              break;

            case 37:
              // '%'
              str += first.slice(lastPos, i);
              lastPos = i + 1;
              continue;

            default:
              // Any other character is not a correct placeholder
              continue;}


          if (lastPos !== i - 1) {
            str += first.slice(lastPos, i - 1);
          }

          str += tempStr;
          lastPos = i + 1;
        } else if (nextChar === 37) {
          str += first.slice(lastPos, i);
          lastPos = i + 1;
        }
      }
    }

    if (lastPos !== 0) {
      a++;
      join = ' ';

      if (lastPos < first.length) {
        str += first.slice(lastPos);
      }
    }
  }

  while (a < args.length) {
    var value = args[a];
    str += join;
    str += typeof value !== 'string' ? inspect(value, inspectOptions) : value;
    join = ' ';
    a++;
  }

  return str;
}
/* eslint-enable max-depth */

var nativeDebug = console.debug;
var nativeError = console.error;
var nativeInfo = console.info;
var nativeLog = console.log;
var nativeWarn = console.warn;
var kColorInspectOptions = {
  colors: true };

var kNoColorInspectOptions = {};

console.debug = function (...args) {
  nativeDebug.call(console, formatWithOptions(kColorInspectOptions, ...args));
};

console.error = function (...args) {
  nativeError.call(console, formatWithOptions(kNoColorInspectOptions, ...args));
};

console.info = function (...args) {
  nativeInfo.call(console, formatWithOptions(kColorInspectOptions, ...args));
};

console.log = function (...args) {
  nativeLog.call(console, formatWithOptions(kColorInspectOptions, ...args));
};

console.warn = function (...args) {
  nativeWarn.call(console, formatWithOptions(kNoColorInspectOptions, ...args));
};

/**
    * Appcelerator Titanium Mobile
    * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.
    * Licensed under the terms of the Apache Public License
    * Please see the LICENSE included with this distribution for details.
    */
// Add a toJSON() method to all Error objects needed to output non-enumerable properties.
// The JSON.stringify() will automatically call this method if it exists to provide custom output.
// Notes:
// - In V8, all Error properties are not enumerable. We need this or else stringify() will return "{}".
// - In JavaScriptCore, only the "stack" property is not enumerable. We want to reveal this.
if (typeof Error.prototype.toJSON !== 'function') {
  Error.prototype.toJSON = function () {
    var properties = {};
    Object.getOwnPropertyNames(this).forEach(function (name) {
      properties[name] = this[name];
    }, this);
    return properties;
  };
}

/**
   * Appcelerator Titanium Mobile
   * Copyright (c) 2019 by Axway, Inc. All Rights Reserved.
   * Licensed under the terms of the Apache Public License
   * Please see the LICENSE included with this distribution for details.
   */
{
  var buffer = Ti.createBuffer({
    value: '' });

  var blob = buffer.toBlob();

  blob.constructor.prototype.toString = function () {
    var value = this.text;
    return value === undefined ? '[object TiBlob]' : value;
  };

  if (parseInt(Ti.Platform.version.split('.')[0]) < 11) {
    // This is hack to fix TIMOB-27707. Remove it after minimum target set iOS 11+
    setTimeout(function () {}, Infinity);
  }
}

/**
   * Appcelerator Titanium Mobile
   * Copyright (c) 2019 by Axway, Inc. All Rights Reserved.
   * Licensed under the terms of the Apache Public License
   * Please see the LICENSE included with this distribution for details.
   */
var colorset;
var osVersion; // As Android passes a new instance of Ti.UI to every JS file we can't just
// Ti.UI within this file, we must call kroll.binding to get the Titanium
// namespace that is passed in with require and that deal with the .UI
// namespace that is on that directly.

var uiModule = Ti.UI;

if (Ti.Android) {
  uiModule = kroll.binding('Titanium').Titanium.UI;
}

uiModule.SEMANTIC_COLOR_TYPE_LIGHT = 'light';
uiModule.SEMANTIC_COLOR_TYPE_DARK = 'dark'; // We need to track this manually with a getter/setter
// due to the same reasons we use uiModule instead of Ti.UI

var currentColorType = uiModule.SEMANTIC_COLOR_TYPE_LIGHT;
Object.defineProperty(uiModule, 'semanticColorType', {
  get: () => {
    return currentColorType;
  },
  set: colorType => {
    currentColorType = colorType;
  } });


uiModule.fetchSemanticColor = function fetchSemanticColor(colorName) {
  if (!osVersion) {
    osVersion = parseInt(Ti.Platform.version.split('.')[0]);
  }

  if (Ti.App.iOS && osVersion >= 13) {
    return Ti.UI.iOS.fetchSemanticColor(colorName);
  } else {
    if (!colorset) {
      try {
        var colorsetFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, 'semantic.colors.json');

        if (colorsetFile.exists()) {
          colorset = JSON.parse(colorsetFile.read().text);
        }
      } catch (error) {
        console.error('Failed to load colors file \'semantic.colors.json\'');
        return;
      }
    }

    try {
      return colorset[colorName][uiModule.semanticColorType].color || colorset[colorName][uiModule.semanticColorType];
    } catch (error) {
      console.error("Failed to lookup color for ".concat(colorName));
    }
  }
};

/**
    * @param {EventEmitter} emitter the EventEmitter instance to use to register for it's events
    * @param {string} eventName the name of the event to register for
    * @param {function} listener the listener callback/function to invoke when the event is emitted
    * @param {boolean} prepend whether to prepend or append the listener
    * @returns {EventEmitter}
    */
function _addListener(emitter, eventName, listener, prepend) {
  if (!emitter._eventsToListeners) {
    // no events/listeners registered
    emitter._eventsToListeners = {}; // initialize it
  } // if there's someone listening to 'newListener' events, emit that **before** we add the listener (to avoid infinite recursion)


  if (emitter._eventsToListeners.newListener) {
    emitter.emit('newListener', eventName, listener);
  }

  var eventListeners = emitter._eventsToListeners[eventName] || [];

  if (prepend) {
    eventListeners.unshift(listener);
  } else {
    eventListeners.push(listener);
  }

  emitter._eventsToListeners[eventName] = eventListeners; // Check max listeners and spit out warning if >

  var max = emitter.getMaxListeners();
  var length = eventListeners.length;

  if (max > 0 && length > max) {
    var w = new Error("Possible EventEmitter memory leak detected. ".concat(length, " ").concat(eventName, " listeners added. Use emitter.setMaxListeners() to increase limit"));
    w.name = 'MaxListenersExceededWarning';
    w.emitter = emitter;
    w.type = eventName;
    w.count = length;
    process.emitWarning(w);
  }

  return emitter;
}

function onceWrap(emitter, eventName, listener) {
  function wrapper(...args) {
    this.emitter.removeListener(this.eventName, this.wrappedFunc); // remove ourselves

    this.listener.apply(this.emitter, args); // then forward the event callback
  } // we have to use bind with a custom 'this', because events fire with 'this' pointing at the emitter


  var wrapperThis = {
    emitter,
    eventName,
    listener };

  var bound = wrapper.bind(wrapperThis); // bind to force "this" to refer to our custom object tracking the wrapper/emitter/listener

  bound.listener = listener; // have to add listener property for "unwrapping"

  wrapperThis.wrappedFunc = bound;
  return bound;
} // many consumers make use of this via util.inherits, which does not chain constructor calls!
// so we need to be aware that _eventsToListeners maye be null/undefined on instances, and check in methods before accessing it


class EventEmitter {
  constructor() {
    this._eventsToListeners = {};
    this._maxListeners = undefined;
  }

  addListener(eventName, listener) {
    return _addListener(this, eventName, listener, false);
  }

  on(eventName, listener) {
    return this.addListener(eventName, listener);
  }

  prependListener(eventName, listener) {
    return _addListener(this, eventName, listener, true);
  }

  once(eventName, listener) {
    this.on(eventName, onceWrap(this, eventName, listener));
  }

  prependOnceListener(eventName, listener) {
    this.prependListener(eventName, onceWrap(this, eventName, listener));
  }

  removeListener(eventName, listener) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return this;
    }

    var eventListeners = this._eventsToListeners[eventName] || [];
    var length = eventListeners.length;
    var foundIndex = -1;
    var unwrappedListener; // Need to search LIFO, and need to handle wrapped functions (once wrappers)

    for (var i = length - 1; i >= 0; i--) {
      if (eventListeners[i] === listener || eventListeners[i].listener === listener) {
        foundIndex = i;
        unwrappedListener = eventListeners[i].listener;
        break;
      }
    }

    if (foundIndex !== -1) {
      if (length === 1) {
        // length was 1 and we want to remove last entry, so delete the event type from our listener mapping now!
        delete this._eventsToListeners[eventName];
      } else {
        // we had 2+ listeners, so store array without this given listener
        eventListeners.splice(foundIndex, 1); // modifies in place, no need to assign to this.listeners[eventName]
      } // Don't emit if there's no listeners for 'removeListener' type!


      if (this._eventsToListeners.removeListener) {
        this.emit('removeListener', eventName, unwrappedListener || listener);
      }
    }

    return this;
  }

  off(eventName, listener) {
    return this.removeListener(eventName, listener);
  }

  emit(eventName, ...args) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return false;
    }

    var eventListeners = this._eventsToListeners[eventName] || [];

    for (var listener of eventListeners.slice()) {
      // must operate on copy because listeners ,ay get remove as side-effect of calling
      listener.call(this, ...args);
    }

    return eventListeners.length !== 0;
  }

  listenerCount(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return 0;
    }

    var eventListeners = this._eventsToListeners[eventName] || [];
    return eventListeners.length;
  }

  eventNames() {
    return Object.getOwnPropertyNames(this._eventsToListeners || {});
  }

  listeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return [];
    } // Need to "unwrap" once wrappers!


    var raw = this._eventsToListeners[eventName] || [];
    return raw.map(l => l.listener || l); // here we unwrap the once wrapper if there is one or fall back to listener function
  }

  rawListeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return [];
    }

    return (this._eventsToListeners[eventName] || []).slice(0); // return a copy
  }

  getMaxListeners() {
    return this._maxListeners || EventEmitter.defaultMaxListeners;
  }

  setMaxListeners(n) {
    this._maxListeners = n; // TODO: Type check n, make sure >= 0 (o equals no limit)

    return this;
  }

  removeAllListeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      this._eventsToListeners = {}; // initialize it
    }

    if (!this._eventsToListeners.removeListener) {
      // no need to emit! we can just wipe!
      if (eventName === undefined) {
        // remove every type!
        this._eventsToListeners = {};
      } else {
        // remove specific type
        delete this._eventsToListeners[eventName];
      }

      return this;
    } // yuck, we'll have to emit 'removeListener' events as we go


    if (eventName === undefined) {
      // Remove all types (but do 'removeListener' last!)
      var names = Object.keys(this._eventsToListeners).filter(name => name !== 'removeListener');
      names.forEach(name => this.removeAllListeners(name));
      this.removeAllListeners('removeListener');
      this._eventsToListeners = {};
    } else {
      // remove listeners for one type, back to front (Last-in, first-out, except where prepend f-ed it up)
      var listeners = this._eventsToListeners[eventName] || [];

      for (var i = listeners.length - 1; i >= 0; i--) {
        this.removeListener(eventName, listeners[i]);
      }
    }

    return this;
  }}


EventEmitter.defaultMaxListeners = 10;

EventEmitter.listenerCount = function (emitter, eventName) {
  return emitter.listenerCount(eventName);
};

EventEmitter.EventEmitter = EventEmitter;

/**
                                           * @param  {*} arg passed in argument value
                                           * @param  {string} name name of the argument
                                           * @param  {string} typename i.e. 'string', 'Function' (value is compared to typeof after lowercasing)
                                           * @return {void}
                                           * @throws {TypeError}
                                           */
function assertArgumentType(arg, name, typename) {
  var type = typeof arg;

  if (type !== typename.toLowerCase()) {
    throw new TypeError("The \"".concat(name, "\" argument must be of type ").concat(typename, ". Received type ").concat(type));
  }
}

var startTime = Date.now();
/**
                             * This function 'standardizes' the reported architectures to the equivalents reported by Node.js
                             * node values: 'arm', 'arm64', 'ia32', 'mips', 'mipsel', 'ppc', 'ppc64', 's390', 's390x', 'x32', and 'x64'.
                             * iOS values: "arm64", "armv7", "x86_64", "i386", "Unknown"
                             * Android values: "armeabi", "armeabi-v7a", "arm64-v8a", "x86", "x86_64", "mips", "mips64", "unknown"
                             * Windows values: "x64", "ia64", "ARM", "x86", "unknown"
                             * @param {string} original original architecture reported by Ti.Platform
                             * @returns {string}
                             */

function standardizeArch(original) {
  switch (original) {
    // coerce 'armv7', 'armeabi', 'armeabi-v7a', 'ARM' -> 'arm'
    // 'armeabi' is a dead ABI for Android, removed in NDK r17
    case 'armv7':
    case 'armeabi':
    case 'armeabi-v7a':
    case 'ARM':
      return 'arm';
    // coerce 'arm64-v8a' -> 'arm64'

    case 'arm64-v8a':
      return 'arm64';
    // coerce 'i386', 'x86' -> 'ia32'

    case 'i386':
    case 'x86':
      return 'ia32';
    // coerce 'x86_64', 'ia64', 'x64' -> 'x64'

    case 'x86_64':
    case 'ia64':
      return 'x64';
    // coerce 'mips64' -> 'mips' // 'mips' and 'mips64' are dead ABIs for Android, removed in NDK r17

    case 'mips64':
      return 'mips';
    // coerce 'Unknown' -> 'unknown'

    case 'Unknown':
      return 'unknown';

    default:
      return original;}

}

var process$5 = new EventEmitter();

process$5.abort = () => {}; // TODO: Do we have equivalent of forcibly killing the process? We have restart, but I think we just want a no-op stub here


process$5.arch = standardizeArch(Ti.Platform.architecture);
process$5.argv = []; // TODO: What makes sense here? path to titanium cli for first arg? path to ti.main/app.js for second?

Object.defineProperty(process$5, 'argv0', {
  value: '',
  // TODO: Path to .app on iOS?
  writable: false,
  enumerable: true,
  configurable: false });


process$5.binding = () => {
  throw new Error('process.binding is unsupported and not user-facing API');
};

process$5.channel = undefined;

process$5.chdir = () => {
  throw new Error('process.chdir is unsupported');
};

process$5.config = {};
process$5.connected = false;

process$5.cpuUsage = () => {
  // FIXME: Can we look at OS.cpus to get this data?
  return {
    user: 0,
    system: 0 };

};

process$5.cwd = () => __dirname;

Object.defineProperty(process$5, 'debugPort', {
  get: function () {
    var value = 0; // default to 0

    try {
      if (Ti.Platform.osname === 'android') {
        var assets = kroll.binding('assets');
        var json = assets.readAsset('deploy.json');

        if (json) {
          var deployData = JSON.parse(json);

          if (deployData.debuggerPort !== -1) {
            // -1 means not set (not in debug mode)
            value = deployData.debuggerPort;
          }
        }
      } else if (true) {
        // iOS is 27753 as of ios < 11.3 for simulators
        // for 11.3+ it uses a unix socket
        // for devices, it uses usbmuxd
        value = 27753; // TODO: Can we only return this for simulator < 11.3?
      }
    } catch (error) {} // ignore
    // overwrite this getter with static value


    Object.defineProperty(this, 'debugPort', {
      value: value,
      writable: true,
      enumerable: true,
      configurable: true });

    return value;
  },
  enumerable: true,
  configurable: true });


process$5.disconnect = () => {}; // no-op


process$5.dlopen = () => {
  throw new Error('process.dlopen is not supported');
};

process$5.emitWarning = function (warning, options, code, ctor) {
  // eslint-disable-line no-unused-vars
  var type;
  var detail;

  if (typeof options === 'string') {
    type = options;
  } else if (typeof options === 'object') {
    type = options.type;
    code = options.code;
    detail = options.detail;
  }

  if (typeof warning === 'string') {
    // TODO: make use of `ctor` arg for limiting stack traces? Can only really be used on V8
    // set stack trace limit to 0, then call Error.captureStackTrace(warning, ctor);
    warning = new Error(warning);
    warning.name = type || 'Warning';

    if (code !== undefined) {
      warning.code = code;
    }

    if (detail !== undefined) {
      warning.detail = detail;
    }
  } // TODO: Throw TypeError if not an instanceof Error at this point!


  var isDeprecation = warning.name === 'DeprecationWarning';

  if (isDeprecation && process$5.noDeprecation) {
    return; // ignore
  }

  if (isDeprecation && process$5.throwDeprecation) {
    throw warning;
  }

  this.emit('warning', warning);
};

function loadEnvJson() {
  try {
    var jsonFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, '_env_.json');

    if (jsonFile.exists()) {
      return JSON.parse(jsonFile.read().text);
    }
  } catch (error) {
    Ti.API.error("Failed to read \"_env_.json\". Reason: ".concat(error.message));
  }

  return {};
}

Object.defineProperty(process$5, 'env', {
  get: function () {
    delete this.env;
    return this.env = loadEnvJson();
  },
  enumerable: true,
  configurable: true });

process$5.execArgv = [];
process$5.execPath = ''; // FIXME: What makes sense here? Path to titanium CLI here?

process$5.exit = () => {
  throw new Error('process.exit is not supported');
};

process$5.exitCode = undefined;
process$5.noDeprecation = false;
process$5.pid = 0; // FIXME: Should we try and adopt 'ipad'/'iphone' to 'darwin'? or 'ios'?

process$5.platform = Ti.Platform.osname;
process$5.ppid = 0; // TODO: Add release property (Object)
// TODO: Can we expose stdout/stderr/stdin natively?

process$5.stderr = {
  isTTY: false,
  writable: true,
  write: (chunk, encoding, callback) => {
    console.error(chunk);

    if (callback) {
      callback();
    }

    return true;
  } };

process$5.stdout = {
  isTTY: false,
  writable: true,
  write: (chunk, encoding, callback) => {
    console.log(chunk);

    if (callback) {
      callback();
    }

    return true;
  } };

process$5.title = Ti.App.name;
process$5.throwDeprecation = false;
process$5.traceDeprecation = false;

process$5.umask = () => 0; // just always return 0


process$5.uptime = () => {
  var diffMs = Date.now() - startTime;
  return diffMs / 1000.0; // convert to "seconds" with fractions
};

process$5.version = "9.1.0";
process$5.versions = {
  modules: '',
  // TODO: Report module api version (for current platform!)
  v8: '',
  // TODO: report android's v8 version (if on Android!)
  jsc: '' // TODO: report javascriptcore version for iOS/WIndows?
  // TODO: Report ios/Android/Windows platform versions?
};

global.process = process$5; // handle spitting out warnings

var WARNING_PREFIX = "(titanium:".concat(process$5.pid, ") ");
process$5.on('warning', warning => {
  var isDeprecation = warning.name === 'DeprecationWarning'; // if we're not doing deprecations, ignore!

  if (isDeprecation && process$5.noDeprecation) {
    return;
  } // TODO: Check process.traceDeprecation and if set, include stack trace in message!


  var msg = WARNING_PREFIX;

  if (warning.code !== undefined) {
    msg += "[".concat(warning.code, "] ");
  }

  if (warning.toString) {
    msg += warning.toString();
  }

  if (warning.detail) {
    msg += "\n".concat(warning.detail);
  }

  console.error(msg);
});
var uncaughtExceptionCallback = null;

process$5.hasUncaughtExceptionCaptureCallback = () => uncaughtExceptionCallback !== null;

process$5.setUncaughtExceptionCaptureCallback = fn => {
  if (fn === null) {
    uncaughtExceptionCallback = null;
    return;
  }

  assertArgumentType(fn, 'fn', 'function');

  if (uncaughtExceptionCallback !== null) {
    throw new Error('`process.setUncaughtExceptionCaptureCallback()` was called while a capture callback was already active');
  }

  uncaughtExceptionCallback = fn;
};

Ti.App.addEventListener('uncaughtException', function (event) {
  // Create an Error instance that wraps the data from the event
  // ideally we'd just forward along the original Error!
  var error = new Error(event.message);
  error.stack = event.backtrace;
  error.fileName = event.sourceName;
  error.lineNumber = event.line;
  error.columnNumber = event.lineOffset;

  if (process$5.hasUncaughtExceptionCaptureCallback()) {
    return uncaughtExceptionCallback(error);
  } // otherwise forward the event!


  process$5.emit('uncaughtException', error);
});
// JS engine should be able to optimize easier

class CallbackWithArgs {
  constructor(func, args) {
    this.func = func;
    this.args = args;
  }

  run() {
    if (this.args) {
      this.func.apply(null, this.args);
    } else {
      this.fun();
    }
  }}

// nextTick vs setImmediate should be handled in a semi-smart way
// Basically nextTick needs to drain the full queue (and can cause infinite loops if nextTick callback calls nextTick!)
// Then we should go through the "immediate" queue
// http://plafer.github.io/2015/09/08/nextTick-vs-setImmediate/


var tickQueue = [];
var immediateQueue = [];
var drainingTickQueue = false;
var drainQueuesTimeout = null;
/**
                                * Iteratively runs all "ticks" until there are no more.
                                * This can cause infinite recursion if a tick schedules another forever.
                                */

function drainTickQueue() {
  if (drainingTickQueue) {
    return;
  }

  drainingTickQueue = true;

  while (tickQueue.length) {
    var tick = tickQueue.shift();
    tick.run();
  }

  drainingTickQueue = false;
}

function drainQueues() {
  // drain the full tick queue first...
  drainTickQueue(); // tick queue should be empty!

  var immediatesRemaining = processImmediateQueue();

  if (immediatesRemaining !== 0) {
    // re-schedule draining our queues, as we have at least one more "immediate" to handle
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  } else {
    drainQueuesTimeout = null;
  }
}
/**
   * Attempts to process "immediates" (in a much more leisurely way than ticks)
   * We give a 100ms window to run them in before re-scheduling the timeout to process them again.
   * If any ticks are added during invocation of immediate, we drain the tick queue fully before
   * proceeding to next immediate (if we still have time in our window).
   * @returns {number} number of remaining immediates to be processed
   */


function processImmediateQueue() {
  var immediateDeadline = Date.now() + 100; // give us up to 100ms to process immediates

  while (immediateQueue.length && Date.now() < immediateDeadline) {
    var immediate = immediateQueue.shift();
    immediate.run();

    if (tickQueue.length > 0) {
      // they added a tick! drain the tick queue before we do anything else (this *may* eat up our deadline/window to process any more immediates)
      drainTickQueue();
    }
  }

  return immediateQueue.length;
}

process$5.nextTick = function (callback, ...args) {
  assertArgumentType(callback, 'callback', 'function');
  tickQueue.push(new CallbackWithArgs(callback, args));

  if (!drainQueuesTimeout) {
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  }
};

global.setImmediate = function (callback, ...args) {
  assertArgumentType(callback, 'callback', 'function');
  var immediate = new CallbackWithArgs(callback, args);
  immediateQueue.push(immediate);

  if (!drainQueuesTimeout) {
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  }

  return immediate;
};

global.clearImmediate = function (immediate) {
  var index = immediateQueue.indexOf(immediate);

  if (index !== -1) {
    immediateQueue.splice(index, 1);
  }
};

var FORWARD_SLASH = 47; // '/'

var BACKWARD_SLASH = 92; // '\\'

/**
 * Is this [a-zA-Z]?
 * @param  {number}  charCode value from String.charCodeAt()
 * @return {Boolean}          [description]
 */

function isWindowsDeviceName(charCode) {
  return charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122;
}
/**
   * [isAbsolute description]
   * @param  {boolean} isPosix whether this impl is for POSIX or not
   * @param  {string} filepath   input file path
   * @return {Boolean}          [description]
   */


function isAbsolute(isPosix, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  var length = filepath.length; // empty string special case

  if (length === 0) {
    return false;
  }

  var firstChar = filepath.charCodeAt(0);

  if (firstChar === FORWARD_SLASH) {
    return true;
  } // we already did our checks for posix


  if (isPosix) {
    return false;
  } // win32 from here on out


  if (firstChar === BACKWARD_SLASH) {
    return true;
  }

  if (length > 2 && isWindowsDeviceName(firstChar) && filepath.charAt(1) === ':') {
    var thirdChar = filepath.charAt(2);
    return thirdChar === '/' || thirdChar === '\\';
  }

  return false;
}
/**
   * [dirname description]
   * @param  {string} separator  platform-specific file separator
   * @param  {string} filepath   input file path
   * @return {string}            [description]
   */


function dirname(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  var length = filepath.length;

  if (length === 0) {
    return '.';
  } // ignore trailing separator


  var fromIndex = length - 1;
  var hadTrailing = filepath.endsWith(separator);

  if (hadTrailing) {
    fromIndex--;
  }

  var foundIndex = filepath.lastIndexOf(separator, fromIndex); // no separators

  if (foundIndex === -1) {
    // handle special case of root windows paths
    if (length >= 2 && separator === '\\' && filepath.charAt(1) === ':') {
      var firstChar = filepath.charCodeAt(0);

      if (isWindowsDeviceName(firstChar)) {
        return filepath; // it's a root windows path
      }
    }

    return '.';
  } // only found root separator


  if (foundIndex === 0) {
    return separator; // if it was '/', return that
  } // Handle special case of '//something'


  if (foundIndex === 1 && separator === '/' && filepath.charAt(0) === '/') {
    return '//';
  }

  return filepath.slice(0, foundIndex);
}
/**
   * [extname description]
   * @param  {string} separator  platform-specific file separator
   * @param  {string} filepath   input file path
   * @return {string}            [description]
   */


function extname(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  var index = filepath.lastIndexOf('.');

  if (index === -1 || index === 0) {
    return '';
  } // ignore trailing separator


  var endIndex = filepath.length;

  if (filepath.endsWith(separator)) {
    endIndex--;
  }

  return filepath.slice(index, endIndex);
}

function lastIndexWin32Separator(filepath, index) {
  for (var i = index; i >= 0; i--) {
    var char = filepath.charCodeAt(i);

    if (char === BACKWARD_SLASH || char === FORWARD_SLASH) {
      return i;
    }
  }

  return -1;
}
/**
   * [basename description]
   * @param  {string} separator  platform-specific file separator
   * @param  {string} filepath   input file path
   * @param  {string} [ext]      file extension to drop if it exists
   * @return {string}            [description]
   */


function basename(separator, filepath, ext) {
  assertArgumentType(filepath, 'path', 'string');

  if (ext !== undefined) {
    assertArgumentType(ext, 'ext', 'string');
  }

  var length = filepath.length;

  if (length === 0) {
    return '';
  }

  var isPosix = separator === '/';
  var endIndex = length; // drop trailing separator (if there is one)

  var lastCharCode = filepath.charCodeAt(length - 1);

  if (lastCharCode === FORWARD_SLASH || !isPosix && lastCharCode === BACKWARD_SLASH) {
    endIndex--;
  } // Find last occurence of separator


  var lastIndex = -1;

  if (isPosix) {
    lastIndex = filepath.lastIndexOf(separator, endIndex - 1);
  } else {
    // On win32, handle *either* separator!
    lastIndex = lastIndexWin32Separator(filepath, endIndex - 1); // handle special case of root path like 'C:' or 'C:\\'

    if ((lastIndex === 2 || lastIndex === -1) && filepath.charAt(1) === ':' && isWindowsDeviceName(filepath.charCodeAt(0))) {
      return '';
    }
  } // Take from last occurrence of separator to end of string (or beginning to end if not found)


  var base = filepath.slice(lastIndex + 1, endIndex); // drop trailing extension (if specified)

  if (ext === undefined) {
    return base;
  }

  return base.endsWith(ext) ? base.slice(0, base.length - ext.length) : base;
}
/**
   * The `path.normalize()` method normalizes the given path, resolving '..' and '.' segments.
   *
   * When multiple, sequential path segment separation characters are found (e.g.
   * / on POSIX and either \ or / on Windows), they are replaced by a single
   * instance of the platform-specific path segment separator (/ on POSIX and \
   * on Windows). Trailing separators are preserved.
   *
   * If the path is a zero-length string, '.' is returned, representing the
   * current working directory.
   *
   * @param  {string} separator  platform-specific file separator
   * @param  {string} filepath  input file path
   * @return {string} [description]
   */


function normalize$1(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');

  if (filepath.length === 0) {
    return '.';
  } // Windows can handle '/' or '\\' and both should be turned into separator


  var isWindows = separator === '\\';

  if (isWindows) {
    filepath = filepath.replace(/\//g, separator);
  }

  var hadLeading = filepath.startsWith(separator); // On Windows, need to handle UNC paths (\\host-name\\resource\\dir) special to retain leading double backslash

  var isUNC = hadLeading && isWindows && filepath.length > 2 && filepath.charAt(1) === '\\';
  var hadTrailing = filepath.endsWith(separator);
  var parts = filepath.split(separator);
  var result = [];

  for (var segment of parts) {
    if (segment.length !== 0 && segment !== '.') {
      if (segment === '..') {
        result.pop(); // FIXME: What if this goes above root? Should we throw an error?
      } else {
        result.push(segment);
      }
    }
  }

  var normalized = hadLeading ? separator : '';
  normalized += result.join(separator);

  if (hadTrailing) {
    normalized += separator;
  }

  if (isUNC) {
    normalized = '\\' + normalized;
  }

  return normalized;
}
/**
   * [assertSegment description]
   * @param  {*} segment [description]
   * @return {void}         [description]
   */


function assertSegment(segment) {
  if (typeof segment !== 'string') {
    throw new TypeError("Path must be a string. Received ".concat(segment));
  }
}
/**
   * The `path.join()` method joins all given path segments together using the
   * platform-specific separator as a delimiter, then normalizes the resulting path.
   * Zero-length path segments are ignored. If the joined path string is a zero-
   * length string then '.' will be returned, representing the current working directory.
   * @param  {string} separator platform-specific file separator
   * @param  {string[]} paths [description]
   * @return {string}       The joined filepath
   */


function join$1(separator, paths) {
  var result = []; // naive impl: just join all the paths with separator

  for (var segment of paths) {
    assertSegment(segment);

    if (segment.length !== 0) {
      result.push(segment);
    }
  }

  return normalize$1(separator, result.join(separator));
}
/**
   * The `path.resolve()` method resolves a sequence of paths or path segments into an absolute path.
   *
   * @param  {string} separator platform-specific file separator
   * @param  {string[]} paths [description]
   * @return {string}       [description]
   */


function resolve(separator, paths) {
  var resolved = '';
  var hitRoot = false;
  var isPosix = separator === '/'; // go from right to left until we hit absolute path/root

  for (var i = paths.length - 1; i >= 0; i--) {
    var segment = paths[i];
    assertSegment(segment);

    if (segment.length === 0) {
      continue; // skip empty
    }

    resolved = segment + separator + resolved; // prepend new segment

    if (isAbsolute(isPosix, segment)) {
      // have we backed into an absolute path?
      hitRoot = true;
      break;
    }
  } // if we didn't hit root, prepend cwd


  if (!hitRoot) {
    resolved = process.cwd() + separator + resolved;
  }

  var normalized = normalize$1(separator, resolved);

  if (normalized.charAt(normalized.length - 1) === separator) {
    // FIXME: Handle UNC paths on Windows as well, so we don't trim trailing separator on something like '\\\\host-name\\resource\\'
    // Don't remove trailing separator if this is root path on windows!
    if (!isPosix && normalized.length === 3 && normalized.charAt(1) === ':' && isWindowsDeviceName(normalized.charCodeAt(0))) {
      return normalized;
    } // otherwise trim trailing separator


    return normalized.slice(0, normalized.length - 1);
  }

  return normalized;
}
/**
   * The `path.relative()` method returns the relative path `from` from to `to` based
   * on the current working directory. If from and to each resolve to the same
   * path (after calling `path.resolve()` on each), a zero-length string is returned.
   *
   * If a zero-length string is passed as `from` or `to`, the current working directory
   * will be used instead of the zero-length strings.
   *
   * @param  {string} separator platform-specific file separator
   * @param  {string} from [description]
   * @param  {string} to   [description]
   * @return {string}      [description]
   */


function relative(separator, from, to) {
  assertArgumentType(from, 'from', 'string');
  assertArgumentType(to, 'to', 'string');

  if (from === to) {
    return '';
  }

  from = resolve(separator, [from]);
  to = resolve(separator, [to]);

  if (from === to) {
    return '';
  } // we now have two absolute paths,
  // lets "go up" from `from` until we reach common base dir of `to`
  // const originalFrom = from;


  var upCount = 0;
  var remainingPath = '';

  while (true) {
    if (to.startsWith(from)) {
      // match! record rest...?
      remainingPath = to.slice(from.length);
      break;
    } // FIXME: Break/throw if we hit bad edge case of no common root!


    from = dirname(separator, from);
    upCount++;
  } // remove leading separator from remainingPath if there is any


  if (remainingPath.length > 0) {
    remainingPath = remainingPath.slice(1);
  }

  return ('..' + separator).repeat(upCount) + remainingPath;
}
/**
   * The `path.parse()` method returns an object whose properties represent
   * significant elements of the path. Trailing directory separators are ignored,
   * see `path.sep`.
   *
   * The returned object will have the following properties:
   *
   * - dir <string>
   * - root <string>
   * - base <string>
   * - name <string>
   * - ext <string>
   * @param  {string} separator platform-specific file separator
   * @param  {string} filepath [description]
   * @return {object}
   */


function parse(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  var result = {
    root: '',
    dir: '',
    base: '',
    ext: '',
    name: '' };

  var length = filepath.length;

  if (length === 0) {
    return result;
  } // Cheat and just call our other methods for dirname/basename/extname?


  result.base = basename(separator, filepath);
  result.ext = extname(separator, result.base);
  var baseLength = result.base.length;
  result.name = result.base.slice(0, baseLength - result.ext.length);
  var toSubtract = baseLength === 0 ? 0 : baseLength + 1;
  result.dir = filepath.slice(0, filepath.length - toSubtract); // drop trailing separator!

  var firstCharCode = filepath.charCodeAt(0); // both win32 and POSIX return '/' root

  if (firstCharCode === FORWARD_SLASH) {
    result.root = '/';
    return result;
  } // we're done with POSIX...


  if (separator === '/') {
    return result;
  } // for win32...


  if (firstCharCode === BACKWARD_SLASH) {
    // FIXME: Handle UNC paths like '\\\\host-name\\resource\\file_path'
    // need to retain '\\\\host-name\\resource\\' as root in that case!
    result.root = '\\';
    return result;
  } // check for C: style root


  if (length > 1 && isWindowsDeviceName(firstCharCode) && filepath.charAt(1) === ':') {
    if (length > 2) {
      // is it like C:\\?
      var thirdCharCode = filepath.charCodeAt(2);

      if (thirdCharCode === FORWARD_SLASH || thirdCharCode === BACKWARD_SLASH) {
        result.root = filepath.slice(0, 3);
        return result;
      }
    } // nope, just C:, no trailing separator


    result.root = filepath.slice(0, 2);
  }

  return result;
}
/**
   * The `path.format()` method returns a path string from an object. This is the
   * opposite of `path.parse()`.
   *
   * @param  {string} separator platform-specific file separator
   * @param  {object} pathObject object of format returned by `path.parse()`
   * @param  {string} pathObject.dir directory name
   * @param  {string} pathObject.root file root dir, ignored if `pathObject.dir` is provided
   * @param  {string} pathObject.base file basename
   * @param  {string} pathObject.name basename minus extension, ignored if `pathObject.base` exists
   * @param  {string} pathObject.ext file extension, ignored if `pathObject.base` exists
   * @return {string}
   */


function format$1(separator, pathObject) {
  assertArgumentType(pathObject, 'pathObject', 'object');
  var base = pathObject.base || "".concat(pathObject.name || '').concat(pathObject.ext || ''); // append base to root if `dir` wasn't specified, or if
  // dir is the root

  if (!pathObject.dir || pathObject.dir === pathObject.root) {
    return "".concat(pathObject.root || '').concat(base);
  } // combine dir + / + base


  return "".concat(pathObject.dir).concat(separator).concat(base);
}
/**
   * On Windows systems only, returns an equivalent namespace-prefixed path for
   * the given path. If path is not a string, path will be returned without modifications.
   * See https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#namespaces
   * @param  {string} filepath [description]
   * @return {string}          [description]
   */


function toNamespacedPath(filepath) {
  if (typeof filepath !== 'string') {
    return filepath;
  }

  if (filepath.length === 0) {
    return '';
  }

  var resolvedPath = resolve('\\', [filepath]);
  var length = resolvedPath.length;

  if (length < 2) {
    // need '\\\\' or 'C:' minimum
    return filepath;
  }

  var firstCharCode = resolvedPath.charCodeAt(0); // if start with '\\\\', prefix with UNC root, drop the slashes

  if (firstCharCode === BACKWARD_SLASH && resolvedPath.charAt(1) === '\\') {
    // return as-is if it's an aready long path ('\\\\?\\' or '\\\\.\\' prefix)
    if (length >= 3) {
      var thirdChar = resolvedPath.charAt(2);

      if (thirdChar === '?' || thirdChar === '.') {
        return filepath;
      }
    }

    return '\\\\?\\UNC\\' + resolvedPath.slice(2);
  } else if (isWindowsDeviceName(firstCharCode) && resolvedPath.charAt(1) === ':') {
    return '\\\\?\\' + resolvedPath;
  }

  return filepath;
}

var Win32Path = {
  sep: '\\',
  delimiter: ';',
  basename: function (filepath, ext) {
    return basename(this.sep, filepath, ext);
  },
  normalize: function (filepath) {
    return normalize$1(this.sep, filepath);
  },
  join: function (...paths) {
    return join$1(this.sep, paths);
  },
  extname: function (filepath) {
    return extname(this.sep, filepath);
  },
  dirname: function (filepath) {
    return dirname(this.sep, filepath);
  },
  isAbsolute: function (filepath) {
    return isAbsolute(false, filepath);
  },
  relative: function (from, to) {
    return relative(this.sep, from, to);
  },
  resolve: function (...paths) {
    return resolve(this.sep, paths);
  },
  parse: function (filepath) {
    return parse(this.sep, filepath);
  },
  format: function (pathObject) {
    return format$1(this.sep, pathObject);
  },
  toNamespacedPath: toNamespacedPath };

var PosixPath = {
  sep: '/',
  delimiter: ':',
  basename: function (filepath, ext) {
    return basename(this.sep, filepath, ext);
  },
  normalize: function (filepath) {
    return normalize$1(this.sep, filepath);
  },
  join: function (...paths) {
    return join$1(this.sep, paths);
  },
  extname: function (filepath) {
    return extname(this.sep, filepath);
  },
  dirname: function (filepath) {
    return dirname(this.sep, filepath);
  },
  isAbsolute: function (filepath) {
    return isAbsolute(true, filepath);
  },
  relative: function (from, to) {
    return relative(this.sep, from, to);
  },
  resolve: function (...paths) {
    return resolve(this.sep, paths);
  },
  parse: function (filepath) {
    return parse(this.sep, filepath);
  },
  format: function (pathObject) {
    return format$1(this.sep, pathObject);
  },
  toNamespacedPath: function (filepath) {
    return filepath; // no-op
  } };

var path$1 = PosixPath;
path$1.win32 = Win32Path;
path$1.posix = PosixPath;

var isAndroid = Ti.Platform.osname === 'android';
var isIOS = !isAndroid && true;
var PosixConstants = {
  UV_UDP_REUSEADDR: 4,
  dlopen: {},
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18 },

  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12 },

  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20 } };

// default implementations

var OS = {
  EOL: '\n',
  arch: () => process.arch,
  constants: PosixConstants,
  cpus: () => {
    var count = Ti.Platform.processorCount;
    var array = [];

    for (var i = 0; i < count; i++) {
      array.push({
        model: 'unknown',
        speed: 0,
        times: {
          user: 0,
          nice: 0,
          sys: 0,
          idle: 0,
          irq: 0 } });


    }

    return array;
  },
  endianness: () => {
    // TODO: Cache the value!
    var result = Ti.Codec.getNativeByteOrder();

    if (result === Ti.Codec.LITTLE_ENDIAN) {
      return 'LE';
    }

    return 'BE';
  },
  freemem: () => Ti.Platform.availableMemory,
  getPriority: () => 0,
  // fake it
  homedir: () => Ti.Filesystem.applicationDataDirectory,
  // fake it
  hostname: () => Ti.Platform.address,
  // fake it
  loadavg: () => [0, 0, 0],
  // fake it
  networkInterfaces: () => {},
  // FIXME: What do we do here? We might be able to piece some of this together using Ti.Platform.netmask, Ti.Platform.address
  platform: () => process.platform,
  release: () => Ti.Platform.version,
  setPriority: () => {},
  // no-op, fake it

  /**
   * The `os.tmpdir()` method returns a string specifying the operating system's default directory for temporary files.
   * @return {string} [description]
   */
  tmpdir: () => Ti.Filesystem.tempDirectory,

  /**
                                              * The `os.totalmem()` method returns the total amount of system memory in bytes as an integer.
                                              * @return {integer} [description]
                                              */
  totalmem: () => Ti.Platform.totalMemory,
  type: () => 'Unknown',
  // overridden per-platform at bottom

  /**
   * The `os.uptime()` method returns the system uptime in number of seconds.
   * @return {integer} [description]
   */
  uptime: () => Ti.Platform.uptime,
  userInfo: () => {
    // fake it!
    return {
      uid: -1,
      guid: -1,
      username: Ti.Platform.username,
      homedir: Ti.Filesystem.applicationDataDirectory,
      shell: null };

  } };
// On specific platforms, override implementations because we don't have them
// yet and need to fake it, or to hack them
// I'm also doing this in blocks to assign implementations that don't need to consult platform
// type at runtime (hopefully speeding up execution at runtime)

if (isIOS) {
  OS.type = () => 'Darwin'; // Now a giant hack for looking up CPU info for OS.cpus() on iOS
  // https://www.theiphonewiki.com/wiki/List_of_iPhones


  var AppleMap = {
    // iPhone 11 Pro Max
    'iPhone12,5': ['Apple A13 Bionic @ 2.66 GHz', 2660],
    // iPhone 11 Pro
    'iPhone12,3': ['Apple A13 Bionic @ 2.66 GHz', 2660],
    // iPhone 11
    'iPhone12,1': ['Apple A13 Bionic @ 2.66 GHz', 2660],
    // iPhone XR
    'iPhone11,8': ['Apple A12 Bionic @ 2.49 GHz', 2490],
    // iPhone XS Max
    'iPhone11,6': ['Apple A12 Bionic @ 2.49 GHz', 2490],
    'iPhone11,4': ['Apple A12 Bionic @ 2.49 GHz', 2490],
    // iPhone XS
    'iPhone11,2': ['Apple A12 Bionic @ 2.49 GHz', 2490],
    // iPhone X
    'iPhone10,6': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    'iPhone10,3': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    // iPhone 8 Plus
    'iPhone10,5': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    'iPhone10,2': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    // iPhone 8
    'iPhone10,4': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    'iPhone10,1': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    // iPhone 7 Plus
    'iPhone9,4': ['Apple A10 Fusion @ 2.34 GHz', 2340],
    'iPhone9,2': ['Apple A10 Fusion @ 2.34 GHz', 2340],
    // iPhone 7
    'iPhone9,3': ['Apple A10 Fusion @ 2.34 GHz', 2340],
    'iPhone9,1': ['Apple A10 Fusion @ 2.34 GHz', 2340],
    // iPhone SE
    'iPhone8,4': ['Apple A9 Twister @ 1.85 GHz', 1850],
    // iPhone 6s Plus
    'iPhone8,2': ['Apple A9 Twister @ 1.85 GHz', 1850],
    // iPhone 6s
    'iPhone8,1': ['Apple A9 Twister @ 1.85 GHz', 1850],
    // iPhone 6 Plus
    'iPhone7,1': ['Apple A8 Typhoon @ 1.38 GHz', 1380],
    // iPhone 6
    'iPhone7,2': ['Apple A8 Typhoon @ 1.38 GHz', 1380],
    // iPhone 5s
    'iPhone6,2': ['Apple A7 Cyclone @ 1.3 GHz', 1300],
    'iPhone6,1': ['Apple A7 Cyclone @ 1.3 GHz', 1300],
    // iPhone 5c
    'iPhone5,4': ['Apple A6 Swift @ 1.2 GHz', 1200],
    'iPhone5,3': ['Apple A6 Swift @ 1.2 GHz', 1200],
    // iPhone 5
    'iPhone5,1': ['Apple A6 Swift @ 1.2 GHz', 1200],
    'iPhone5,2': ['Apple A6 Swift @ 1.2 GHz', 1200],
    // iPhone 4s
    'iPhone4,1': ['Apple A5 @ 800 MHz', 800],
    // iPhone 4
    'iPhone3,3': ['Apple A4 @ 800 MHz', 800],
    'iPhone3,2': ['Apple A4 @ 800 MHz', 800],
    'iPhone3,1': ['Apple A4 @ 800 MHz', 800],
    // iPhone 3GS
    'iPhone2,1': ['Samsung S5L8920 @ 620 MHz', 620],
    // iPhone 3G
    'iPhone1,2': ['Samsung S5L8900 @ 412 MHz', 412],
    // iPhone
    'iPhone1,1': ['Samsung S5L8900 @ 412 MHz', 412],
    // ////// iPads
    // https://www.theiphonewiki.com/wiki/List_of_iPads
    // https://en.wikipedia.org/wiki/IPad
    // iPad Pro (12.9" 3rd gen)
    'iPad8,8': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,7': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,6': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,5': ['Apple A12X @ 2.49 GHz', 2490],
    // iPad Pro (11")
    'iPad8,4': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,3': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,2': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,1': ['Apple A12X @ 2.49 GHz', 2490],
    // iPad (6th gen)
    'iPad7,6': ['Apple A10 @ 2.31 GHz', 2310],
    // FIXME: Wikipedia says 2.34 GHz
    'iPad7,5': ['Apple A10 @ 2.31 GHz', 2310],
    // iPad Pro (10.5")
    'iPad7,4': ['Apple A10X @ 2.38 GHz', 2380],
    'iPad7,3': ['Apple A10X @ 2.38 GHz', 2380],
    // iPad Pro (12.9" 2nd gen)
    'iPad7,2': ['Apple A10X @ 2.38 GHz', 2380],
    'iPad7,1': ['Apple A10X @ 2.38 GHz', 2380],
    // iPad (5th gen)
    'iPad6,12': ['Apple A9 @ 1.85 GHz', 1850],
    'iPad6,11': ['Apple A9 @ 1.85 GHz', 1850],
    // iPad Pro (12.9" 1st gen)
    'iPad6,8': ['Apple A9X @ 2.24 GHz', 2240],
    'iPad6,7': ['Apple A9X @ 2.24 GHz', 2240],
    // iPad Pro (9.7")
    'iPad6,4': ['Apple A9X @ 2.16 GHz', 2160],
    'iPad6,3': ['Apple A9X @ 2.16 GHz', 2160],
    // iPad Air 2
    'iPad5,4': ['Apple A8X @ 1.5 GHz', 1500],
    'iPad5,3': ['Apple A8X @ 1.5 GHz', 1500],
    // iPad Mini 4
    'iPad5,2': ['Apple A8 @ 1.49 GHz', 1490],
    'iPad5,1': ['Apple A8 @ 1.49 GHz', 1490],
    // iPad Mini 3
    'iPad4,9': ['Apple A7 @ 1.3 GHz', 1300],
    'iPad4,8': ['Apple A7 @ 1.3 GHz', 1300],
    'iPad4,7': ['Apple A7 @ 1.3 GHz', 1300],
    // iPad Mini 2
    'iPad4,6': ['Apple A7 @ 1.3 GHz', 1300],
    'iPad4,5': ['Apple A7 @ 1.3 GHz', 1300],
    'iPad4,4': ['Apple A7 @ 1.3 GHz', 1300],
    // iPad Air 2
    'iPad4,3': ['Apple A7 Rev A @ 1.4 GHz', 1400],
    'iPad4,2': ['Apple A7 Rev A @ 1.4 GHz', 1400],
    'iPad4,1': ['Apple A7 Rev A @ 1.4 GHz', 1400],
    // iPad (4th gen)
    'iPad3,6': ['Apple A6X @ 1.4 GHz', 1400],
    'iPad3,5': ['Apple A6X @ 1.4 GHz', 1400],
    'iPad3,4': ['Apple A6X @ 1.4 GHz', 1400],
    // iPad (3rd gen)
    'iPad3,3': ['Apple A5X @ 1 GHz', 1000],
    'iPad3,2': ['Apple A5X @ 1 GHz', 1000],
    'iPad3,1': ['Apple A5X @ 1 GHz', 1000],
    // iPad Mini
    'iPad2,7': ['Apple A5 Rev A @ 1 GHz', 1000],
    'iPad2,6': ['Apple A5 Rev A @ 1 GHz', 1000],
    'iPad2,5': ['Apple A5 Rev A @ 1 GHz', 1000],
    // iPad 2
    'iPad2,4': ['Apple A5 @ 1 GHz', 1000],
    'iPad2,3': ['Apple A5 @ 1 GHz', 1000],
    'iPad2,2': ['Apple A5 @ 1 GHz', 1000],
    'iPad2,1': ['Apple A5 @ 1 GHz', 1000],
    // iPad
    'iPad1,1': ['Apple A4 @ 1 GHz', 1000] };

  /**
                                              * [cpuModel description]
                                              * @param  {string} model [description]
                                              * @return {array}       [description]
                                              */

  var cpuModelAndSpeed = model => {
    var trimmed = model.replace(' (Simulator)', '').trim();
    return AppleMap[trimmed] || ['Unknown', 0];
  }; // override cpus impl


  OS.cpus = () => {
    // TODO: Cache the result!
    var count = Ti.Platform.processorCount;
    var modelAndSpeed = cpuModelAndSpeed(Ti.Platform.model);
    var array = [];

    for (var i = 0; i < count; i++) {
      array.push({
        model: modelAndSpeed[0],
        speed: modelAndSpeed[1],
        times: {} });

    }

    return array;
  };
} else if (isAndroid) {
  OS.cpus = () => Ti.Platform.cpus();

  OS.type = () => 'Linux';
}

var tty = {
  isatty: () => false,
  ReadStream: () => {
    throw new Error('tty.ReadStream is not implemented');
  },
  WriteStream: () => {
    throw new Error('tty.WriteStream is not implemented');
  } };


var MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
var util = {
  format,
  formatWithOptions,
  inspect,
  isArray: Array.isArray,
  isBoolean: value => typeof value === 'boolean',
  isBuffer: BufferModule.Buffer.isBuffer,
  isFunction: value => typeof value === 'function',
  isNull: value => value === null,
  isNullOrUndefined: value => value === undefined || value === null,
  isNumber: value => typeof value === 'number',
  isObject: value => value !== null && typeof value === 'object',
  isPrimitive: value => typeof value !== 'object' && typeof value !== 'function' || value === null,
  isString: value => typeof value === 'string',
  isSymbol: value => typeof value === 'symbol',
  isUndefined: value => value === undefined,
  isRegExp: isRegExp,
  isDate: isDate,
  isError: e => Object.prototype.toString.call(e) === '[object Error]' || e instanceof Error,
  log: string => {
    var date = new Date();
    var time = "".concat(date.getHours().toString().padStart(2, '0'), ":").concat(date.getMinutes().toString().padStart(2, '0'), ":").concat(date.getSeconds().toString().padStart(2, '0')); // Produces output like: "21 Feb 10:04:23 - message"

    console.log("".concat(date.getDate(), " ").concat(MONTHS[date.getMonth()], " ").concat(time, " - ").concat(string));
  },
  print: (...args) => console.log(args.join('')),
  // FIXME: Shouldn't add trailing newline like console.log does!
  puts: (...args) => console.log(args.join('\n')),
  error: (...args) => console.error(args.join('\n')),
  debug: string => console.error("DEBUG: ".concat(string)),
  types };

/**
            * @param {Function} constructor subclass
            * @param {Function} superConstructor base class
            * @returns {void}
            */

util.inherits = function (constructor, superConstructor) {
  assertArgumentType(constructor, 'constructor', 'Function');
  assertArgumentType(superConstructor, 'superConstructor', 'Function');
  assertArgumentType(superConstructor.prototype, 'superConstructor.prototype', 'Object');
  Object.defineProperty(constructor, 'super_', {
    value: superConstructor });

  Object.setPrototypeOf(constructor.prototype, superConstructor.prototype);
};
/**
    * @param {Function} original original function to wrap which is expected to have a final callback argument
    * @returns {Function} function that returns a Promise
    */


util.promisify = function (original) {
  assertArgumentType(original, 'original', 'Function');

  function wrapped(...args) {
    return new Promise((resolve, reject) => {
      original.call(this, ...args, (err, result) => {
        if (err) {
          return reject(err);
        }

        return resolve(result);
      });
    });
  } // TODO: Copy properties from original to wrapped
  // TODO: hook prototype chain up from wrapped to original
  // TODO: Support custom promisify hooks


  return wrapped;
};
/**
    * @param {Function} original original function to convert from async/Promise return value to a callback style
    * @returns {Function} wrapped function
    */


util.callbackify = function (original) {
  assertArgumentType(original, 'original', 'Function');

  function wrapped(...args) {
    var callback = args.pop();
    var promise = original.apply(this, args);
    promise.then(result => {
      // eslint-disable-line promise/always-return
      callback(null, result); // eslint-disable-line promise/no-callback-in-promise
    }).catch(err => {
      if (!err) {
        var wrappedError = new Error('Promise was rejected with falsy value');
        wrappedError.reason = err;
        err = wrappedError;
      }

      callback(err); // eslint-disable-line promise/no-callback-in-promise
    });
  }

  return wrapped;
};
/**
    * @param {Function} func function to deprecate/wrap
    * @param {string} string message to give when deprecation warning is emitted
    * @param {string} code deprecation code to use to group warnings
    * @returns {Function} wrapped function
    */


util.deprecate = function (func, string, code) {
  // eslint-disable-line no-unused-vars
  if (process.noDeprecation) {
    return func; // skip the wrapping!
  } // TODO: Support `code` argument by tracking a map of codes we've warned about


  function wrapped(...args) {
    var warned = false;

    if (!warned) {
      process.emitWarning(string, 'DeprecationWarning');
      warned = true;
    }

    return func.apply(this, args);
  }

  return wrapped;
}; // TODO: Support debuglog? What is our equivalent of process.env('NODE_DEBUG')?


var noop = () => {};

util.debuglog = () => {
  return noop;
};

var DEFAULT_MESSAGES = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:' };
// Fake enums to use internally

var COMPARE_TYPE = {
  Object: 0,
  Map: 1,
  Set: 2 };

var STRICTNESS = {
  Strict: 0,
  Loose: 1 };


class AssertionError extends Error {
  constructor(options) {
    var {
      actual,
      expected,
      message,
      operator } =
    options;

    if (!message) {
      // FIXME: Generate the rest of the message with diff of actual/expected!
      message = "".concat(DEFAULT_MESSAGES[operator], "\n\n");
    }

    super(message);
    this.actual = actual;
    this.expected = expected;
    this.operator = operator;
    this.generatedMessage = !message;
    this.name = 'AssertionError [ERR_ASSERTION]';
    this.code = 'ERR_ASSERTION';
  }}

// TODO: Can we define AssertStrict and AssertLoose as subclasses of a base Assert class
// that class holds impls for shared methods, subclasses override specific
// comparisons used (Object.is vs ===)?


var assert$1 = (value, message) => assert$1.ok(value, message);

assert$1.AssertionError = AssertionError;

assert$1.ok = (...args) => {
  var value = args[0];

  if (value) {
    return;
  }

  var message = args[1];
  var generatedMessage = false; // Check if value (1st arg) was not supplied!
  // Have to use ugly hack on args definition to do so

  if (args.length === 0) {
    message = 'No value argument passed to `assert.ok()`';
    generatedMessage = true;
  } else if (message == null) {
    // eslint-disable-line no-eq-null,eqeqeq
    // TODO: generate rest of the message. Node actually reads the input file! The hacked browserify does not do this
    // It treates ok failing like `value == true` failing
    message = 'The expression evaluated to a falsy value:\n\n';
    generatedMessage = true;
  } else if (message instanceof Error) {
    throw message;
  }

  var err = new AssertionError({
    actual: value,
    expected: true,
    message,
    operator: '==' });

  err.generatedMessage = generatedMessage;
  throw err;
};

function throwError(obj) {
  // If message is an Error object, throw that instead!
  if (obj.message instanceof Error) {
    throw obj.message;
  }

  throw new AssertionError(obj);
}

assert$1.equal = (actual, expected, message) => {
  if (actual == expected) {
    // eslint-disable-line eqeqeq
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'equal' });

};

assert$1.strictEqual = (actual, expected, message) => {
  if (Object.is(actual, expected)) {
    // provides SameValue comparison for us
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'strictEqual' });

};

assert$1.notEqual = (actual, expected, message) => {
  if (actual != expected) {
    // eslint-disable-line eqeqeq
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'notEqual' });

};

assert$1.notStrictEqual = (actual, expected, message) => {
  if (!Object.is(actual, expected)) {
    // provides SameValue comparison for us
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'notStrictEqual' });

};

var isPrimitive = value => {
  return typeof value !== 'object' && typeof value !== 'function' || value === null;
};
/**
    * @param {Map} actual map we are comparing
    * @param {Map} expected map we're comparing against
    * @param {STRICTNESS.Loose|strictness.Strict} strictness how to compare
    * @param {object} references memoized references to objects in the deepEqual hierarchy
    * @returns {boolean}
    */


function compareMaps(actual, expected, strictness, references) {
  var looseChecks = new Set(); // keep track of objects we need to test more extensively than using #get()/#has()

  for (var [key, value] of actual) {
    if (typeof key === 'object' && key !== null) {
      // non-null object. We need to do our own checking, not use get()/has()
      looseChecks.add(key);
    } else {
      // handle "primitives"
      if (expected.has(key) && deepEqual(value, expected.get(key), strictness, references)) {
        // yay! a nice easy match - both key and value matched exactly - move on
        continue;
      }

      if (strictness === STRICTNESS.Strict) {
        // if we didn't match key/value perfectly in strict mode, fail right away
        return false;
      } // ok, so it didn't match key/value perfectly - but we're in loose mode, so fall back to try again


      looseChecks.add(key);
    }
  }

  if (looseChecks.size === 0) {
    // no loose ends to tie up, everything matched
    return true;
  } // only go through the second Map once!


  for (var [expectedKey, expectedValue] of expected) {
    // if it's not a non-null object in strict mode, fail!
    // (i.e. if it's a primitive that failed a match, don't fall back to more loosely match it)
    // Note that this shouldn't ever happen since we should be returning false immediately above
    if (strictness === STRICTNESS.Strict && !(typeof expectedKey === 'object' && expectedKey !== null)) {
      return false;
    } // otherwise, test it // TODO: Wish we could use #find() like on an Array, but Set doesn't have it!


    var found = false;

    for (var _key of looseChecks) {
      // if both key and value matches
      if (deepEqual(_key, expectedKey, strictness, references) && deepEqual(actual.get(_key), expectedValue, strictness, references)) {
        found = true;
        looseChecks.delete(_key); // remove from our looseChecks Set since we already matched it

        break;
      }
    } // if not found, we failed to match


    if (!found) {
      return false;
    }
  } // did we leave un-matched keys? if so, fail


  return looseChecks.size === 0;
}
/**
   * @param {Set} actual map we are comparing
   * @param {Set} expected map we're comparing against
   * @param {strictness.Loose|strictness.Strict} strictness how to compare
   * @param {object} references memoized references to objects in the deepEqual hierarchy
   * @returns {boolean}
   */


function compareSets(actual, expected, strictness, references) {
  var looseChecks = new Set(); // keep track of values we need to test more extensively than using #has()

  for (var value of actual) {
    if (typeof value === 'object' && value !== null) {
      // non-null object. We need to do our own checking, not use has()
      looseChecks.add(value);
    } else if (!expected.has(value)) {
      // FIXME: has does "same-value-zero" check, which is like Object.is except for -0/+0 being considered equal
      // so may need to special case that here, that'd have to be in an else below (since has will return true here)
      if (strictness === STRICTNESS.Strict) {
        // failed "same-value" match for primitive in strict mode, so fail right away
        return false;
      } // When doing loose check, we need to fall back to looser check than #has(), so we can't just return false immediately here
      // add to set of values to check more thoroughly


      looseChecks.add(value);
    }
  }

  if (looseChecks.size === 0) {
    // no loose ends to tie up, everything matched
    return true;
  } // Try to whittle down the loose checks set to be empty...
  // only go through the second Set once!


  for (var expectedValue of expected) {
    // if it's not a non-null object in strict mode, fail!
    // (i.e. if it's a primitive that failed a match, don't fall back to more loosely match it)
    // Note that this shouldn't ever happen since we should be returning false immediately above
    if (strictness === STRICTNESS.Strict && !(typeof expectedValue === 'object' && expectedValue !== null)) {
      return false;
    }

    var found = false;

    for (var object of looseChecks) {
      if (deepEqual(object, expectedValue, strictness, references)) {
        found = true; // found a match!

        looseChecks.delete(object); // remove from our looseChecks Set since we matched it

        break;
      }
    } // if not found, we failed to match


    if (!found) {
      return false;
    }
  } // did we leave un-matched values? if so, fail


  return looseChecks.size === 0;
}
/**
   * @param {*} actual value we are comparing
   * @param {*} expected values we're comparing against
   * @param {STRICTNESS.Strict|STRICTNESS.Loose} strictness how strict a comparison to do
   * @param {object} [references] optional object to keep track of circular references in the hierarchy
   * @param {Map<object,number>} [references.actual] mapping from objects visited (on `actual`) to their depth
   * @param {Map<object,number>} [references.expected] mapping from objects visited (on `expected`) to their depth
   * @param {number} [references.depth] The current depth of the hierarchy
   * @returns {boolean}
   */


function deepEqual(actual, expected, strictness, references) {
  // if primitives, compare using Object.is
  // This handles: null, undefined, number, string, boolean
  if (isPrimitive(actual) && isPrimitive(expected)) {
    if (strictness === STRICTNESS.Strict) {
      return Object.is(actual, expected);
    } else {
      return actual == expected; // eslint-disable-line eqeqeq
    }
  } // Now we have various objects/functions:
  // Date, Error, RegExp, Array, Map, Set, Object, Function, Arrow functions, WeakMap, DataView, ArrayBuffer, WeakSet, typed arrays
  // notably, this includes "boxed" primitives created by new Boolean(false), new String('value'), Symbol('whatever'), etc
  // Type tags of objects should be the same


  var actualTag = Object.prototype.toString.call(actual);
  var expectedTag = Object.prototype.toString.call(expected);

  if (actualTag !== expectedTag) {
    return false;
  } // [[Prototype]] of objects are compared using the Strict Equality Comparison.


  if (strictness === STRICTNESS.Strict) {
    // don't check prototype when doing "loose"
    var actualPrototype = Object.getPrototypeOf(actual);
    var expectedPrototype = Object.getPrototypeOf(expected);

    if (actualPrototype !== expectedPrototype) {
      return false;
    }
  }

  var comparison = COMPARE_TYPE.Object;

  if (util.types.isRegExp(actual)) {
    // RegExp source and flags should match
    if (!util.types.isRegExp(expected) || actual.flags !== expected.flags || actual.source !== expected.source) {
      return false;
    } // continue on to check properties...

  } else if (util.types.isDate(actual)) {
    // Date's underlying time should match
    if (!util.types.isDate(expected) || actual.getTime() !== expected.getTime()) {
      return false;
    } // continue on to check properties...

  } else if (actual instanceof Error) {
    // Error's name and message must match
    if (!(expected instanceof Error) || actual.name !== expected.name || actual.message !== expected.message) {
      return false;
    } // continue on to check properties...

  } else if (Array.isArray(actual)) {
    // if array lengths differ, quick fail
    if (!Array.isArray(expected) || actual.length !== expected.length) {
      return false;
    } // continue on to check properties...

  } else if (util.types.isBoxedPrimitive(actual)) {
    if (!util.types.isBoxedPrimitive(expected)) {
      return false;
    } // check that they're the same type of wrapped primitive and then call the relevant valueOf() for that type to compare them!


    if (util.types.isNumberObject(actual) && (!util.types.isNumberObject(expected) || !Object.is(Number.prototype.valueOf.call(actual), Number.prototype.valueOf.call(expected)))) {
      return false;
    } else if (util.types.isStringObject(actual) && (!util.types.isStringObject(expected) || String.prototype.valueOf.call(actual) !== String.prototype.valueOf.call(expected))) {
      return false;
    } else if (util.types.isBooleanObject(actual) && (!util.types.isBooleanObject(expected) || Boolean.prototype.valueOf.call(actual) !== Boolean.prototype.valueOf.call(expected))) {
      return false; // FIXME: Uncomment when we support BigInt cross-platform!
      // } else if (util.types.isBigIntObject(actual)
      // 	&& (!util.types.isBigIntObject(expected)
      // 		|| BigInt.prototype.valueOf.call(actual) !== BigInt.prototype.valueOf.call(expected))) {
      // 	return false;
    } else if (util.types.isSymbolObject(actual) && (!util.types.isSymbolObject(expected) || Symbol.prototype.valueOf.call(actual) !== Symbol.prototype.valueOf.call(expected))) {
      return false;
    } // continue on to check properties...

  } else if (util.types.isSet(actual)) {
    if (!util.types.isSet(expected) || actual.size !== expected.size) {
      return false;
    }

    comparison = COMPARE_TYPE.Set; // continue on to check properties...
  } else if (util.types.isMap(actual)) {
    if (!util.types.isMap(expected) || actual.size !== expected.size) {
      return false;
    }

    comparison = COMPARE_TYPE.Map; // continue on to check properties...
  } // Now iterate over properties and compare them!


  var actualKeys = Object.keys(actual); // for an array, this will return the indices that have values

  var expectedKeys = Object.keys(expected); // and it just magically works
  // Must have same number of properties

  if (actualKeys.length !== expectedKeys.length) {
    return false;
  } // Are they the same keys? If one is missing, then no, fail right away


  if (!actualKeys.every(key => Object.prototype.hasOwnProperty.call(expected, key))) {
    return false;
  } // Don't check own symbols when doing "loose"


  if (strictness === STRICTNESS.Strict) {
    var actualSymbols = Object.getOwnPropertySymbols(actual);
    var expectedSymbols = Object.getOwnPropertySymbols(expected); // Must have same number of symbols

    if (actualSymbols.length !== expectedSymbols.length) {
      return false;
    }

    if (actualSymbols.length > 0) {
      // Have to filter them down to enumerable symbols!
      for (var key of actualSymbols) {
        var actualIsEnumerable = Object.prototype.propertyIsEnumerable.call(actual, key);
        var expectedIsEnumerable = Object.prototype.propertyIsEnumerable.call(expected, key);

        if (actualIsEnumerable !== expectedIsEnumerable) {
          return false; // they differ on whetehr symbol is enumerable, fail!
        } else if (actualIsEnumerable) {
          // it's enumerable, add to keys to check
          actualKeys.push(key);
          expectedKeys.push(key);
        }
      }
    }
  } // Avoid circular references!
  // Record map from objects to depth in the hierarchy


  if (references === undefined) {
    references = {
      actual: new Map(),
      expected: new Map(),
      depth: 0 };

  } else {
    // see if we've already recorded these objects.
    // if so, make sure they refer to same depth in object hierarchy
    var memoizedActual = references.actual.get(actual);

    if (memoizedActual !== undefined) {
      var memoizedExpected = references.expected.get(expected);

      if (memoizedExpected !== undefined) {
        return memoizedActual === memoizedExpected;
      }
    }

    references.depth++;
  } // store the object -> depth mapping


  references.actual.set(actual, references.depth);
  references.expected.set(expected, references.depth); // When comparing Maps/Sets, compare elements before custom properties

  var result = true;

  if (comparison === COMPARE_TYPE.Set) {
    result = compareSets(actual, expected, strictness, references);
  } else if (comparison === COMPARE_TYPE.Map) {
    result = compareMaps(actual, expected, strictness, references);
  }

  if (result) {
    // Now loop over keys and compare them to each other!
    for (var _key2 of actualKeys) {
      if (!deepEqual(actual[_key2], expected[_key2], strictness, references)) {
        result = false;
        break;
      }
    }
  } // wipe the object to depth mapping for these objects now


  references.actual.delete(actual);
  references.expected.delete(expected);
  return result;
}

assert$1.deepStrictEqual = (actual, expected, message) => {
  if (!deepEqual(actual, expected, STRICTNESS.Strict)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'deepStrictEqual' });

  }
};

assert$1.notDeepStrictEqual = (actual, expected, message) => {
  if (deepEqual(actual, expected, STRICTNESS.Strict)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'notDeepStrictEqual' });

  }
};

assert$1.deepEqual = (actual, expected, message) => {
  if (!deepEqual(actual, expected, STRICTNESS.Loose)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'deepEqual' });

  }
};

assert$1.notDeepEqual = (actual, expected, message) => {
  if (deepEqual(actual, expected, STRICTNESS.Loose)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'notDeepEqual' });

  }
};

assert$1.fail = (message = 'Failed') => throwError({
  message });


var NO_EXCEPTION = {};

function execute(fn) {
  assertArgumentType(fn, 'fn', 'Function');

  try {
    fn();
  } catch (e) {
    return e;
  }

  return NO_EXCEPTION;
}

function isPromiseLike(fn) {
  return util.types.isPromise(fn) || fn && typeof fn === 'object' && typeof fn.then === 'function';
}

function executePromise(_x) {
  return _executePromise.apply(this, arguments);
}

function _executePromise() {
  _executePromise = _asyncToGenerator(function* (fn) {
    var promise;
    var fnType = typeof fn;

    if (fnType === 'function') {
      promise = fn();

      if (!isPromiseLike(promise)) {
        throw new TypeError("Expected instanceof Promise to be returned from the \"fn\" function but got ".concat(typeof promise));
      }
    } else {
      if (!isPromiseLike(fn)) {
        throw new TypeError("The \"fn\" argument must be of type Function or Promise. Received type ".concat(fnType));
      }

      promise = fn;
    }

    try {
      yield promise;
    } catch (e) {
      return e;
    }

    return NO_EXCEPTION;
  });
  return _executePromise.apply(this, arguments);
}

assert$1.throws = (fn, error, message) => {
  var actual = execute(fn);

  if (actual === NO_EXCEPTION) {
    // FIXME: append message if not null
    throwError({
      actual: undefined,
      expected: error,
      message: 'Missing expected exception.',
      operator: 'throws' });

    return;
  } // They didn't specify how to validate, so just roll with it


  if (!error) {
    return;
  }

  if (!checkError(actual, error, message)) {
    throw actual; // throw the Error it did generate
  }
};

assert$1.rejects =
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(function* (asyncFn, error, message) {
    var actual = yield executePromise(asyncFn);

    if (actual === NO_EXCEPTION) {
      // FIXME: append message if not null
      throwError({
        actual: undefined,
        expected: error,
        message: 'Missing expected exception.',
        operator: 'rejects' });

      return;
    } // They didn't specify how to validate, so just roll with it


    if (!error) {
      return;
    }

    if (!checkError(actual, error, message)) {
      throw actual; // throw the Error it did generate
    }
  });

  return function (_x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();

assert$1.doesNotThrow = (fn, error, message) => {
  var actual = execute(fn); // no Error, just return

  if (actual === NO_EXCEPTION) {
    return;
  } // They didn't specify how to validate, so just re-throw


  if (!error) {
    throw actual;
  } // If error matches expected, throw an AssertionError


  if (checkError(actual, error)) {
    throwError({
      actual,
      expected: error,
      operator: 'doesNotThrow',
      message: "Got unwanted exception".concat(message ? ': ' + message : '.') });

    return;
  } // doesn't match, re-throw


  throw actual;
};

assert$1.doesNotReject =
/*#__PURE__*/
function () {
  var _ref2 = _asyncToGenerator(function* (fn, error, message) {
    var actual = yield executePromise(fn); // no Error, just return

    if (actual === NO_EXCEPTION) {
      return;
    } // They didn't specify how to validate, so just re-throw


    if (!error) {
      throw actual;
    } // If error matches expected, throw an AssertionError


    if (checkError(actual, error)) {
      throwError({
        actual,
        expected: error,
        operator: 'doesNotThrow',
        message: "Got unwanted exception".concat(message ? ': ' + message : '.') });

      return;
    } // doesn't match, re-throw


    throw actual;
  });

  return function (_x5, _x6, _x7) {
    return _ref2.apply(this, arguments);
  };
}();
/**
      * @param {Error} actual the actual Error generated by the wrapped function/block
      * @param {object|RegExp|Function|Error|Class} expected The value to test against the Error
      * @param {string} [message] custom message to append
      * @returns {boolean} true if the Error matches the expected value/object
      */


function checkError(actual, expected, message) {
  // What we do here depends on what `expected` is:
  // function - call it to validate
  // object - test properties against actual
  // Regexp - test against actual.toString()
  // Error type - check type matches
  // Error instance - compare properties
  if (typeof expected === 'object') {
    if (util.types.isRegExp(expected)) {
      return expected.test(actual); // does the error match the RegExp expression? if so, pass
    } // Test properties (`expected` is either a generic Object or an Error instance)


    var keys = Object.keys(expected); // If we're testing against an instance of an Error, we need to hack in name/message properties.

    if (expected instanceof Error) {
      keys.unshift('name', 'message'); // we want to compare name and message, but they're not set as enumerable on Error
    }

    for (var key of keys) {
      if (!deepEqual(actual[key], expected[key], STRICTNESS.Strict)) {
        if (!message) {
          // generate a meaningful message! Cheat by treating like equality check of values
          // then steal the message it generated
          try {
            throwError({
              actual: actual[key],
              expected: expected[key],
              operator: 'deepStrictEqual' });

          } catch (err) {
            message = err.message;
          }
        }

        throwError({
          actual,
          expected,
          message,
          operator: 'throws' });

        return false;
      }
    }

    return true; // They all matched, pass!
  } else if (typeof expected === 'function') {
    // if `expected` is a "type" and actual is an instance of that type, then pass
    if (expected.prototype != null && actual instanceof expected) {
      // eslint-disable-line no-eq-null,eqeqeq
      return true;
    } // If `expected` is a subclass of Error but `actual` wasn't an instance of it (above), fail


    if (Object.prototype.isPrototypeOf.call(Error, expected)) {
      return false;
    } // ok, let's assume what's left is that `expected` was a validation function,
    // so call it with empty `this` and single argument of the actual error we received


    return expected.call({}, actual);
  }

  return false;
}

assert$1.ifError = value => {
  if (value === null || value === undefined) {
    return;
  }

  throwError({
    actual: value,
    expected: null,
    message: "ifError got unwanted exception: ".concat(value),
    operator: 'ifError' });

}; // Create "strict" copy which overrides "loose" methods to call strict equivalents


assert$1.strict = (value, message) => assert$1.ok(value, message); // "Copy" methods from assert to assert.strict!


Object.assign(assert$1.strict, assert$1); // Override the "loose" methods to point to the strict ones

assert$1.strict.deepEqual = assert$1.deepStrictEqual;
assert$1.strict.notDeepEqual = assert$1.notDeepStrictEqual;
assert$1.strict.equal = assert$1.strictEqual;
assert$1.strict.notEqual = assert$1.notStrictEqual; // hang strict off itself

assert$1.strict.strict = assert$1.strict;

/**
                                           * @param {string} [encoding='utf8'] The character encoding the `StringDecoder` will use.
                                           */
function StringDecoder(encoding = 'utf8') {
  this.encoding = encoding.toLowerCase();

  switch (this.encoding) {
    case 'utf8':
    case 'utf-8':
      this._impl = new Utf8StringDecoder();
      break;

    case 'ucs2':
    case 'ucs-2':
    case 'utf16-le':
    case 'utf16le':
      this._impl = new Utf16StringDecoder();
      break;

    case 'base64':
      this._impl = new Base64StringDecoder();
      break;

    default:
      this._impl = new StringDecoderImpl(this.encoding);
      break;}

}
/**
   * Returns any remaining input stored in the internal buffer as a string.
   * Bytes representing incomplete UTF-8 and UTF-16 characters will be replaced with substitution
   * characters appropriate for the character encoding.
   *
   * If the buffer argument is provided, one final call to stringDecoder.write() is performed before returning the remaining input.
   * @param {Buffer} [buffer] containing the bytes to decode.
   * @returns {string}
   */


StringDecoder.prototype.end = function end(buffer) {
  return this._impl.end(buffer);
};
/**
    * Returns a decoded string, ensuring that any incomplete multibyte characters at the end of the Buffer, or
    * TypedArray, or DataView are omitted from the returned string and stored in an internal buffer for the
    * next call to stringDecoder.write() or stringDecoder.end().
    * @param {Buffer|TypedArray|DataView} buffer containing the bytes to decode.
    * @returns {string}
    */


StringDecoder.prototype.write = function write(buffer) {
  if (typeof buffer === 'string') {
    return buffer;
  } // empty string for empty buffer


  if (buffer.length === 0) {
    return '';
  }

  return this._impl.write(buffer);
};
/**
    * This is the base class. We override parts of it for certain encodings. For ascii/hex/binary/latin1 the impl is super-easy
    */


class StringDecoderImpl {
  constructor(encoding = 'utf8') {
    this.encoding = encoding;
    this.byteCount = 0;
    this.charLength = 1;
  } // the actual underlying implementation!


  end(buffer) {
    if (buffer && buffer.length !== 0) {
      return this.write(buffer);
    }

    return '';
  }

  write(buffer) {
    if (buffer && buffer.length !== 0) {
      return buffer.toString(this.encoding); // single byte character encodings are a cinch
    }

    return ''; // no buffer, or empty
  }}

// For multi-byte encodings, let's implement some base logic...


class MultiByteStringDecoderImpl extends StringDecoderImpl {
  constructor(encoding, bytesPerChar) {
    super(encoding);
    this.incomplete = Buffer.allocUnsafe(bytesPerChar); // temporary incomplete character buffer
  }
  /**
     * @typedef {Object} IncompleteCharObject
     * @property {integer} bytesNeeded bytes missing to complete the character
     * @property {integer} charLength bytes expected to complete the character
     * @property {integer} index location in the buffer where the character starts
     */

  /**
         * Given a Buffer, sees if we have an incomplete "character" at the end of it.
         * Returns info on that:
         * - bytesNeeded: 0-3, number of bytes still remaining
         * - charLength: expected number of bytes for the incomplete character
         * - index: index in the buffer where the incomplete character begins
         * @param {Buffer} _buffer Buffer we are checking to see if it has an incompelte "character" at the end
         * @returns {IncompleteCharObject}
         */


  _checkIncompleteBytes(_buffer) {
    throw new Error('subclasses must override!');
  }

  _incompleteEnd() {
    throw new Error('subclasses must override!');
  }

  _incompleteBufferEmptied() {
    // typically we reset byte count back to 0 and character length to 1
    this.byteCount = 0;
    this.charLength = 1;
  }

  end(buffer) {
    var result = super.end(buffer);

    if (this.byteCount !== 0) {
      // we have incomplete characters!
      result += this._incompleteEnd();
    }

    this._incompleteBufferEmptied(); // reset our internals to "wipe" the incomplete buffer


    return result;
  }

  write(buffer) {
    // first let's see if we had some multi-byte character we didn't finish...
    var char = '';

    if (this.byteCount !== 0) {
      // we still needed some bytes to finish the character
      // How many bytes do we still need? charLength - bytes we received
      var left = this.charLength - this.byteCount; // need 4, have 1? then we have 3 "left"

      var bytesCopied = Math.min(left, buffer.length); // copy up to that many bytes
      // copy bytes from `buffer` to our incomplete buffer

      buffer.copy(this.incomplete, this.byteCount, 0, bytesCopied);
      this.byteCount += bytesCopied; // record how many more bytes we copied...

      if (bytesCopied < left) {
        // still need more bytes to complete!
        return '';
      } // we were able to complete, yay!
      // grab the character we completed


      char = this.incomplete.slice(0, this.charLength).toString(this.encoding); // reset our counters

      this._incompleteBufferEmptied(); // do we have any bytes left in this buffer?


      if (bytesCopied === buffer.length) {
        return char; // if not, return the character we finished!
      } // we still have more bytes, so slice the buffer up


      buffer = buffer.slice(bytesCopied, buffer.length);
    } // check this buffer to see if it indicates we need more bytes?


    var incompleteCharData = this._checkIncompleteBytes(buffer);

    if (incompleteCharData.bytesNeeded === 0) {
      return char + buffer.toString(this.encoding); // no incomplete bytes, return any character we completed plus the buffer
    } // ok so the buffer holds an incomplete character at it's end


    this.charLength = incompleteCharData.charLength; // record how many bytes we need for the 'character'

    var incompleteCharIndex = incompleteCharData.index; // this is the index of the multibyte character that is incomplete
    // copy from index of incomplete character to end of buffer

    var bytesToCopy = buffer.length - incompleteCharIndex;
    buffer.copy(this.incomplete, 0, incompleteCharIndex, buffer.length);
    this.byteCount = bytesToCopy; // record how many bytes we actually copied

    if (bytesToCopy < buffer.length) {
      // buffer had bytes before the incomplete character
      // so smush any character we may have completed with any complete characters in the buffer
      return char + buffer.toString(this.encoding, 0, incompleteCharIndex);
    }

    return char; // any now-completed character that was previously incomplete, possibly empty
  }}



class Utf8StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('utf8', 4);
  }

  _checkIncompleteBytes(buffer) {
    var length = buffer.length; // FIXME: In Node, they check the last character first!
    // And they rely on Buffer#toString() to handle injecting the '\ufffd' character for busted multi-byte sequences!
    // iOS apparently just returns undefined in that special case and
    // Android differs here because we don't work backwards from the last char
    // Can we cheat here and...
    // see https://github.com/nodejs/string_decoder/blob/master/lib/string_decoder.js#L173-L198
    // - if we see a multi-byte character start, validate the next characters are continuation chars
    // - if they're not replace the sequence with '\ufffd', treat like that multi-byte character was "completed"
    // Note that even if we do hack this, if there's some invalid multi-byte UTF-8 in the buffer that isn't at the last 3 bytes
    // then we're at the mercy of the JS engine/platform code for handling that
    // Here's someone's hack there: https://gist.github.com/oleganza/997155
    // if buffer.length >= 3, check 3rd to last byte

    if (length >= 3) {
      var charLength = checkCharLengthForUTF8(buffer[length - 3]);

      if (charLength === 4) {
        return {
          bytesNeeded: 1,
          // we have 3 last bytes, need 4th
          index: length - 3,
          charLength: 4 };

      }
    } // if buffer.length >= 2, check 2nd to last byte


    if (length >= 2) {
      var _charLength = checkCharLengthForUTF8(buffer[length - 2]);

      if (_charLength >= 3) {
        return {
          bytesNeeded: _charLength - 2,
          // we have 2 bytes of whatever we need
          index: length - 2,
          charLength: _charLength };

      }
    } // if buffer.length >= 1, check last byte


    if (length >= 1) {
      var _charLength2 = checkCharLengthForUTF8(buffer[length - 1]);

      if (_charLength2 >= 2) {
        return {
          bytesNeeded: _charLength2 - 1,
          // we have 1 byte of whatever we need
          index: length - 1,
          charLength: _charLength2 };

      }
    } // base case, no bytes needed - ends on complete character


    return {
      bytesNeeded: 0,
      index: length - 1,
      charLength: 1 };

  }

  _incompleteEnd() {
    return '\ufffd'; // we replace the missing character with a special utf8 char
  }}



class Utf16StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('utf16le', 4);
  }

  _checkIncompleteBytes(buffer) {
    var length = buffer.length;
    var modulo = length % 2; // ok, we have a multiple of 2 bytes

    if (modulo === 0) {
      // is the last byte a leading/high surrogate?
      var byte = buffer[buffer.length - 1];

      if (byte >= 0xD8 && byte <= 0xDB) {
        return {
          bytesNeeded: 2,
          charLength: 4,
          index: length - 2 };

      } // we're good, not a surrogate, so we have our needed 2 bytes


      return {
        bytesNeeded: 0,
        charLength: 2 };

    } // ok we have 1 byte left over, assume we need 2 to form the character


    return {
      bytesNeeded: 1,
      index: length - 1,
      charLength: 2 };

  }

  _incompleteEnd() {
    // Just write out the last N bytes, hopefully the engine can handle it for us?
    return this.incomplete.toString('utf16le', 0, this.byteCount);
  }}



class Base64StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('base64', 3);
    this.charLength = 3; // always 3!
  }

  _checkIncompleteBytes(buffer) {
    var length = buffer.length;
    var modulo = length % 3; // base64 needs 3 bytes always, so if we have that many (or a multiple), we have a complete buffer

    if (modulo === 0) {
      return {
        bytesNeeded: 0,
        charLength: 3 };

    } // ok we have 1 or 2 bytes left over


    return {
      bytesNeeded: 3 - modulo,
      // always need 3, so if we have 1 left over -> need 2
      index: length - modulo,
      charLength: 3 // always need 3
    };

  }

  _incompleteBufferEmptied() {
    this.byteCount = 0;
    this.charLength = 3; // always 3!
  }

  _incompleteEnd() {
    // Just write out the last N bytes, it should insert the '=' placeholders
    // it's not really 'missing'/'incomplete', just needs placeholder insertion
    return this.incomplete.toString('base64', 0, this.byteCount);
  }}



function checkCharLengthForUTF8(byte) {
  // 11110XXX => 1110 => 0x1E
  if (byte >> 3 === 0x1E) {
    return 4;
  } // 1110XXXX => 1110 => 0x1E


  if (byte >> 4 === 0x0E) {
    return 3;
  } // 110XXXXX => 110 => 0x06


  if (byte >> 5 === 0x06) {
    return 2;
  }

  return 1;
}

var StringDecoder$1 = {
  StringDecoder };


var isAndroid$1 = Ti.Platform.name === 'android'; // Keep track of printing out one-time warning messages for unsupported operations/options/arguments

var printedWarnings = {};

function oneTimeWarning(key, msg) {
  if (!printedWarnings[key]) {
    console.warn(msg);
    printedWarnings[key] = true;
  }
}
/**
   * Prints a one-time warning message that we do not support the given API and performs an effective no-op
   * @param {string} moduleName name of the module/object
   * @param {string} name name of the function.property we don't support
   * @returns {Function} no-op function
   */


function unsupportedNoop(moduleName, name) {
  return () => {
    var fqn = "".concat(moduleName, ".").concat(name);
    oneTimeWarning(fqn, "\"".concat(fqn, "\" is not supported yet on Titanium and uses a no-op fallback."));
    return undefined;
  };
}
/**
   * @param {string} moduleName name of the module/object
   * @param {string} name name of the function.property we don't support
   * @param {Function} callback async callback we call in a quick setTimeout
   */


function asyncUnsupportedNoop(moduleName, name, callback) {
  callback = maybeCallback(callback); // enforce we have a valid callback

  unsupportedNoop(moduleName, name)();
  setTimeout(callback, 1);
} // Used to choose the buffer/chunk size when pumping bytes during copies


var COPY_FILE_CHUNK_SIZE = 8092; // what should we use here?
// Keep track of integer -> FileStream mappings

var fileDescriptors = new Map();
var fileDescriptorCount = 4; // global counter used to report file descriptor integers
// Map file system access flags to Ti.Filesystem.MODE_* constants

var FLAGS_TO_TI_MODE = new Map();
FLAGS_TO_TI_MODE.set('a', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('ax', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('a+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('ax+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('as+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('r', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('r+', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('rs+', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('w', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('wx', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('w+', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('wx+', Ti.Filesystem.MODE_WRITE); // Common errors

var permissionDenied = (syscall, path) => makeError('EACCES', 'permission denied', -13, syscall, path);

var noSuchFile = (syscall, path) => makeError('ENOENT', 'no such file or directory', -2, syscall, path);

var fileAlreadyExists = (syscall, path) => makeError('EEXIST', 'file already exists', -17, syscall, path);

var notADirectory = (syscall, path) => makeError('ENOTDIR', 'not a directory', -20, syscall, path);

var directoryNotEmpty = (syscall, path) => makeError('ENOTEMPTY', 'directory not empty', -66, syscall, path);

var illegalOperationOnADirectory = (syscall, path) => makeError('EISDIR', 'illegal operation on a directory', -21, syscall, path);

var fs = {
  constants: {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 512,
    O_EXCL: 2048,
    O_NOCTTY: 131072,
    O_TRUNC: 1024,
    O_APPEND: 8,
    O_DIRECTORY: 1048576,
    O_NOFOLLOW: 256,
    O_SYNC: 128,
    O_DSYNC: 4194304,
    O_SYMLINK: 2097152,
    O_NONBLOCK: 4,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_COPYFILE_EXCL: 1,
    COPYFILE_EXCL: 1 } };



class Stats {
  constructor(path) {
    this._file = null;
    this.dev = 0;
    this.ino = 0;
    this.mode = 0;
    this.nlink = 0;
    this.uid = 0;
    this.gid = 0;
    this.rdev = 0;
    this.size = 0;
    this.blksize = 4096; // FIXME: https://stackoverflow.com/questions/1315311/what-is-the-block-size-of-the-iphone-filesystem

    this.blocks = 0;
    this.atimeMs = this.mtimeMs = this.ctimeMs = this.birthtimeMs = 0;
    this.atime = this.mtime = this.ctime = this.birthtime = new Date(0);

    if (path) {
      this._file = getTiFileFromPathLikeValue(path); // TODO: use lazy getters here?

      this.ctime = this.birthtime = this._file.createdAt();
      this.atime = this.mtime = this._file.modifiedAt();
      this.atimeMs = this.atime.getTime();
      this.birthtimeMs = this.birthtime.getTime();
      this.ctimeMs = this.ctime.getTime();
      this.mtimeMs = this.mtime.getTime();
      this.size = this._file.size;
      this.blocks = Math.ceil(this.size / this.blksize); // TODO: Can we fake out the mode based on the readonly/writable/executable properties?
    }
  }

  isFile() {
    return this._file.isFile();
  }

  isDirectory() {
    return this._file.isDirectory();
  }

  isBlockDevice() {
    return false;
  }

  isCharacterDevice() {
    return false;
  }

  isSymbolicLink() {
    return this._file.symbolicLink;
  }

  isFIFO() {
    return false;
  }

  isSocket() {
    return false;
  }}



fs.Stats = Stats;

class ReadStream {}

fs.ReadStream = ReadStream;

class WriteStream {}

fs.WriteStream = WriteStream;
/**
                               * @callback statsCallback
                               * @param {Error} err - Error if one occurred
                               * @param {fs.Stats} stats - file stats
                               */

/**
                                   * @param {string|URL|Buffer} path file path
                                   * @param {integer} [mode=fs.constants.F_OK] accessibility mode/check
                                   * @param {function} callback async callback
                                   */

fs.access = function (path, mode, callback) {
  if (typeof mode === 'function') {
    callback = mode;
    mode = fs.constants.F_OK;
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.accessSync(path, mode);
    } catch (e) {
      callback(e);
      return;
    }

    callback();
  }, 1);
};
/**
    * @param {string|URL|Buffer} path file path
    * @param {integer} [mode=fs.constants.F_OK] accessibility mode/check
    */


fs.accessSync = function (path, mode = fs.constants.F_OK) {
  // F_OK is just whether file exists or not, no permissions check
  // R_OK is read check
  // W_OK is write check
  // X_OK is execute check (acts like F_OK on Windows)
  var fileHandle = getTiFileFromPathLikeValue(path);

  if (!fileHandle.exists()) {
    throw noSuchFile('access', path);
  } // TODO: We have no means of testing if a file is readable. It's assumed all files that exist under the app are?


  if (mode & fs.constants.W_OK && !fileHandle.writable) {
    throw permissionDenied('access', path);
  }

  if (mode & fs.constants.X_OK && !fileHandle.executable && fileHandle.isFile()) {
    throw permissionDenied('access', path);
  }
};
/**
    * Asynchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer.
    * @param {string|Buffer|URL|FileStream} file filepath to file
    * @param {string|Buffer} data data to append to file
    * @param {object|string} [options] options
    * @param {string} [options.encoding='utf8'] encoding to use
    * @param {integer} [options.mode=0o666] mode to create file, if not created
    * @param {string} [options.flag='a'] file system flag
    * @param {Function} callback function to call back with error if failed
    */


fs.appendFile = (file, data, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'a' });

  fs.writeFile(file, data, options, callback);
};
/**
    * Synchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer.
    * @param {string|Buffer|URL|FileStream} file filepath to file
    * @param {string|Buffer} data data to append to file
    * @param {object|string} [options] options
    * @param {string} [options.encoding='utf8'] encoding to use
    * @param {integer} [options.mode=0o666] mode to create file, if not created
    * @param {string} [options.flag='a'] file system flag
    */


fs.appendFileSync = (file, data, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'a' });

  fs.writeFileSync(file, data, options); // TODO: Use Ti.Filesystem.File.append() instead?
};

fs.chmod = (path, mode, callback) => asyncUnsupportedNoop('fs', 'chmod', callback);

fs.chmodSync = unsupportedNoop('fs', 'chmodSync');
/**
                                                    * Callback for functions that can only throw errors
                                                    *
                                                    * @callback errorCallback
                                                    * @param {Error} [err] - Error thrown
                                                    */

/**
                                                        * @param {integer} fd file descriptor
                                                        * @param {errorCallback} callback callback function
                                                        */

fs.close = (fd, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.closeSync(fd);
    } catch (e) {
      callback(e);
      return;
    }

    callback();
  }, 1);
};
/**
    * @param {integer} fd file descriptor
    */


fs.closeSync = fd => {
  var stream = streamForDescriptor(fd);
  stream.close();
}; // Rather than use a hack to wrap sync version in setTimeout, use actual async APIs!

/**
 * @param {string|Buffer|URL} src source filename to copy
 * @param {string|Buffer|URL} dest destination filename of the copy operation
 * @param {number} [flags=0] modifiers for copy operation
 * @param {errorCallback} callback callback called at end of operation
 */


fs.copyFile = function (src, dest, flags, callback) {
  if (typeof flags === 'function') {
    callback = flags;
    flags = 0;
  }

  callback = maybeCallback(callback); // FIXME: I don't know why, but changing this to use Ti.Filesystem.openStream(mode, path) fails (at least on iOS)

  var srcFile = Ti.Filesystem.getFile(src);
  var srcStream = srcFile.open(Ti.Filesystem.MODE_READ);
  var destFile = Ti.Filesystem.getFile(dest);
  var destStream = destFile.open(Ti.Filesystem.MODE_WRITE);
  pipe(srcStream, destStream, callback);
};
/**
    * @param {string|Buffer|URL} src source filename to copy
    * @param {string|Buffer|URL} dest destination filename of the copy operation
    * @param {number} [flags=0] modifiers for copy operation
    */


fs.copyFileSync = function (src, dest, flags = 0) {
  var srcFile = Ti.Filesystem.getFile(src);

  if (flags === fs.constants.COPYFILE_EXCL && fs.existsSync(dest)) {
    throw fileAlreadyExists('copyFile', dest);
  }

  if (!srcFile.copy(dest)) {
    throw new Error("Unable to copy ".concat(src, " to ").concat(dest)); // FIXME: What error should we give?
  }
}; // TODO: fs.createReadStream(path, options)
// /**
//  * @param {string|Buffer|URL} path path like
//  * @param {string|object} [options] options, if a string, it's the encoding
//  * @param {string} [options.flags='r'] See support of file system flags.
//  * @param {string} [options.encoding=null] encoding
//  * @param {integer} [options.fd=null] file descriptor, if specified, `path` is ignored
//  * @param {integer} [options.mode=0o666] permissions to set if file is created
//  * @param {boolean} [options.autoClose=true] if false, file descriptor will not be closed; if true even on error it will be closed
//  * @param {integer} [options.start] start index of range of bytes to read from file
//  * @param {integer} [options.end=Infinity] end index of range of bytes to read from file
//  * @param {integer} [options.highWaterMark=64 * 1024]
//  * @returns {fs.ReadStream}
//  */
// fs.createReadStream = (path, options) => {
// 	options = mergeDefaultOptions(options, { flags: 'r', encoding: null, fd: null, mode: 0o666, autoClose: true, end: Infinity, highWaterMark: 64 * 1024 });
// 	// FIXME: If options.fd, use that in place of path!
// 	const tiFile = getTiFileFromPathLikeValue(path);
// };
// TODO: fs.createWriteStream(path, options)

/**
 * @callback existsCallback
 * @param {boolean} exists - whether path exists
 */

/**
     * @param {string} path path to check
     * @param {existsCallback} callback callback function
     * @returns {void}
     */


fs.exists = function (path, callback) {
  callback = maybeCallback(callback);
  setTimeout(() => {
    callback(fs.existsSync(path));
  }, 1);
};
/**
    * @param {string} path path to check
    * @returns {boolean} whether a file or directory exists at that path
    */


fs.existsSync = function (path) {
  try {
    fs.accessSync(path);
    return true;
  } catch (e) {
    return false;
  }
};

fs.fchmod = (fd, mode, callback) => asyncUnsupportedNoop('fs', 'fchmod', callback);

fs.fchmodSync = unsupportedNoop('fs', 'fchmodSync');

fs.fchown = (fd, uid, gid, callback) => asyncUnsupportedNoop('fs', 'fchown', callback);

fs.fchownSync = unsupportedNoop('fs', 'fchownSync');

fs.fdatasync = (fd, callback) => asyncUnsupportedNoop('fs', 'fdatasync', callback);

fs.fdatasyncSync = unsupportedNoop('fs', 'fdatasyncSync');
/**
                                                            * @param {integer} fd file descriptor
                                                            * @param {object} [options] options
                                                            * @param {boolean} [options.bigint] whether stat values should be bigint
                                                            * @param {function} callback async callback function
                                                            */

fs.fstat = (fd, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    var stats;

    try {
      stats = fs.fstatSync(fd, options);
    } catch (e) {
      callback(e);
      return;
    }

    callback(null, stats);
  }, 1);
};
/**
    * @param {integer} fd file descriptor
    * @param {object} [_options] options
    * @param {boolean} [_options.bigint] whether stat values should be bigint
    * @returns {fs.Stats} stats for file descriptor
    */


fs.fstatSync = (fd, _options) => {
  var path = pathForFileDescriptor(fd);
  return fs.statSync(path);
}; // TODO: Add versions of these APIs:
// fs.fsync(fd, callback)
// fs.fsyncSync(fd)
// fs.ftruncate(fd[, len], callback)
// fs.ftruncateSync(fd[, len])
// fs.futimes(fd, atime, mtime, callback)
// fs.futimesSync(fd, atime, mtime)
// fs.lchmod(path, mode, callback)
// fs.lchmodSync(path, mode)
// fs.lchown(path, uid, gid, callback)
// fs.lchownSync(path, uid, gid)
// fs.link(existingPath, newPath, callback)
// fs.linkSync(existingPath, newPath)
// FIXME: If symbolic link we need to follow link to target to get stats! Our API doesn't support that!


fs.lstat = (path, options, callback) => fs.stat(path, options, callback);

fs.lstatSync = (path, options) => fs.statSync(path, options);
/**
                                                               * @param {string|Buffer|URL} path file path
                                                               * @param {string|object} [options] options
                                                               * @param {boolean} [options.recursive=false] recursivley create dirs?
                                                               * @param {integer} [options.mode=0o777] permissions
                                                               * @param {errorCallback} callback async callback
                                                               */


fs.mkdir = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {
      recursive: false,
      mode: 0o777 };

  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.mkdirSync(path, options);
    } catch (e) {
      callback(e);
      return;
    }

    callback(null);
  }, 1);
};
/**
    * @param {string|Buffer|URL} path file path
    * @param {string|object} [options] options
    * @param {boolean} [options.recursive=false] recursivley create dirs?
    * @param {integer} [options.mode=0o777] permissions
    */


fs.mkdirSync = (path, options) => {
  var tiFile = getTiFileFromPathLikeValue(path);

  if (typeof options === 'number') {
    options = {
      recursive: false,
      mode: options };

  } else {
    options = mergeDefaultOptions(options, {
      recursive: false,
      mode: 0o777 });

  }

  if (!tiFile.createDirectory(options.recursive) && !options.recursive) {
    if (tiFile.exists()) {
      // already existed!
      throw fileAlreadyExists('mkdir', path);
    } // We failed, probably because we didn't ask for recursive and parent doesn't exist, so reproduce node's error


    throw noSuchFile('mkdir', path);
  }
};
/**
    * @callback tempDirCallback
    * @param {Error} err - Error if one occurred
    * @param {string} folder - generated folder name
    */

/**
        * @param {string} prefix directory name prefix
        * @param {string|object} [options] options
        * @param {string} [options.encoding='utf-8'] prefix encoding
        * @param {tempDirCallback} callback async callback
        */


fs.mkdtemp = (prefix, options, callback) => {
  assertArgumentType(prefix, 'prefix', 'string');

  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  callback = maybeCallback(callback);
  options = mergeDefaultOptions(options, {
    encoding: 'utf-8' });
  // try to be all async

  var tryMkdtemp = () => {
    var generated = randomCharacters(6, options.encoding); // generate six random characters

    var path = "".concat(prefix).concat(generated);
    fs.mkdir(path, 0o700, err => {
      if (err) {
        if (err.code === 'EEXIST') {
          // retry!
          setTimeout(tryMkdtemp, 1);
          return;
        } // bubble up error


        callback(err);
        return;
      } // succeeded! Hurray!


      callback(null, path);
    });
  };

  setTimeout(tryMkdtemp, 1);
};
/**
    * Creates a unique temporary directory.
    * @param {string} prefix directory name prefix
    * @param {string|object} [options] options
    * @param {string} [options.encoding='utf-8'] prefix encoding
    * @returns {string} path to created directory
    */


fs.mkdtempSync = (prefix, options) => {
  assertArgumentType(prefix, 'prefix', 'string');
  options = mergeDefaultOptions(options, {
    encoding: 'utf-8' });

  var retryCount = 0;
  var MAX_RETRIES = 100;

  while (retryCount < MAX_RETRIES) {
    var generated = randomCharacters(6, options.encoding); // generate six random characters

    var _path = "".concat(prefix).concat(generated);

    try {
      fs.mkdirSync(_path, 0o700); // don't try recursive

      return _path;
    } catch (e) {
      if (e.code !== 'EEXIST') {
        throw e; // bubble up error
      } // name was not unique, so retry


      retryCount++;
    }
  }

  throw new Error("Failed to create a unique directory name with prefix ".concat(prefix));
};
/**
    * @callback fileDescriptorCallback
    * @param {Error} err - Error if one occurred
    * @param {integer} fileDescriptor - generated file descriptor
    */

/**
        * @param {string|Buffer|URL} path path to file
        * @param {string} [flags='r'] file system access flags
        * @param {integer} [mode=0o666] file mode to use when creating file
        * @param {fileDescriptorCallback} callback async callback
        */


fs.open = (path, flags, mode, callback) => {
  // flags and mode are optional, we need to handle if not supplied!
  if (typeof flags === 'function') {
    callback = flags;
    flags = 'r';
    mode = 0o666;
  } else if (typeof mode === 'function') {
    callback = mode;
    mode = 0o666;
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    var fileDescriptor;

    try {
      fileDescriptor = fs.openSync(path, flags, mode);
    } catch (e) {
      callback(e);
      return;
    }

    callback(null, fileDescriptor);
  }, 1);
};
/**
    * @param {string|Buffer|URL} path path to file
    * @param {string} [flags='r'] file system access flags
    * @param {integer} [_mode=0o666] file mode to use when creating file
    * @returns {integer}
    */


fs.openSync = (path, flags = 'r', _mode = 0o666) => {
  var tiFile = getTiFileFromPathLikeValue(path);

  if (!tiFile.exists()) {
    // TODO: Support creating file with specific mode
    oneTimeWarning('fs.openSync.mode', 'fs.openSync\'s mode parameter is unsupported in Titanium and will be ignored');

    if (!tiFile.createFile()) {
      // Oh crap, we failed to create the file. why?
      if (!tiFile.parent.exists()) {
        // parent does not exist!
        throw noSuchFile('open', path);
      }

      throw new Error("failed to create file at path ".concat(path));
    }
  } else if (flags) {
    // file/dir exists...
    if ((flags.charAt(0) === 'w' || flags.charAt(0) === 'a') && tiFile.isDirectory()) {
      // If user is trying to write or append and it's a directory, fail
      throw illegalOperationOnADirectory('open', path);
    }

    if (flags.length > 1 && flags.charAt(1) === 'x') {
      // If user has "exclusive" flag on, fail if file already exists
      throw fileAlreadyExists('open', path);
    }
  }

  var tiMode = FLAGS_TO_TI_MODE.get(flags);

  if (tiMode === undefined) {
    // TODO: Make use of common error type/code for this once we have internal/errors.js
    var err = new TypeError("The value \"".concat(String(flags), "\" is invalid for option \"flags\""));
    err.code = 'ERR_INVALID_OPT_VALUE';
    throw err;
  }

  return createFileDescriptor(path, tiFile.open(tiMode));
};
/**
    * @callback readCallback
    * @param {Error} err - Error if one occurred
    * @param {integer} bytesRead - number of bytes read
    * @param {Buffer} buffer buffer
    */

/**
        * @param {integer} fd file descriptor
        * @param {Buffer|Ti.Buffer} buffer buffer to read into
        * @param {integer} offset the offset in the buffer to start writing at.
        * @param {integer} length integer specifying the number of bytes to read.
        * @param {integer} position where to begin reading from in the file
        * @param {readCallback} callback async callback
        */


fs.read = (fd, buffer, offset, length, position, callback) => {
  callback = maybeCallback(callback);
  var tiFileStream = streamForDescriptor(fd);

  if (!Buffer.isBuffer(buffer)) {
    buffer = Buffer.from(buffer);
  } // FIXME: Allow using position argument!


  if (position !== null) {
    oneTimeWarning('fs.readSync.position', 'fs.readSync\'s position argument is unsupported by Titanium and will be treated as null');
  }

  tiFileStream.read(buffer.toTiBuffer(), offset, length, readObj => {
    if (!readObj.success) {
      callback(new Error(readObj.error));
      return;
    }

    callback(null, readObj.bytesProcessed, buffer);
  });
};
/**
    * @param {integer} fd file descriptor
    * @param {Buffer|Ti.Buffer} buffer buffer to read into
    * @param {integer} offset the offset in the buffer to start writing at.
    * @param {integer} length integer specifying the number of bytes to read.
    * @param {integer} _position where to begin reading from in the file
    * @returns {integer} bytes read
    */


fs.readSync = (fd, buffer, offset, length, _position) => {
  var fileStream = streamForDescriptor(fd);

  if (!Buffer.isBuffer(buffer)) {
    buffer = Buffer.from(buffer);
  } // FIXME: Allow using position argument!


  if (_position !== null) {
    oneTimeWarning('fs.readSync.position', 'fs.readSync\'s position argument is unsupported by Titanium and will be treated as null');
  }

  return fileStream.read(buffer.toTiBuffer(), offset, length);
};
/**
    * @callback filesCallback
    * @param {Error} err - Error if one occurred
    * @param {string[]|Buffer[]|fs.Dirent[]} files - file listing
    */

/**
        * @param {string} path directory to list
        * @param {string|object} [options] optional options
        * @param {string} [options.encoding='utf8'] encoding to use for filenames, if `'buffer'`, returns `Buffer` objects
        * @param {boolean} [options.withFileTypes=false] if true, returns `fs.Dirent` objects
        * @param {filesCallback} callback async callback
        */


fs.readdir = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    var result;

    try {
      result = fs.readdirSync(path, options);
    } catch (e) {
      callback(e);
      return;
    }

    callback(null, result);
  }, 1);
};
/**
    * @param {string} filepath directory to list
    * @param {string|object} [options] optional options
    * @param {string} [options.encoding='utf8'] encoding to use for filenames, if `'buffer'`, returns `Buffer` objects
    * @param {boolean} [options.withFileTypes=false] if true, returns `fs.Dirent` objects
    * @returns {string[]|Buffer[]|fs.Dirent[]}
    */


fs.readdirSync = (filepath, options) => {
  var file = getTiFileFromPathLikeValue(filepath);

  if (!file.exists()) {
    throw noSuchFile('scandir', filepath);
  }

  if (!file.isDirectory()) {
    throw notADirectory('scandir', filepath);
  }

  options = mergeDefaultOptions(options, {
    encoding: 'utf-8',
    withFileTypes: false });

  var listing = file.getDirectoryListing();

  if (options.withFileTypes === true) {
    // TODO: if options.withFileTypes === true, return fs.Dirent objects
    oneTimeWarning('fs.readdir\'s options.withFileTypes is unsupported by Titanium and strings will be returned');
  } else if (options.encoding === 'buffer') {
    return listing.map(name => Buffer.from(name));
  }

  return listing;
};
/**
    * @callback readFilePostOpenCallback
    * @param {Error} err - Error if one occurred
    * @param {Ti.Buffer} buffer
    */

/**
        * @param {integer} fileDescriptor file descriptor
        * @param {readFilePostOpenCallback} callback async callback
        */


function readFilePostOpen(fileDescriptor, callback) {
  callback = maybeCallback(callback);
  fs.fstat(fileDescriptor, (err, stats) => {
    if (err) {
      callback(err);
      return;
    }

    var fileSize = stats.size; // Create a Ti.Buffer to read into

    var buffer = Ti.createBuffer({
      length: fileSize });
    // Use Ti.Stream.readAll(sourceStream, buffer, callback) which spins off a separate thread to read in while loop!

    var sourceStream = streamForDescriptor(fileDescriptor);
    Ti.Stream.readAll(sourceStream, buffer, readAllObj => {
      if (!readAllObj.success) {
        callback(new Error(readAllObj.error));
        return;
      }

      callback(null, buffer);
    });
  });
}
/**
   * @callback readFileCallback
   * @param {Error} err - Error if one occurred
   * @param {string|Buffer} data
   */

/**
       * Asynchronously read entire contents of file
       * @param {string|Buffer|URL|integer} path filename or file descriptor
       * @param {object|string} [options] options
       * @param {string} [options.encoding=null] encoding to use
       * @param {string} [options.flag='r'] file system flag
       * @param {readFileCallback} callback async callback
       */


fs.readFile = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {
      encoding: null,
      flag: 'r' };

  } else {
    options = mergeDefaultOptions(options, {
      encoding: null,
      flag: 'r' });

  }

  callback = maybeCallback(callback);
  var wasFileDescriptor = typeof path === 'number';
  var fileDescriptor = path; // may be overriden later

  /**
   * @param {Error} err possible Error
   * @param {Ti.Buffer} buffer Ti.Buffer instance
   */

  var handleBuffer = (err, buffer) => {
    if (err) {
      callback(err);
      return;
    } // fs.closeSync if it was not originally a file descriptor


    if (!wasFileDescriptor) {
      fs.closeSync(fileDescriptor);
    } // TODO: trim buffer if we didn't read full size?


    callback(null, encodeBuffer(options.encoding, buffer));
  };

  if (!wasFileDescriptor) {
    fs.open(path, options.flag, (err, fd) => {
      if (err) {
        callback(err);
        return;
      }

      fileDescriptor = fd;
      readFilePostOpen(fd, handleBuffer);
    });
  } else {
    readFilePostOpen(path, handleBuffer);
  }
};
/**
    * Returns the contents of the path.
    * @param {string|Buffer|URL|integer} path path to file
    * @param {object|string} [options] options
    * @param {string} [options.encoding=null] encoding to use
    * @param {string} [options.flag='r'] file system flag
    * @returns {string|Buffer} string if encoding is specified, otherwise Buffer
    */


fs.readFileSync = (path, options) => {
  options = mergeDefaultOptions(options, {
    encoding: null,
    flag: 'r' });

  var wasFileDescriptor = typeof path === 'number';
  var fileDescriptor = wasFileDescriptor ? path : fs.openSync(path, options.flag); // use default mode

  var tiFileStream = streamForDescriptor(fileDescriptor); // Just use our own API that reads full stream in

  var buffer = Ti.Stream.readAll(tiFileStream); // fs.closeSync if it was not originally a file descriptor

  if (!wasFileDescriptor) {
    fs.closeSync(fileDescriptor);
  } // TODO: trim buffer if we didn't read full size?


  return encodeBuffer(options.encoding, buffer);
}; // TODO: fs.readlink(path[, options], callback)
// TODO: fs.readlinkSync(path[, options])

/**
 * @callback realpathCallback
 * @param {Error} err - Error if one occurred
 * @param {string|Buffer} resolvedPath the resolved path
 */

/**
     * @param {string|Buffer|URL} filepath original filepath
     * @param {object} [options] optiosn object
     * @param {string} [options.encoding='utf8'] encoding used for returned object. If 'buffer", we'll return a Buffer in palce of a string
     * @param {realpathCallback} callback async callback
     */


fs.realpath = (filepath, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8' });

  setTimeout(() => {
    // FIXME: This assumes no symlinks, which we really don't have full support for in our SDK anyways.
    var result = path$1.normalize(filepath);
    fs.exists(result, resultExists => {
      if (resultExists) {
        if (options.encoding === 'buffer') {
          return callback(null, Buffer.from(result));
        }

        return callback(null, result);
      } // this path doesn't exist, try each segment until we find first that doesn't


      var segments = result.split(path$1.sep); // FIXME: Drop last segment as we already know the full path doesn't exist?

      var partialFilePath = '';
      var index = 0; // handle typical case of empty first segment so we don't need to do an async setTimeout to get to first real case

      if (segments[index].length === 0) {
        index++;
      }

      setTimeout(tryPath, 1);

      function tryPath() {
        if (index >= segments.length) {
          // don't run past end of segments, throw error for resolved path
          return callback(noSuchFile(result));
        } // grab next segment


        var segment = segments[index++];

        if (segment.length === 0) {
          // if it's an empty segment...
          // try again at next index
          return setTimeout(tryPath, 1);
        } // normal case


        partialFilePath += path$1.sep + segment; // check if path up to this point exists...

        fs.exists(partialFilePath, partialExists => {
          if (!partialExists) {
            // nope, throw the Error
            return callback(noSuchFile('lstat', partialFilePath));
          } // try again at next depth of dir tree


          setTimeout(tryPath, 1);
        });
      }
    });
  }, 1);
};

fs.realpath.native = (path, options, callback) => {
  fs.realpath(path, options, callback);
};
/**
    * @param {string|Buffer|URL} filepath original filepath
    * @param {object} [options] options object
    * @param {string} [options.encoding='utf8'] encoding used for returned object. If 'buffer", we'll return a Buffer in palce of a string
    * @returns {string|Buffer}
    */


fs.realpathSync = (filepath, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8' });
  // FIXME: This assumes no symlinks, which we really don't have full support for in our SDK anyways.

  var result = path$1.normalize(filepath);

  if (!fs.existsSync(result)) {
    // this path doesn't exist, try each segment until we find first that doesn't
    var segments = result.split(path$1.sep);
    var partialFilePath = '';

    for (var segment of segments) {
      if (segment.length === 0) {
        continue;
      }

      partialFilePath += path$1.sep + segment;

      if (!fs.existsSync(partialFilePath)) {
        throw noSuchFile('lstat', partialFilePath);
      }
    }
  }

  if (options.encoding === 'buffer') {
    return Buffer.from(result);
  }

  return result;
};

fs.realpathSync.native = (path, options) => {
  fs.realpathSync(path, options);
};
/**
    * @param {string|Buffer|URL} oldPath source filepath
    * @param {string|Buffer|URL} newPath destination filepath
    * @param {errorCallback} callback async callback
    */


fs.rename = (oldPath, newPath, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.renameSync(oldPath, newPath);
    } catch (e) {
      callback(e);
      return;
    }

    callback();
  }, 1);
};
/**
    * @param {string|Buffer|URL} oldPath source filepath
    * @param {string|Buffer|URL} newPath destination filepath
    */


fs.renameSync = (oldPath, newPath) => {
  var tiFile = getTiFileFromPathLikeValue(oldPath); // src doesn't actually exist?

  if (!tiFile.exists()) {
    var err = noSuchFile('rename', oldPath);
    err.message = "".concat(err.message, " -> '").concat(newPath, "'");
    err.dest = newPath;
    throw err;
  }

  var destFile = getTiFileFromPathLikeValue(newPath);

  if (destFile.isDirectory()) {
    // dest is a directory that already exists
    var _err2 = illegalOperationOnADirectory('rename', oldPath);

    _err2.message = "".concat(_err2.message, " -> '").concat(newPath, "'");
    _err2.dest = newPath;
    throw _err2;
  }

  var tempPath;

  if (destFile.isFile()) {
    // destination file exists, we should overwrite
    // Our APIs will fail if we try, so first let's make a backup copy and delete the the original
    tempPath = path$1.join(fs.mkdtempSync(path$1.join(Ti.Filesystem.tempDirectory, 'rename-')), path$1.basename(newPath));
    destFile.move(tempPath);
  }

  var success = false;

  try {
    success = tiFile.move(newPath);
  } finally {
    if (tempPath) {
      // we temporarily copied the existing destination to back it up...
      if (success) {
        // move worked, so we can wipe it away whenever...
        fs.unlink(tempPath, _err => {});
      } else {
        // move it back, because we failed!
        var tmpFile = getTiFileFromPathLikeValue(tempPath);
        tmpFile.move(newPath);
      }
    }
  }
};
/**
    * @param {string|Buffer|URL} path file path
    * @param {errorCallback} callback async callback
    */


fs.rmdir = (path, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.rmdirSync(path);
    } catch (e) {
      callback(e);
      return;
    }

    callback();
  }, 1);
};
/**
    * @param {string|Buffer|URL} path file path
    */


fs.rmdirSync = path => {
  var tiFile = getTiFileFromPathLikeValue(path);

  if (!tiFile.deleteDirectory(false)) {
    // do not delete contents!
    // we failed to delete, but why?
    // does it exist?
    if (!tiFile.exists()) {
      throw noSuchFile('rmdir', path);
    } // is it a file?


    if (tiFile.isFile()) {
      throw notADirectory('rmdir', path);
    } // is it not empty?


    var subFiles = tiFile.getDirectoryListing();

    if (subFiles && subFiles.length > 0) {
      throw directoryNotEmpty('rmdir', path);
    }
  }
};
/**
    * @param {string|Buffer|URL} path file path
    * @param {object} [options] options
    * @param {boolean} [options.bigint] whether stat values should be bigint
    * @param {statsCallback} callback async callback
    */


fs.stat = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    callback(null, new fs.Stats(path));
  }, 1);
};
/**
    * @param {string|Buffer|URL|integer} path filepath or file descriptor
    * @param {object} [_options] options
    * @param {boolean} [_options.bigint] whether stat values should be bigint
    * @returns {fs.Stats}
    */


fs.statSync = (path, _options) => new fs.Stats(path);

fs.symlink = (target, path, type, callback) => asyncUnsupportedNoop('fs', 'symlink', callback);

fs.symlinkSync = unsupportedNoop('fs', 'symlinkSync');
/**
                                                        * @param {string} path file path
                                                        * @param {integer} [len=0] bytes to trim to
                                                        * @param {errorCallback} callback async callback
                                                        */

fs.truncate = (path, len, callback) => {
  callback = maybeCallback(callback || len);

  if (typeof len !== 'number') {
    len = 0;
  }

  if (len <= 0) {
    fs.writeFile(path, '', callback); // empty the file

    return;
  } // we have to retain some of the file!
  // yuck, so let's read what we need to retain, then overwrite file with it


  fs.open(path, (err, fd) => {
    if (err) {
      return callback(err);
    }

    var buffer = Buffer.alloc(len);
    fs.read(fd, buffer, 0, len, null, (err, bytesRead, buffer) => {
      if (err) {
        fs.closeSync(fd);
        return callback(err);
      }

      fs.close(fd, err => {
        if (err) {
          return callback(err);
        }

        fs.writeFile(path, buffer, callback);
      });
    });
  });
};
/**
    * @param {string} path file path
    * @param {integer} [len=0] bytes to trim to
    */


fs.truncateSync = (path, len = 0) => {
  if (len <= 0) {
    // empty the file
    fs.writeFileSync(path, '');
    return;
  } // we have to retain some of the file!
  // yuck, so let's read what we need to retain, then overwrite file with it


  var fd = fs.openSync(path);
  var buffer = Buffer.alloc(len);
  fs.readSync(fd, buffer, 0, len, null);
  fs.closeSync(fd);
  fs.writeFileSync(path, buffer);
};
/**
    * @param {string|Buffer|URL} path file path
    * @param {errorCallback} callback async callback
    */


fs.unlink = (path, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.unlinkSync(path);
    } catch (err) {
      callback(err);
      return;
    }

    callback();
  }, 1);
};
/**
    * @param {string|Buffer|URL} path file path
    * @returns {undefined}
    */


fs.unlinkSync = path => {
  var tiFile = getTiFileFromPathLikeValue(path);

  if (!tiFile.deleteFile()) {
    // we failed, but why?
    if (!tiFile.exists()) {
      throw noSuchFile('unlink', path);
    }

    if (tiFile.isDirectory()) {
      throw illegalOperationOnADirectory('unlink', path);
    }
  }
};

fs.unwatchFile = unsupportedNoop('fs', 'unwatchFile');

fs.utimes = (path, atime, mtime, callback) => asyncUnsupportedNoop('fs', 'utimes', callback);

fs.utimesSync = unsupportedNoop('fs', 'utimesSync');
fs.watch = unsupportedNoop('fs', 'watch');
fs.watchFile = unsupportedNoop('fs', 'watchFile');
/**
                                                    * @param {string|Buffer|URL|integer} file file path or descriptor
                                                    * @param {string|Buffer|TypedArray|DataView} data data to write
                                                    * @param {object|string} [options] options, encoding if string
                                                    * @param {string|null} [options.encoding='utf-8'] options
                                                    * @param {object} [options.mode=0o666] options
                                                    * @param {object} [options.flag='w'] options
                                                    * @param {errorCallback} callback async callback
                                                    */

fs.writeFile = (file, data, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'w' });
  // Turn into file descriptor

  var wasFileDescriptor = typeof file === 'number';
  var fileDescriptor = file; // may be overriden later

  var finish = err => {
    if (err) {
      callback(err);
      return;
    }

    if (wasFileDescriptor) {
      callback();
      return;
    } // fs.close if it was not originally a file descriptor


    fs.close(fileDescriptor, callback);
  };

  if (!wasFileDescriptor) {
    fs.open(file, options.flag, options.mode, (err, fd) => {
      if (err) {
        callback(err);
        return;
      }

      fileDescriptor = fd;
      fs.write(fileDescriptor, data, finish);
    });
  } else {
    fs.write(fileDescriptor, data, finish);
  }
};
/**
    * @param {string|Buffer|URL|integer} file file path or descriptor
    * @param {string|Buffer|TypedArray|DataView} data data to write
    * @param {object|string} [options] options, encoding if string
    * @param {string} [options.encoding='utf-8'] options
    * @param {object} [options.mode=0o666] options
    * @param {object} [options.flag='w'] options
    */


fs.writeFileSync = (file, data, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'w' });
  // Turn into file descriptor

  var wasFileDescriptor = typeof file === 'number';
  var fileDescriptor = wasFileDescriptor ? file : fs.openSync(file, options.flag, options.mode); // if data is a string, make it a buffer first

  if (!Buffer.isBuffer(data)) {
    data = Buffer.from('' + data, options.encoding); // force data to be a string, handles case where it's undefined and writes 'undefined' to file!
  }

  fs.writeSync(fileDescriptor, data); // close if user didn't give us file descriptor

  if (!wasFileDescriptor) {
    fs.closeSync(fileDescriptor);
  }
};
/**
    * @callback writeTiFileStreamCallback
    * @param {Error} err - Error if one occurred
    * @param {integer} written - bytes written
    */

/**
        * @param {Ti.Filesystem.FileStream} tiFileStream file stream
        * @param {Buffer} buffer buffer we're writing
        * @param {writeTiFileStreamCallback} callback async callback
        */


function writeTiFileStream(tiFileStream, buffer, callback) {
  callback = maybeCallback(callback);
  Ti.Stream.write(tiFileStream, buffer.toTiBuffer(), writeObj => {
    if (!writeObj.success) {
      callback(new Error(writeObj.error));
      return;
    }

    callback(null, writeObj.bytesProcessed);
  });
}
/**
   * @param {integer} fd file descriptor
   * @param {string|Buffer} buffer contents to write: Buffer or string
   * @param {integer} [offset] offset within Buffer to write; OR offset from the beginning of the file where this data should be written (if string)
   * @param {string|integer} [length] length of bytes to write if Buffer; OR expected string encoding
   * @param {writeCallback|integer} [position] offset from the beginning of the file where this data should be written (if Buffer); OR async callback if string
   * @param {writeCallback} [callback] async callback (if Buffer)
   */


fs.write = (fd, buffer, offset, length, position, callback) => {
  var isBuffer = Buffer.isBuffer(buffer);

  if (isBuffer) {
    writeBuffer(fd, buffer, offset, length, position, callback);
  } else {
    writeString(fd, buffer, offset, length, position);
  }
};
/**
    * @param {integer} fd file descriptor
    * @param {string|Buffer} buffer contents to write
    * @param {integer} [offset] offset from the beginning of the file where this data should be written
    * @param {string|integer} [length]  expected string encoding
    * @param {integer} [position] position
    * @returns {integer} number of bytes written
    */


fs.writeSync = (fd, buffer, offset, length, position) => {
  var isBuffer = Buffer.isBuffer(buffer);

  if (isBuffer) {
    return writeBufferSync(fd, buffer, offset, length);
  }

  return writeStringSync(fd, buffer, offset, length);
}; // TODO: Add FileHandle class to match Node's wrapper for file descriptors. Re-purpose our own wrapper?
// TODO: Add the fs.promises API!
// TODO: Define fs.Dirent class, which can simply wrap a Ti.Filesystem.File (and is very similar to fs.Stats!)
// Helper functions
// --------------------------------------------------------

/**
 * Tracks the pairing of the number we use to represent the file externally, the filepath it's pointing at, and the stream pointing at it.
 */


class FileDescriptor {
  constructor(number, path, stream) {
    this.path = path;
    this.number = number;
    this.stream = stream;
  }}


/**
      * @param {Ti.IOStream} srcStream input stream we're reading from
      * @param {Ti.IOStream} destStream output stream we're writing to
      * @param {errorCallback} callback async callback
      */


function pipe(srcStream, destStream, callback) {
  if (isAndroid$1) {
    // Android is probably better off with Ti.Stream.writeStream, less overhead back and forth the bridge
    // Though Android does support the Ti.Stream.pump/Ti.Stream.write pattern using both APIs async
    pipeViaWriteStream(srcStream, destStream, callback);
    return;
  } // iOS has some... issues with writeStream calling the callback every iteration of the loop *and* at the end
  // it also doesn't play as expected when doing Ti.Stream.pump and Ti.Stream.write async each
  // it ends up doing all reads first and then all writes
  // so we have to hack here and do Ti.Stream.pump async, but each time the read callback happens we do a *sync* write inside it
  // See https://jira.appcelerator.org/browse/TIMOB-27321


  pipeViaPump(srcStream, destStream, callback);
}
/**
   * @param {Ti.IOStream} srcStream input stream we're reading from
   * @param {Ti.IOStream} destStream output stream we're writing to
   * @param {errorCallback} callback async callback
   */


function pipeViaWriteStream(srcStream, destStream, callback) {
  Ti.Stream.writeStream(srcStream, destStream, COPY_FILE_CHUNK_SIZE, result => {
    if (!result.success) {
      return callback(new Error(result.error));
    } // Android will only call this at the end or error, so we can safely assume we're done here.
    // iOS will call per loop iteration, see https://jira.appcelerator.org/browse/TIMOB-27320


    callback();
  });
}
/**
   * @param {Ti.IOStream} srcStream input stream we're reading from
   * @param {Ti.IOStream} destStream output stream we're writing to
   * @param {errorCallback} callback async callback
   */


function pipeViaPump(srcStream, destStream, callback) {
  Ti.Stream.pump(srcStream, obj => {
    if (!obj.success) {
      return callback(new Error(obj.error)); // TODO: set code via writeObj.code?
    }

    if (obj.bytesProcessed === -1) {
      // reached EOF
      return callback();
    } // we read some segment of the input stream and have not reached EOF yet


    var bytesWritten = 0;
    var offset = 0;
    var length = obj.bytesProcessed;

    try {
      while (true) {
        // try to write all of the current buffer
        var bytesWrittenThisChunk = destStream.write(obj.buffer, offset, length);
        bytesWritten += bytesWrittenThisChunk;

        if (bytesWritten === obj.bytesProcessed) {
          // wrote same amount of bytes as we read, move on
          break;
        } // NOTE: This shouldn't ever happen because our APIs should write the entire byte array or fail, but just in case...
        // we didn't write it all, so move on to try and write the rest of buffer...


        offset = bytesWritten;
        length = obj.bytesProcessed - bytesWritten;
      }
    } catch (e) {
      return callback(e);
    }
  }, COPY_FILE_CHUNK_SIZE, true);
}
/**
   * @param {string|Buffer|URL} path file path
   * @param {Ti.Filesystem.FileStream} fileStream file stream
   * @returns {integer} file descriptor
   */


function createFileDescriptor(path, fileStream) {
  var pointer = fileDescriptorCount++; // increment global counter

  var fd = new FileDescriptor(pointer, path, fileStream);
  fileDescriptors.set(pointer, fd); // use it to refer to this file stream as the "descriptor"

  return pointer;
}
/**
   * @param {integer} fd file descriptor
   * @returns {Ti.Filesystem.FileStream} matching stream
   */


function streamForDescriptor(fd) {
  var wrapper = fileDescriptors.get(fd);
  return wrapper.stream;
}
/**
   * @param {integer} fd file descriptor
   * @returns {string} matching stream
   */


function pathForFileDescriptor(fd) {
  var wrapper = fileDescriptors.get(fd);
  return wrapper.path;
}
/**
   * Used to merge the user-supplied options with the defaults for a function. Special cases a string to be encoding.
   * @param {*} options user-supplied options
   * @param {object} defaults defaults to use
   * @return {object}
   */


function mergeDefaultOptions(options, defaults) {
  if (options === null) {
    return defaults;
  }

  var optionsType = typeof options;

  switch (optionsType) {
    case 'undefined':
    case 'function':
      return defaults;

    case 'string':
      // Use copy of defaults but with encoding set to the 'options' value!
      var merged = Object.assign({}, defaults);
      merged.encoding = options;
      return merged;

    case 'object':
      return options;

    default:
      assertArgumentType(options, 'options', 'object');
      return null;
    // should never get reached
  }
}
/**
   * Enforces that we have a valid callback function. Throws TypeError if not.
   * @param {*} cb possible callback function
   * @returns {Function}
   * @throws {TypeError}
   */


function maybeCallback(cb) {
  if (typeof cb === 'function') {
    return cb;
  }

  var err = new TypeError("Callback must be a function. Received ".concat(cb));
  err.code = 'ERR_INVALID_CALLBACK';
  throw err;
}
/**
   * returns randomly generated characters of given length 1-16
   * @param {integer} length 1 - 16
   * @param {string} [_encoding='utf8'] encoding of the string generated
   * @returns {string}
   */


function randomCharacters(length, _encoding = 'utf8') {
  // FIXME: use the encoding specified!
  return (Math.random().toString(36) + '00000000000000000').slice(2, length + 2);
}

function makeError(code, message, errno, syscall, path) {
  var error = new Error("".concat(code, ": ").concat(message, ", ").concat(syscall, " '").concat(path, "'"));
  error.errno = errno;
  error.syscall = syscall;
  error.code = code;
  error.path = path;
  return error;
}
/**
   * @param {string} encoding what we're encoding to
   * @param {Ti.Buffer} tiBuffer Ti.Buffer instance
   * @returns {Buffer} node-compatible Buffer instance
   */


function encodeBuffer(encoding, tiBuffer) {
  var buffer = Buffer.from(tiBuffer);

  switch (encoding) {
    case 'buffer':
    case null:
    case undefined:
      return buffer;

    default:
      return buffer.toString(encoding);}

}
/**
   * @param {string|Buffer|URL} path file path
   * @return {Ti.Filesystem.File}
   */


function getTiFileFromPathLikeValue(path) {
  // This is a hack that is likely to work in most cases?
  // Basically assumes Buffer is holding a utf-8 string filename/path
  // Node just copies the bytes from the buffer as-is on the native side and adds a null terminator
  if (Buffer.isBuffer(path)) {
    path = path.toString(); // assumes utf-8 string
  } // FIXME: Handle URLs! We don't have an URL shim yet, so no way to handle those yet


  assertArgumentType(path, 'path', 'string');
  return Ti.Filesystem.getFile(path);
}
/**
   * @callback writeBufferCallback
   * @param {Error} err - Error if one occurred
   * @param {integer} written - bytes written
   * @param {Buffer} buffer - original Buffer being written
   */

/**
       * @param {integer} fd file descriptor
       * @param {Buffer} buffer contents to write
       * @param {integer} [offset] offset within Buffer to write
       * @param {integer} [length] length of bytes to write if Buffer
       * @param {integer} [position] offset from the beginning of the file where this data should be written
       * @param {writeBufferCallback} callback async callback
       */


function writeBuffer(fd, buffer, offset, length, position, callback) {
  callback = maybeCallback(callback || position || length || offset);

  if (typeof offset !== 'number') {
    offset = 0;
  }

  if (typeof length !== 'number') {
    length = buffer.length - offset;
  }

  if (typeof position !== 'number') {
    position = null;
  } // ok now what?


  var tiFileStream = streamForDescriptor(fd); // Make use of the buffer slice that's specified by offset/length

  if (offset !== 0 || length !== buffer.length) {
    buffer = buffer.slice(offset, length);
  } // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow


  writeTiFileStream(tiFileStream, buffer, (err, bytesProcessed) => {
    if (err) {
      callback(err);
      return;
    }

    callback(null, bytesProcessed, buffer);
  });
}
/**
   * @param {integer} fd file descriptor
   * @param {Buffer} buffer contents to write
   * @param {integer} [offset] offset within Buffer to write
   * @param {integer} [length] length of bytes to write if Buffer
   * @param {integer} [position] offset from the beginning of the file where this data should be written
   * @returns {integer} number of bytes written
   */


function writeBufferSync(fd, buffer, offset, length, position) {
  if (typeof offset !== 'number') {
    offset = 0;
  }

  if (typeof length !== 'number') {
    length = buffer.length - offset;
  }


  var tiFileStream = streamForDescriptor(fd); // Make use of the buffer slice that's specified by offset/length

  if (offset !== 0 || length !== buffer.length) {
    buffer = buffer.slice(offset, length);
  } // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow


  return tiFileStream.write(buffer.toTiBuffer());
}
/**
   * @callback writeStringCallback
   * @param {Error} err - Error if one occurred
   * @param {integer} written - bytes written
   * @param {string} string - original string being written
   */

/**
       * @param {integer} fd file descriptor
       * @param {string} string contents to write
       * @param {integer} [position] offset from the beginning of the file where this data should be written
       * @param {string} [encoding='utf8'] expected string encoding
       * @param {writeStringCallback} [callback] async callback
       */


function writeString(fd, string, position, encoding, callback) {
  callback = maybeCallback(callback || encoding || position); // position could be: number, function (callback)

  if (typeof position !== 'number') {
    position = null;
  } // encoding could be: function (callback) or string


  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }

  var tiFileStream = streamForDescriptor(fd);
  string += ''; // coerce to string

  var buffer = Buffer.from(string, encoding); // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow

  writeTiFileStream(tiFileStream, buffer, (err, bytesProcessed) => {
    if (err) {
      callback(err);
      return;
    }

    callback(null, bytesProcessed, string);
  });
}
/**
   * @param {integer} fd file descriptor
   * @param {string} string contents to write
   * @param {integer} [position] offset from the beginning of the file where this data should be written
   * @param {string} [encoding='utf8'] expected string encoding
   * @returns {integer} number of bytes written
   */


function writeStringSync(fd, string, position, encoding) {

  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }

  var tiFileStream = streamForDescriptor(fd);
  string += ''; // coerce to string

  var buffer = Buffer.from(string, encoding); // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow

  return tiFileStream.write(buffer.toTiBuffer());
}

/**
   * This file is used to hijack the standard require to allow for JS
   * implementations of "core" modules.
   *
   * You add a binding from the "core" module id to the under the hood JS
   * implementation. We then intercept require calls to handle requests for these modules
   * and lazily load the file.
   */

/**
       * Used by @function bindObjectToCoreModuleId
       * @type {map<string, object>}
       */
var bindings = new Map();
/**
                           * Used by @function redirectCoreModuleIdToPath
                           * @type {map<string, string>}
                           */

var redirects = new Map();
/**
                            * Does the request look like a typical core module? (no '.' or '/' characters)
                            * @param {string} path original require path/id
                            * @returns {boolean}
                            */

function isHijackableModuleId(path) {
  if (!path || path.length < 1) {
    return false;
  }

  var firstChar = path.charAt(0);
  return firstChar !== '.' && firstChar !== '/';
} // Hack require to point to this as a core module "binding"


var originalRequire = global.require; // This works for iOS as-is, and also intercepts the call on Android for ti.main.js (the first file executed)

global.require = function (moduleId) {
  if (bindings.has(moduleId)) {
    return bindings.get(moduleId);
  }

  if (redirects.has(moduleId)) {
    moduleId = redirects.get(moduleId);
  }

  return originalRequire(moduleId);
};

if (Ti.Platform.name === 'android') {
  // ... but we still need to hack it when requiring from other files for Android
  var originalModuleRequire = global.Module.prototype.require;

  global.Module.prototype.require = function (path, context) {
    if (bindings.has(path)) {
      return bindings.get(path);
    }

    if (redirects.has(path)) {
      path = redirects.get(path);
    }

    return originalModuleRequire.call(this, path, context);
  };
}
/**
   * Registers a binding from a short module id to an already loaded/constructed object/value to export for that core module id
   *
   * @param {string} moduleId the module id to "hijack"
   * @param {*} binding an already constructured value/object to return
   */


function register(moduleId, binding) {
  if (!isHijackableModuleId(moduleId)) {
    throw new Error("Cannot register for relative/absolute file paths; no leading '.' or '/' allowed (was given ".concat(moduleId, ")"));
  }

  if (redirects.has(moduleId)) {
    Ti.API.warn("Another binding has already registered for module id: '".concat(moduleId, "', it will be overwritten..."));
    redirects.delete(moduleId);
  } else if (bindings.has(moduleId)) {
    Ti.API.warn("Another binding has already registered for module id: '".concat(moduleId, "', it will be overwritten..."));
  }

  bindings.set(moduleId, binding);
}
/**
   * Registers a binding from a short module id to the full under the hood filepath if given a string.
   * This allows for lazy instantiation of the module on-demand
   *
   * @param {string} moduleId the module id to "hijack"
   * @param {string} filepath the full filepath to require under the hood.
   *                              This should be an already resolved absolute path,
   *                              as otherwise the context of the call could change what gets loaded!
   */

function redirect(moduleId, filepath) {
  if (!isHijackableModuleId(moduleId)) {
    throw new Error("Cannot register for relative/absolute file paths; no leading '.' or '/' allowed (was given ".concat(moduleId, ")"));
  }

  if (bindings.has(moduleId)) {
    Ti.API.warn("Another binding has already registered for module id: '".concat(moduleId, "', it will be overwritten..."));
    bindings.delete(moduleId);
  } else if (redirects.has(moduleId)) {
    Ti.API.warn("Another binding has already registered for module id: '".concat(moduleId, "', it will be overwritten..."));
  }

  redirects.set(moduleId, filepath);
}
var binding = {
  register,
  redirect };

global.binding = binding;

// Load all the node compatible core modules
register('path', path$1);
register('os', OS);
register('tty', tty);
register('util', util);
register('assert', assert$1);
register('events', EventEmitter);
register('buffer', BufferModule);
register('string_decoder', StringDecoder$1);
register('fs', fs); // Register require('buffer').Buffer as global

global.Buffer = BufferModule.Buffer;

/**
                                      * Appcelerator Titanium Mobile
                                      * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.
                                      * Licensed under the terms of the Apache Public License
                                      * Please see the LICENSE included with this distribution for details.
                                      *
                                      * Description:
                                      * This script loads all JavaScript files ending with the name "*.bootstrap.js" and then executes them.
                                      * The main intention of this feature is to allow JavaScript files to kick-off functionality or
                                      * display UI to the end-user before the "app.js" gets loaded. This feature is the CommonJS
                                      * equivalent to Titanium's Android module onAppCreate() or iOS module load() features.
                                      *
                                      * Use-Cases:
                                      * - Automatically kick-off analytics functionality on app startup.
                                      * - Ensure "Google Play Services" is installed/updated on app startup on Android.
                                      */

/**
                                          * Attempts to load all bootstraps from a "bootstrap.json" file created by the app build system.
                                          * This is an optional feature and is the fastest method of acquiring boostraps configured for the app.
                                          * This JSON file, if provided, must be in the same directory as this script.
                                          * @returns {string[]}
                                          * Returns an array of require() compatible strings if bootstraps were successfully loaded from JSON.
                                          * Returns an empty array if JSON file was found, but no bootstraps were configured for the app.
                                          * Returns null if JSON file was not found.
                                          */
function fetchScriptsFromJson() {
  var JSON_FILE_NAME = 'bootstrap.json';

  try {
    var jsonFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, "ti.internal/".concat(JSON_FILE_NAME));

    if (jsonFile.exists()) {
      var settings = JSON.parse(jsonFile.read().text);

      if (Array.isArray(settings.scripts)) {
        return settings.scripts;
      }

      return [];
    }
  } catch (error) {
    Ti.API.error("Failed to read \"".concat(JSON_FILE_NAME, "\". Reason: ").concat(error.message));
  }

  return null;
}
/**
   * Recursively searches the "Resources" directory for all "*.bootstrap.js" files.
   * @returns {Array.<string>}
   * Returns an array of require() compatible strings for each bootstrap found in the search.
   * Returns an empty array if no bootstrap files were found.
   */


function fetchScriptsFromResourcesDirectory() {
  var resourceDirectory = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory);
  var resourceDirectoryPathLength = resourceDirectory.nativePath.length;
  var bootstrapScripts = [];

  function loadFrom(file) {
    if (file) {
      if (file.isDirectory()) {
        // This is a directory. Recursively look for bootstrap files under it.
        var fileNameArray = file.getDirectoryListing();

        if (fileNameArray) {
          for (var index = 0; index < fileNameArray.length; index++) {
            loadFrom(Ti.Filesystem.getFile(file.nativePath, fileNameArray[index]));
          }
        }
      } else if (file.name.search(/.bootstrap.js$/) >= 0) {
        // This is a bootstrap file.
        // Convert its path to something loadable via require() and add it to the array.
        var bootstrapPath = file.nativePath;
        bootstrapPath = bootstrapPath.substr(resourceDirectoryPathLength, bootstrapPath.length - resourceDirectoryPathLength - '.js'.length);
        bootstrapScripts.push(bootstrapPath);
      }
    }
  }

  loadFrom(resourceDirectory);
  return bootstrapScripts;
}
/**
   * Non-blocking function which loads and executes all bootstrap scripts configured for the app.
   * @param {function} finished Callback to be invoked once all bootstraps have finished executing. Cannot be null.
   */


function loadAsync(finished) {
  // Acquire an array of all bootstrap scripts included with the app.
  // - For best performance, attempt to fetch scripts via an optional JSON file created by the build system.
  // - If JSON file not found (will return null), then search "Resources" directory for bootstrap files.
  var bootstrapScripts = fetchScriptsFromJson();

  if (!bootstrapScripts) {
    bootstrapScripts = fetchScriptsFromResourcesDirectory();
  } // Do not continue if no bootstraps were found.


  if (!bootstrapScripts || bootstrapScripts.length <= 0) {
    finished();
    return;
  } // Sort the bootstraps so that they'll be loaded in a consistent order between platforms.


  bootstrapScripts.sort(); // Loads all bootstrap scripts found.

  function loadBootstrapScripts(finished) {
    var bootstrapIndex = 0;

    function doLoad() {
      // Attempt to load all bootstrap scripts.
      while (bootstrapIndex < bootstrapScripts.length) {
        // Load the next bootstrap.
        var fileName = bootstrapScripts[bootstrapIndex];

        var bootstrap = require(fileName); // eslint-disable-line security/detect-non-literal-require
        // Invoke the bootstrap's execute() method if it has one. (This is optional.)
        // We must wait for the given callback to be invoked before loading the next script.
        // Note: This is expected to be used to display UI to the end-user.


        if (bootstrap.execute) {
          bootstrap.execute(onBootstrapExecutionFinished);
          return;
        } // We're done with the current bootstrap. Time to load the next one.


        bootstrapIndex++;
      } // Invoke given callback to inform caller that all loading is done.


      finished();
    }

    function onBootstrapExecutionFinished() {
      // Last bootstrap has finished execution. Time to load the next one.
      // Note: Add a tiny delay so whatever UI the last bootstrap loaded has time to close.
      bootstrapIndex++;
      setTimeout(() => doLoad(), 1);
    }

    doLoad();
  } // We've finished loading/executing all bootstrap scripts.
  // Inform caller by invoking the callback given to loadAsync().


  loadBootstrapScripts(finished);
}

/**
   * Appcelerator Titanium Mobile
   * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.
   * Licensed under the terms of the Apache Public License
   * Please see the LICENSE included with this distribution for details.
   *
   * This script is loaded on app startup on all platforms. It is used to do the following:
   * - Provide consistent startup behavior between platforms, such as logging Titanium version.
   * - Load Titanium's core JavaScript extensions shared by all platforms.
   * - Provide "*.bootstrap.js" script support. (Similar to native module onAppCreate()/load() support.)
   * - Load the app developer's main "app.js" script after doing all of the above.
   */
// Log the app name, app version, and Titanium version on startup.
Ti.API.info("".concat(Ti.App.name, " ").concat(Ti.App.version, " (Powered by Titanium ").concat("9.1.0", ".").concat("b8e966d0c9", ")")); // Attempt to load crash analytics module.
// NOTE: This should be the first module that loads on startup.

try {
  require('com.appcelerator.aca');
} catch (e) {} // Could not load module, silently ignore exception.
loadAsync(function () {
  // We've finished loading/executing all bootstrap scripts.
  // We can now proceed to run the main "app.js" script.
  require('./app'); // This event is to be fired after "app.js" execution. Reasons:
  // - Allow system to queue startup related events until "app.js" has had a chance to add listeners.
  // - For Alloy apps, we now know that Alloy has been initialized and its globals were added.


  Ti.App.fireEvent('started');
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRpLm1haW4uanMiXSwibmFtZXMiOlsiY29tbW9uanNHbG9iYWwiLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsImNyZWF0ZUNvbW1vbmpzTW9kdWxlIiwiZm4iLCJtb2R1bGUiLCJleHBvcnRzIiwiY2hlY2siLCJpdCIsIk1hdGgiLCJnbG9iYWxfMSIsIkZ1bmN0aW9uIiwiZmFpbHMiLCJleGVjIiwiZXJyb3IiLCJkZXNjcmlwdG9ycyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiYSIsIm5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJOQVNIT1JOX0JVRyIsImNhbGwiLCJmIiwiViIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwib2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUiLCJjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IiLCJiaXRtYXAiLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidG9TdHJpbmciLCJjbGFzc29mUmF3Iiwic2xpY2UiLCJzcGxpdCIsImluZGV4ZWRPYmplY3QiLCJyZXF1aXJlT2JqZWN0Q29lcmNpYmxlIiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwidG9JbmRleGVkT2JqZWN0IiwiaXNPYmplY3QiLCJ0b1ByaW1pdGl2ZSIsImlucHV0IiwiUFJFRkVSUkVEX1NUUklORyIsInZhbCIsInZhbHVlT2YiLCJoYXNPd25Qcm9wZXJ0eSIsImhhcyIsImtleSIsImRvY3VtZW50JDEiLCJkb2N1bWVudCIsIkVYSVNUUyIsImNyZWF0ZUVsZW1lbnQiLCJkb2N1bWVudENyZWF0ZUVsZW1lbnQiLCJpZThEb21EZWZpbmUiLCJuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJmJDEiLCJPIiwiUCIsIm9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImFuT2JqZWN0IiwiU3RyaW5nIiwibmF0aXZlRGVmaW5lUHJvcGVydHkiLCJmJDIiLCJBdHRyaWJ1dGVzIiwib2JqZWN0RGVmaW5lUHJvcGVydHkiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkiLCJvYmplY3QiLCJzZXRHbG9iYWwiLCJTSEFSRUQiLCJzdG9yZSIsInNoYXJlZFN0b3JlIiwiZnVuY3Rpb25Ub1N0cmluZyIsImluc3BlY3RTb3VyY2UiLCJXZWFrTWFwIiwibmF0aXZlV2Vha01hcCIsInRlc3QiLCJzaGFyZWQiLCJwdXNoIiwidmVyc2lvbiIsIm1vZGUiLCJjb3B5cmlnaHQiLCJpZCIsInBvc3RmaXgiLCJyYW5kb20iLCJ1aWQiLCJrZXlzIiwic2hhcmVkS2V5IiwiaGlkZGVuS2V5cyIsIldlYWtNYXAkMSIsInNldCIsImhhcyQxIiwiZW5mb3JjZSIsImdldHRlckZvciIsIlRZUEUiLCJzdGF0ZSIsInR5cGUiLCJzdG9yZSQxIiwid21nZXQiLCJ3bWhhcyIsIndtc2V0IiwibWV0YWRhdGEiLCJTVEFURSIsImludGVybmFsU3RhdGUiLCJyZWRlZmluZSIsImdldEludGVybmFsU3RhdGUiLCJlbmZvcmNlSW50ZXJuYWxTdGF0ZSIsIlRFTVBMQVRFIiwib3B0aW9ucyIsInVuc2FmZSIsInNpbXBsZSIsIm5vVGFyZ2V0R2V0Iiwic291cmNlIiwiam9pbiIsInByb3RvdHlwZSIsInBhdGgiLCJhRnVuY3Rpb24iLCJ2YXJpYWJsZSIsImdldEJ1aWx0SW4iLCJuYW1lc3BhY2UiLCJtZXRob2QiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJjZWlsIiwiZmxvb3IiLCJ0b0ludGVnZXIiLCJhcmd1bWVudCIsImlzTmFOIiwibWluIiwidG9MZW5ndGgiLCJtYXgiLCJtaW4kMSIsInRvQWJzb2x1dGVJbmRleCIsImluZGV4IiwiaW50ZWdlciIsImNyZWF0ZU1ldGhvZCIsIklTX0lOQ0xVREVTIiwiJHRoaXMiLCJlbCIsImZyb21JbmRleCIsImFycmF5SW5jbHVkZXMiLCJpbmNsdWRlcyIsImluZGV4T2YiLCJvYmplY3RLZXlzSW50ZXJuYWwiLCJuYW1lcyIsImkiLCJyZXN1bHQiLCJlbnVtQnVnS2V5cyIsImhpZGRlbktleXMkMSIsImNvbmNhdCIsImYkMyIsImdldE93blByb3BlcnR5TmFtZXMiLCJvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZiQ0IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwib2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzIiwib3duS2V5cyIsImNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMiLCJ0YXJnZXQiLCJyZXBsYWNlbWVudCIsImlzRm9yY2VkIiwiZmVhdHVyZSIsImRldGVjdGlvbiIsImRhdGEiLCJub3JtYWxpemUiLCJQT0xZRklMTCIsIk5BVElWRSIsInN0cmluZyIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsImlzRm9yY2VkXzEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSIsIl9leHBvcnQiLCJUQVJHRVQiLCJHTE9CQUwiLCJTVEFUSUMiLCJzdGF0IiwiRk9SQ0VEIiwidGFyZ2V0UHJvcGVydHkiLCJzb3VyY2VQcm9wZXJ0eSIsImZvcmNlZCIsInNoYW0iLCJOYXRpdmVTeW1ib2wiLCJTeW1ib2wiLCJkZXNjcmlwdGlvbiIsIkVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSIsIlN5bWJvbFdyYXBwZXIiLCJzeW1ib2xQcm90b3R5cGUiLCJjb25zdHJ1Y3RvciIsInN5bWJvbFRvU3RyaW5nIiwibmF0aXZlIiwicmVnZXhwIiwic3ltYm9sIiwiZGVzYyIsIm5hdGl2ZVN5bWJvbCIsInVzZVN5bWJvbEFzVWlkIiwiaXRlcmF0b3IiLCJXZWxsS25vd25TeW1ib2xzU3RvcmUiLCJTeW1ib2wkMSIsImNyZWF0ZVdlbGxLbm93blN5bWJvbCIsIndpdGhvdXRTZXR0ZXIiLCJ3ZWxsS25vd25TeW1ib2wiLCJuYW1lIiwiZiQ1Iiwid3JhcHBlZFdlbGxLbm93blN5bWJvbCIsImRlZmluZVByb3BlcnR5JDEiLCJkZWZpbmVXZWxsS25vd25TeW1ib2wiLCJOQU1FIiwiaXNBcnJheSIsIkFycmF5IiwiYXJnIiwiYUZ1bmN0aW9uJDEiLCJiaW5kQ29udGV4dCIsInRoYXQiLCJiIiwiYyIsImFwcGx5IiwiZmxhdHRlbkludG9BcnJheSIsIm9yaWdpbmFsIiwic291cmNlTGVuIiwic3RhcnQiLCJkZXB0aCIsIm1hcHBlciIsInRoaXNBcmciLCJ0YXJnZXRJbmRleCIsInNvdXJjZUluZGV4IiwibWFwRm4iLCJlbGVtZW50IiwiZmxhdHRlbkludG9BcnJheV8xIiwidG9PYmplY3QiLCJTUEVDSUVTIiwiYXJyYXlTcGVjaWVzQ3JlYXRlIiwib3JpZ2luYWxBcnJheSIsIkMiLCJwcm90byIsImZsYXQiLCJkZXB0aEFyZyIsIkEiLCJmbGF0TWFwIiwiY2FsbGJhY2tmbiIsIm5hdGl2ZVJldmVyc2UiLCJyZXZlcnNlIiwic2xvcHB5QXJyYXlNZXRob2QiLCJNRVRIT0RfTkFNRSIsInRlc3QkMSIsIm5hdGl2ZVNvcnQiLCJzb3J0IiwiRkFJTFNfT05fVU5ERUZJTkVEIiwiRkFJTFNfT05fTlVMTCIsIlNMT1BQWV9NRVRIT0QiLCJjb21wYXJlZm4iLCJvYmplY3RLZXlzIiwib2JqZWN0RGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnRpZXMiLCJQcm9wZXJ0aWVzIiwiaHRtbCIsIkdUIiwiTFQiLCJQUk9UT1RZUEUiLCJTQ1JJUFQiLCJJRV9QUk9UTyIsIkVtcHR5Q29uc3RydWN0b3IiLCJzY3JpcHRUYWciLCJjb250ZW50IiwiTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCIsImFjdGl2ZVhEb2N1bWVudCIsIndyaXRlIiwiY2xvc2UiLCJ0ZW1wIiwicGFyZW50V2luZG93IiwiTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lIiwiaWZyYW1lIiwiSlMiLCJpZnJhbWVEb2N1bWVudCIsInN0eWxlIiwiZGlzcGxheSIsImFwcGVuZENoaWxkIiwic3JjIiwiY29udGVudFdpbmRvdyIsIm9wZW4iLCJGIiwiTnVsbFByb3RvT2JqZWN0IiwiZG9tYWluIiwiQWN0aXZlWE9iamVjdCIsIm9iamVjdENyZWF0ZSIsImNyZWF0ZSIsIlVOU0NPUEFCTEVTIiwiQXJyYXlQcm90b3R5cGUiLCJhZGRUb1Vuc2NvcGFibGVzIiwiVE9fU1RSSU5HX1RBRyIsInRlc3QkMiIsInRvU3RyaW5nVGFnU3VwcG9ydCIsIlRPX1NUUklOR19UQUckMSIsIkNPUlJFQ1RfQVJHVU1FTlRTIiwidHJ5R2V0IiwiY2xhc3NvZiIsInRhZyIsImNhbGxlZSIsImNvcnJlY3RQcm90b3R5cGVHZXR0ZXIiLCJnZXRQcm90b3R5cGVPZiIsIklFX1BST1RPJDEiLCJPYmplY3RQcm90b3R5cGUiLCJvYmplY3RHZXRQcm90b3R5cGVPZiIsImFQb3NzaWJsZVByb3RvdHlwZSIsIm9iamVjdFNldFByb3RvdHlwZU9mIiwic2V0UHJvdG90eXBlT2YiLCJDT1JSRUNUX1NFVFRFUiIsInNldHRlciIsIl9fcHJvdG9fXyIsImRlZmluZVByb3BlcnR5JDIiLCJEYXRhVmlldyIsIkRhdGFWaWV3UHJvdG90eXBlIiwiSW50OEFycmF5JDEiLCJJbnQ4QXJyYXkiLCJJbnQ4QXJyYXlQcm90b3R5cGUiLCJVaW50OENsYW1wZWRBcnJheSQxIiwiVWludDhDbGFtcGVkQXJyYXkiLCJVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSIsIlR5cGVkQXJyYXkiLCJUeXBlZEFycmF5UHJvdG90eXBlIiwiT2JqZWN0UHJvdG90eXBlJDEiLCJpc1Byb3RvdHlwZU9mIiwiVE9fU1RSSU5HX1RBRyQyIiwiVFlQRURfQVJSQVlfVEFHIiwiTkFUSVZFX0FSUkFZX0JVRkZFUiIsIkFycmF5QnVmZmVyIiwiTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyIsIm9wZXJhIiwiVFlQRURfQVJSQVlfVEFHX1JFUUlSRUQiLCJUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCIsIlVpbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiVWludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiVWludDMyQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJpc1ZpZXciLCJrbGFzcyIsImlzVHlwZWRBcnJheSIsImFUeXBlZEFycmF5IiwiYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciIsIkFSUkFZIiwiVHlwZWRBcnJheUNvbnN0cnVjdG9yIiwiZXhwb3J0VHlwZWRBcnJheU1ldGhvZCIsIktFWSIsInByb3BlcnR5IiwiZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZCIsImFycmF5QnVmZmVyVmlld0NvcmUiLCJyZWRlZmluZUFsbCIsImFuSW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsInRvSW5kZXgiLCJudW1iZXIiLCJSYW5nZUVycm9yIiwiSW5maW5pdHkkMSIsImFicyIsInBvdyIsImZsb29yJDEiLCJsb2ciLCJMTjIiLCJwYWNrIiwibWFudGlzc2FMZW5ndGgiLCJieXRlcyIsImJ1ZmZlciIsImV4cG9uZW50TGVuZ3RoIiwiZU1heCIsImVCaWFzIiwicnQiLCJzaWduIiwiZXhwb25lbnQiLCJtYW50aXNzYSIsInVucGFjayIsIm5CaXRzIiwiTmFOIiwiaWVlZTc1NCIsImFycmF5RmlsbCIsImZpbGwiLCJhcmd1bWVudHNMZW5ndGgiLCJlbmQiLCJlbmRQb3MiLCJkZWZpbmVQcm9wZXJ0eSQzIiwiVE9fU1RSSU5HX1RBRyQzIiwic2V0VG9TdHJpbmdUYWciLCJUQUciLCJOQVRJVkVfQVJSQVlfQlVGRkVSJDEiLCJkZWZpbmVQcm9wZXJ0eSQ0Iiwic2V0SW50ZXJuYWxTdGF0ZSIsIkFSUkFZX0JVRkZFUiIsIkRBVEFfVklFVyIsIlBST1RPVFlQRSQxIiwiV1JPTkdfTEVOR1RIIiwiV1JPTkdfSU5ERVgiLCJOYXRpdmVBcnJheUJ1ZmZlciIsIiRBcnJheUJ1ZmZlciIsIiREYXRhVmlldyIsIlJhbmdlRXJyb3IkMSIsInBhY2tJRUVFNzU0IiwidW5wYWNrSUVFRTc1NCIsInBhY2tJbnQ4IiwicGFja0ludDE2IiwicGFja0ludDMyIiwidW5wYWNrSW50MzIiLCJwYWNrRmxvYXQzMiIsInBhY2tGbG9hdDY0IiwiYWRkR2V0dGVyIiwiZ2V0JDEiLCJ2aWV3IiwiY291bnQiLCJpc0xpdHRsZUVuZGlhbiIsImludEluZGV4IiwiYnl0ZUxlbmd0aCIsImJ5dGVPZmZzZXQiLCJzZXQkMSIsImNvbnZlcnNpb24iLCJidWZmZXJMZW5ndGgiLCJvZmZzZXQiLCJnZXRJbnQ4IiwiZ2V0VWludDgiLCJnZXRJbnQxNiIsImdldFVpbnQxNiIsImdldEludDMyIiwiZ2V0VWludDMyIiwiZ2V0RmxvYXQzMiIsImdldEZsb2F0NjQiLCJzZXRJbnQ4Iiwic2V0VWludDgiLCJzZXRJbnQxNiIsInNldFVpbnQxNiIsInNldEludDMyIiwic2V0VWludDMyIiwic2V0RmxvYXQzMiIsInNldEZsb2F0NjQiLCJBcnJheUJ1ZmZlclByb3RvdHlwZSIsImtleXMkMSIsImoiLCJ0ZXN0VmlldyIsIm5hdGl2ZVNldEludDgiLCJhcnJheUJ1ZmZlciIsIlNQRUNJRVMkMSIsInNldFNwZWNpZXMiLCJDT05TVFJVQ1RPUl9OQU1FIiwiQVJSQVlfQlVGRkVSJDEiLCJBcnJheUJ1ZmZlciQxIiwiTmF0aXZlQXJyYXlCdWZmZXIkMSIsIlNQRUNJRVMkMiIsInNwZWNpZXNDb25zdHJ1Y3RvciIsImRlZmF1bHRDb25zdHJ1Y3RvciIsIlMiLCJBcnJheUJ1ZmZlciQyIiwiRGF0YVZpZXckMSIsIm5hdGl2ZUFycmF5QnVmZmVyU2xpY2UiLCJJTkNPUlJFQ1RfU0xJQ0UiLCJmaXJzdCIsImZpbiIsInZpZXdTb3VyY2UiLCJ2aWV3VGFyZ2V0Iiwid2hpdGVzcGFjZXMiLCJ3aGl0ZXNwYWNlIiwibHRyaW0iLCJSZWdFeHAiLCJydHJpbSIsImNyZWF0ZU1ldGhvZCQxIiwic3RyaW5nVHJpbSIsInRyaW0iLCJuYXRpdmVQYXJzZUZsb2F0IiwicGFyc2VGbG9hdCIsIkZPUkNFRCQxIiwiSW5maW5pdHkiLCJfcGFyc2VGbG9hdCIsInRyaW1tZWRTdHJpbmciLCJjaGFyQXQiLCJOdW1iZXIiLCJjcmVhdGVNZXRob2QkMiIsIlRPX0VOVFJJRVMiLCJvYmplY3RUb0FycmF5IiwiZW50cmllcyIsInZhbHVlcyIsIiRlbnRyaWVzIiwiaXRlcmF0b3JzIiwiSVRFUkFUT1IiLCJBcnJheVByb3RvdHlwZSQxIiwiaXNBcnJheUl0ZXJhdG9yTWV0aG9kIiwiSVRFUkFUT1IkMSIsImdldEl0ZXJhdG9yTWV0aG9kIiwiY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyIsIkVOVFJJRVMiLCJyZXR1cm5NZXRob2QiLCJpdGVyYXRlXzEiLCJSZXN1bHQiLCJzdG9wcGVkIiwiaXRlcmF0ZSIsIml0ZXJhYmxlIiwiQVNfRU5UUklFUyIsIklTX0lURVJBVE9SIiwiYm91bmRGdW5jdGlvbiIsIml0ZXJGbiIsIm5leHQiLCJzdGVwIiwiZG9uZSIsInN0b3AiLCJjcmVhdGVQcm9wZXJ0eSIsInByb3BlcnR5S2V5IiwiZnJvbUVudHJpZXMiLCJvYmoiLCJrIiwidiIsIiR2YWx1ZXMiLCJuYXRpdmVQcm9taXNlQ29uc3RydWN0b3IiLCJQcm9taXNlIiwiSVRFUkFUT1IkMiIsIlNBRkVfQ0xPU0lORyIsImNhbGxlZCIsIml0ZXJhdG9yV2l0aFJldHVybiIsImZyb20iLCJjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24iLCJTS0lQX0NMT1NJTkciLCJJVEVSQVRJT05fU1VQUE9SVCIsInVzZXJBZ2VudCIsImlzSW9zIiwibG9jYXRpb24iLCJzZXQkMiIsInNldEltbWVkaWF0ZSIsImNsZWFyIiwiY2xlYXJJbW1lZGlhdGUiLCJwcm9jZXNzJDEiLCJwcm9jZXNzIiwiTWVzc2FnZUNoYW5uZWwiLCJEaXNwYXRjaCIsImNvdW50ZXIiLCJxdWV1ZSIsIk9OUkVBRFlTVEFURUNIQU5HRSIsImRlZmVyIiwiY2hhbm5lbCIsInBvcnQiLCJydW4iLCJydW5uZXIiLCJsaXN0ZW5lciIsImV2ZW50IiwicG9zdCIsInBvc3RNZXNzYWdlIiwicHJvdG9jb2wiLCJob3N0IiwiYXJncyIsIm5leHRUaWNrIiwibm93IiwicG9ydDIiLCJwb3J0MSIsIm9ubWVzc2FnZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJpbXBvcnRTY3JpcHRzIiwicmVtb3ZlQ2hpbGQiLCJzZXRUaW1lb3V0IiwidGFzayIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciQyIiwibWFjcm90YXNrIiwiTXV0YXRpb25PYnNlcnZlciIsIldlYktpdE11dGF0aW9uT2JzZXJ2ZXIiLCJwcm9jZXNzJDIiLCJQcm9taXNlJDEiLCJJU19OT0RFIiwicXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yIiwicXVldWVNaWNyb3Rhc2siLCJmbHVzaCIsImhlYWQiLCJsYXN0Iiwibm90aWZ5IiwidG9nZ2xlIiwibm9kZSIsInByb21pc2UiLCJ0aGVuIiwicGFyZW50IiwiZXhpdCIsImVudGVyIiwiY3JlYXRlVGV4dE5vZGUiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsInJlc29sdmUiLCJtaWNyb3Rhc2siLCJQcm9taXNlQ2FwYWJpbGl0eSIsInJlamVjdCIsIiQkcmVzb2x2ZSIsIiQkcmVqZWN0IiwiZiQ2IiwibmV3UHJvbWlzZUNhcGFiaWxpdHkiLCJwcm9taXNlUmVzb2x2ZSIsIngiLCJwcm9taXNlQ2FwYWJpbGl0eSIsImhvc3RSZXBvcnRFcnJvcnMiLCJjb25zb2xlIiwicGVyZm9ybSIsInByb2Nlc3MkMyIsInZlcnNpb25zIiwidjgiLCJtYXRjaCIsInY4VmVyc2lvbiIsInRhc2skMSIsIlNQRUNJRVMkMyIsIlBST01JU0UiLCJnZXRJbnRlcm5hbFN0YXRlJDEiLCJzZXRJbnRlcm5hbFN0YXRlJDEiLCJnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSIsIlByb21pc2VDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciQxIiwiZG9jdW1lbnQkMiIsInByb2Nlc3MkNCIsIiRmZXRjaCIsIm5ld1Byb21pc2VDYXBhYmlsaXR5JDEiLCJuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkiLCJJU19OT0RFJDEiLCJESVNQQVRDSF9FVkVOVCIsImNyZWF0ZUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIlVOSEFORExFRF9SRUpFQ1RJT04iLCJSRUpFQ1RJT05fSEFORExFRCIsIlBFTkRJTkciLCJGVUxGSUxMRUQiLCJSRUpFQ1RFRCIsIkhBTkRMRUQiLCJVTkhBTkRMRUQiLCJJbnRlcm5hbCIsIk93blByb21pc2VDYXBhYmlsaXR5IiwiUHJvbWlzZVdyYXBwZXIiLCJuYXRpdmVUaGVuIiwiRk9SQ0VEJDIiLCJHTE9CQUxfQ09SRV9KU19QUk9NSVNFIiwiUHJvbWlzZVJlamVjdGlvbkV2ZW50IiwiRmFrZVByb21pc2UiLCJJTkNPUlJFQ1RfSVRFUkFUSU9OIiwiYWxsIiwiaXNUaGVuYWJsZSIsIm5vdGlmeSQxIiwiaXNSZWplY3QiLCJub3RpZmllZCIsImNoYWluIiwicmVhY3Rpb25zIiwib2siLCJyZWFjdGlvbiIsImhhbmRsZXIiLCJmYWlsIiwiZXhpdGVkIiwicmVqZWN0aW9uIiwib25IYW5kbGVVbmhhbmRsZWQiLCJvblVuaGFuZGxlZCIsInJlYXNvbiIsImluaXRFdmVudCIsIklTX1VOSEFORExFRCIsImlzVW5oYW5kbGVkIiwiZW1pdCIsImJpbmQiLCJ1bndyYXAiLCJpbnRlcm5hbFJlamVjdCIsImludGVybmFsUmVzb2x2ZSIsIndyYXBwZXIiLCJleGVjdXRvciIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsImZldGNoIiwid3JhcCIsInIiLCJjYXBhYmlsaXR5IiwiJHByb21pc2VSZXNvbHZlIiwicmVtYWluaW5nIiwiYWxyZWFkeUNhbGxlZCIsInJhY2UiLCJOT05fR0VORVJJQyIsInJlYWwiLCJvbkZpbmFsbHkiLCJpc0Z1bmN0aW9uIiwiZSIsInN0cmluZ1JlcGVhdCIsInJlcGVhdCIsInN0ciIsIm4iLCJjZWlsJDEiLCJjcmVhdGVNZXRob2QkMyIsIklTX0VORCIsIm1heExlbmd0aCIsImZpbGxTdHJpbmciLCJzdHJpbmdMZW5ndGgiLCJmaWxsU3RyIiwiaW50TWF4TGVuZ3RoIiwiZmlsbExlbiIsInN0cmluZ0ZpbGxlciIsInN0cmluZ1BhZCIsIndlYmtpdFN0cmluZ1BhZEJ1ZyIsIiRwYWRFbmQiLCJwYWRFbmQiLCIkcGFkU3RhcnQiLCJwYWRTdGFydCIsInJlZ2V4cEZsYWdzIiwiaWdub3JlQ2FzZSIsIm11bHRpbGluZSIsImRvdEFsbCIsInVuaWNvZGUiLCJzdGlja3kiLCJSRSIsInMiLCJVTlNVUFBPUlRFRF9ZIiwicmUiLCJsYXN0SW5kZXgiLCJCUk9LRU5fQ0FSRVQiLCJyZWdleHBTdGlja3lIZWxwZXJzIiwibmF0aXZlRXhlYyIsIm5hdGl2ZVJlcGxhY2UiLCJwYXRjaGVkRXhlYyIsIlVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyIsInJlMSIsInJlMiIsIlVOU1VQUE9SVEVEX1kkMSIsIk5QQ0dfSU5DTFVERUQiLCJQQVRDSCIsInJlQ29weSIsImZsYWdzIiwiY2hhcnNBZGRlZCIsInN0ckNvcHkiLCJyZWdleHBFeGVjIiwiU1BFQ0lFUyQ0IiwiUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMiLCJncm91cHMiLCJSRVBMQUNFX0tFRVBTXyQwIiwiU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDIiwib3JpZ2luYWxFeGVjIiwiZml4UmVnZXhwV2VsbEtub3duU3ltYm9sTG9naWMiLCJTWU1CT0wiLCJERUxFR0FURVNfVE9fU1lNQk9MIiwiREVMRUdBVEVTX1RPX0VYRUMiLCJleGVjQ2FsbGVkIiwibmF0aXZlUmVnRXhwTWV0aG9kIiwibWV0aG9kcyIsIm5hdGl2ZU1ldGhvZCIsImFyZzIiLCJmb3JjZVN0cmluZ01ldGhvZCIsInN0cmluZ01ldGhvZCIsInJlZ2V4TWV0aG9kIiwiY3JlYXRlTWV0aG9kJDQiLCJDT05WRVJUX1RPX1NUUklORyIsInBvcyIsInBvc2l0aW9uIiwic2l6ZSIsInNlY29uZCIsImNoYXJDb2RlQXQiLCJzdHJpbmdNdWx0aWJ5dGUiLCJjb2RlQXQiLCJhZHZhbmNlU3RyaW5nSW5kZXgiLCJyZWdleHBFeGVjQWJzdHJhY3QiLCJSIiwibWF4JDEiLCJtaW4kMiIsImZsb29yJDIiLCJTVUJTVElUVVRJT05fU1lNQk9MUyIsIlNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEIiwibWF5YmVUb1N0cmluZyIsIlJFUExBQ0UiLCJtYXliZUNhbGxOYXRpdmUiLCJzZWFyY2hWYWx1ZSIsInJlcGxhY2VWYWx1ZSIsInJlcGxhY2VyIiwicmVzIiwicngiLCJmdW5jdGlvbmFsUmVwbGFjZSIsImZ1bGxVbmljb2RlIiwicmVzdWx0cyIsIm1hdGNoU3RyIiwiYWNjdW11bGF0ZWRSZXN1bHQiLCJuZXh0U291cmNlUG9zaXRpb24iLCJtYXRjaGVkIiwiY2FwdHVyZXMiLCJuYW1lZENhcHR1cmVzIiwicmVwbGFjZXJBcmdzIiwiZ2V0U3Vic3RpdHV0aW9uIiwidGFpbFBvcyIsIm0iLCJzeW1ib2xzIiwiY2giLCJjYXB0dXJlIiwibm9uIiwiZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCIsIiR0cmltIiwiJHRyaW1FbmQiLCJGT1JDRUQkMyIsInRyaW1FbmQiLCJ0cmltUmlnaHQiLCIkdHJpbVN0YXJ0IiwiRk9SQ0VEJDQiLCJ0cmltU3RhcnQiLCJ0cmltTGVmdCIsIk5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMSIsIkFycmF5QnVmZmVyJDMiLCJJbnQ4QXJyYXkkMiIsInR5cGVkQXJyYXlzQ29uc3RydWN0b3JzUmVxdWlyZXNXcmFwcGVycyIsInRvUG9zaXRpdmVJbnRlZ2VyIiwidG9PZmZzZXQiLCJCWVRFUyIsImFUeXBlZEFycmF5Q29uc3RydWN0b3IkMSIsInR5cGVkQXJyYXlGcm9tIiwibWFwZm4iLCJtYXBwaW5nIiwiaXRlcmF0b3JNZXRob2QiLCJjcmVhdGVNZXRob2QkNSIsIklTX01BUCIsIklTX0ZJTFRFUiIsIklTX1NPTUUiLCJJU19FVkVSWSIsIklTX0ZJTkRfSU5ERVgiLCJOT19IT0xFUyIsInNwZWNpZmljQ3JlYXRlIiwiYXJyYXlJdGVyYXRpb24iLCJmb3JFYWNoIiwibWFwIiwiZmlsdGVyIiwic29tZSIsImV2ZXJ5IiwiZmluZCIsImZpbmRJbmRleCIsImluaGVyaXRJZlJlcXVpcmVkIiwiZHVtbXkiLCJXcmFwcGVyIiwiTmV3VGFyZ2V0IiwiTmV3VGFyZ2V0UHJvdG90eXBlIiwidHlwZWRBcnJheUNvbnN0cnVjdG9yIiwicm91bmQiLCJCWVRFU19QRVJfRUxFTUVOVCIsImZyb21MaXN0IiwibGlzdCIsImlzQXJyYXlCdWZmZXIiLCJpc1R5cGVkQXJyYXlJbmRleCIsIndyYXBwZWRHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ3cmFwcGVkRGVmaW5lUHJvcGVydHkiLCJDTEFNUEVEIiwiR0VUVEVSIiwiU0VUVEVSIiwiTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yIiwiVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlIiwiZXhwb3J0ZWQiLCJnZXR0ZXIiLCJhZGRFbGVtZW50IiwiJGxlbmd0aCIsIiRsZW4iLCJ0eXBlZEFycmF5T2Zmc2V0IiwiaW5pdCIsImV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QkMSIsImFUeXBlZEFycmF5Q29uc3RydWN0b3IkMiIsImV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QkMiIsIm9mIiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiZ2VuIiwiX25leHQiLCJfdGhyb3ciLCJpbmZvIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJlcnIiLCJfZGVmaW5lUHJvcGVydHkiLCJvd25LZXlzJDEiLCJlbnVtZXJhYmxlT25seSIsInN5bSIsIl9vYmplY3RTcHJlYWQyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImtOb2RlTW9kdWxlc1JFIiwiY3VzdG9tSW5zcGVjdFN5bWJvbCIsImZvciIsImlzQnVmZmVyIiwiY29sb3JSZWdFeHAiLCJyZW1vdmVDb2xvcnMiLCJpc0Vycm9yIiwiaXNOYXRpdmVFcnJvciIsIkVycm9yIiwiZ2V0U3RydWN0dXJlZFN0YWNrIiwiU3RhY2tUcmFjZUVycm9yIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJ0cmFjZSIsInN0YWNrVHJhY2VMaW1pdCIsImlzSW5zaWRlTm9kZU1vZHVsZXMiLCJzdGFjayIsInN0YWNrRnJhbWVzIiwibGluZXMiLCJsaW5lIiwibGluZUluZm8iLCJmaWxlbmFtZSIsImdldEZpbGVOYW1lIiwiZnJhbWUiLCJvdXRwdXQiLCJzZXBhcmF0b3IiLCJ1bmN1cnJ5VGhpcyIsIkFMTF9QUk9QRVJUSUVTIiwiT05MWV9FTlVNRVJBQkxFIiwicHJvcGVydHlGaWx0ZXIiLCJnZXRPd25Ob25JbmRleFByb3BlcnRpZXMiLCJwcm9wcyIsImlzQWxsRGlnaXRzIiwiY29kZSIsIlR5cGVkQXJyYXlQcm90b3R5cGUkMSIsIlR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY2hlY2tQcm90b3R5cGUiLCJpc0FueUFycmF5QnVmZmVyIiwiaXNTaGFyZWRBcnJheUJ1ZmZlciIsImlzQXJndW1lbnRzT2JqZWN0IiwiaXNBcnJheUJ1ZmZlclZpZXciLCJpc0FzeW5jRnVuY3Rpb24iLCJpc0JpZ0ludDY0QXJyYXkiLCJpc0JpZ1VpbnQ2NEFycmF5IiwiaXNCb29sZWFuT2JqZWN0IiwiaXNCb3hlZFByaW1pdGl2ZSIsImlzTnVtYmVyT2JqZWN0IiwiaXNTdHJpbmdPYmplY3QiLCJpc1N5bWJvbE9iamVjdCIsImlzRGF0YVZpZXciLCJpc0RhdGUiLCJpc0Zsb2F0MzJBcnJheSIsImlzRmxvYXQ2NEFycmF5IiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImlzR2VuZXJhdG9yT2JqZWN0IiwiaXNJbnQ4QXJyYXkiLCJpc0ludDE2QXJyYXkiLCJpc0ludDMyQXJyYXkiLCJpc01hcCIsImlzTWFwSXRlcmF0b3IiLCJpc1Byb21pc2UiLCJpc1JlZ0V4cCIsImlzU2V0IiwiaXNTZXRJdGVyYXRvciIsIlNoYXJlZEFycmF5QnVmZmVyIiwiaXNUeXBlZEFycmF5JDEiLCJpc0J1aWx0SW5UeXBlZEFycmF5IiwiaXNVaW50OEFycmF5IiwiaXNVaW50OENsYW1wZWRBcnJheSIsImlzVWludDE2QXJyYXkiLCJpc1VpbnQzMkFycmF5IiwiaXNXZWFrTWFwIiwiaXNXZWFrU2V0IiwidHlwZXMiLCJmcmVlemUiLCJsYXp5RXJyb3IiLCJjb2RlcyIsIkVSUl9JTlRFUk5BTF9BU1NFUlRJT04iLCJhc3NlcnQiLCJtZXNzYWdlIiwibWVzc2FnZXMiLCJNYXAiLCJTeXN0ZW1FcnJvciIsIkUiLCJkZWYiLCJvdGhlckNsYXNzZXMiLCJtYWtlTm9kZUVycm9yV2l0aENvZGUiLCJjbGF6eiIsIkJhc2UiLCJOb2RlRXJyb3IiLCJnZXRNZXNzYWdlIiwiYWRkQ29kZVRvTmFtZSIsIm1zZyIsImV4cGVjdGVkTGVuZ3RoIiwidW5zaGlmdCIsImZvcm1hdCIsInN1ZmZpeCIsImV4cGVjdGVkIiwiYWN0dWFsIiwiZGV0ZXJtaW5lciIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsIm9uZU9mIiwibWF4U3RhY2tfRXJyb3JOYW1lIiwibWF4U3RhY2tfRXJyb3JNZXNzYWdlIiwiaXNTdGFja092ZXJmbG93RXJyb3IiLCJvdmVyZmxvd1N0YWNrIiwidGhpbmciLCJsZW4iLCJBTExfUFJPUEVSVElFUyQxIiwiT05MWV9FTlVNRVJBQkxFJDEiLCJUSV9DT0RFQ19NQVAiLCJUaSIsIkNvZGVjIiwiQ0hBUlNFVF9VVEY4IiwiQ0hBUlNFVF9VVEYxNkxFIiwiQ0hBUlNFVF9JU09fTEFUSU5fMSIsIkNIQVJTRVRfQVNDSUkiLCJWQUxJRF9FTkNPRElOR1MiLCJkb3VibGVBcnJheSIsInVpbnQ4RG91YmxlQXJyYXkiLCJmbG9hdEFycmF5IiwidWludDhGbG9hdEFycmF5IiwiSU5TUEVDVF9NQVhfQllURVMiLCJCdWZmZXIkMSIsImVuY29kaW5nT3JPZmZzZXQiLCJhcGlOYW1lIiwic2hvd0ZsYWdnZWREZXByZWNhdGlvbiIsImFsbG9jIiwidGlCdWZmZXIiLCJfdGlCdWZmZXIiLCJjb21wYXJlIiwidGFyZ2V0U3RhcnQiLCJ0YXJnZXRFbmQiLCJzb3VyY2VTdGFydCIsInNvdXJjZUVuZCIsImJ1ZjEiLCJzb3VyY2VMZW5ndGgiLCJkZXN0IiwiZGVzdExlbmd0aCIsInRhcmdldFZhbHVlIiwiZ2V0QWRqdXN0ZWRJbmRleCIsInNvdXJjZVZhbHVlIiwiY29weSIsIm5leHRJbmRleCIsImVudHJ5SXRlcmF0b3IiLCJlcXVhbHMiLCJvdGhlckJ1ZmZlciIsImVuY29kaW5nIiwib2Zmc2V0VHlwZSIsInZhbHVlVHlwZSIsImJ1ZlRvRmlsbFdpdGgiLCJmaWxsQnVmTGVuZ3RoIiwiZmlsbENoYXIiLCJpbmRleE9mJDEiLCJtYXRjaExlbmd0aCIsImN1cnJlbnRJbmRleCIsInRoaXNMZW5ndGgiLCJmaXJzdE1hdGNoIiwiZmlyc3RCeXRlTWF0Y2giLCJteUl0ZXJhdG9yIiwicmVhZERvdWJsZUJFIiwiY2hlY2tPZmZzZXQiLCJyZWFkRG91YmxlTEUiLCJyZWFkRmxvYXRCRSIsInJlYWRGbG9hdExFIiwicmVhZEludDgiLCJ1bnNpZ25lZFZhbHVlIiwicmVhZFVJbnQ4IiwidW5zaWduZWRUb1NpZ25lZCIsInJlYWRJbnQxNkJFIiwicmVhZFVJbnQxNkJFIiwicmVhZEludDE2TEUiLCJyZWFkVUludDE2TEUiLCJyZWFkSW50MzJCRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnQzMkxFIiwicmVhZFVJbnQzMkxFIiwicmVhZEludEJFIiwicmVhZFVJbnRCRSIsInJlYWRJbnRMRSIsInJlYWRVSW50TEUiLCJtdWx0aXBsaWVyIiwibmV3QnVmZmVyIiwic3ViYXJyYXkiLCJzd2FwMTYiLCJzZXRBZGp1c3RlZEluZGV4Iiwic3dhcDMyIiwidGhpcmQiLCJmb3VydGgiLCJzd2FwNjQiLCJmaWZ0aCIsInNpeHRoIiwic2V2ZW50aCIsImVpZ2h0aCIsInRvSlNPTiIsImlzRW5jb2RpbmciLCJjbG9uZSIsImJsb2IiLCJVdGlscyIsImJhc2U2NGVuY29kZSIsInRvQmxvYiIsImhleFN0ciIsImhleCIsImxhdGluMVN0cmluZyIsIl9pIiwiZnJvbUNoYXJDb2RlIiwiYXNjaWkiLCJfaTIiLCJidWZmZXJUb1VURjE2U3RyaW5nIiwidG9UaUJ1ZmZlciIsImNvcHlCdWZmZXIiLCJ3cml0ZURvdWJsZUJFIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRmxvYXRMRSIsIndyaXRlSW50OCIsImNoZWNrVmFsdWUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDMyQkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludEJFIiwibWluTWF4QmFzZSIsImJ5dGVWYWx1ZSIsIndyaXRlSW50TEUiLCJ3cml0ZVVJbnQ4Iiwid3JpdGVVSW50MTZCRSIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQzMkJFIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludEJFIiwid3JpdGVVSW50TEUiLCJhbGxvY1Vuc2FmZSIsImNyZWF0ZUJ1ZmZlciIsImFsbG9jVW5zYWZlU2xvdyIsImJ1ZiIsInV0ZjhCeXRlTGVuZ3RoIiwiYnVmMiIsInRvdGFsTGVuZ3RoIiwiX2kzIiwiYmFzZTY0ZGVjb2RlIiwiYmxvYlN0cmVhbSIsIlN0cmVhbSIsImNyZWF0ZVN0cmVhbSIsIk1PREVfUkVBRCIsInJlYWRBbGwiLCJzdHJpbmdUb0hleEJ5dGVzIiwiZ2V0VGlDb2RlY0NoYXJzZXQiLCJfYnVmZmVyIiwiX2xlbmd0aCIsInJlY3Vyc2VUaW1lcyIsImN0eCIsImFjdHVhbE1heCIsImV4dHJhcyIsInNob3dIaWRkZW4iLCJyZWR1Y2UiLCJpbnNwZWN0IiwiYnJlYWtMZW5ndGgiLCJjb21wYWN0IiwicG9vbFNpemUiLCJCdWZmZXJNb2R1bGUiLCJCdWZmZXIiLCJ0cmFuc2NvZGUiLCJfc291cmNlIiwiX2Zyb21FbmNvZGluZyIsIl90b0VuY29kaW5nIiwia01heExlbmd0aCIsImtTdHJpbmdNYXhMZW5ndGgiLCJjb25zdGFudHMiLCJNQVhfTEVOR1RIIiwiTUFYX1NUUklOR19MRU5HVEgiLCJzaW5nbGVCeXRlIiwiYml0TGVuZ3RoIiwibWF4UG9zaXRpdmVWYWx1ZSIsIm1heFVuc2lnbmVkVmFsdWUiLCJzcmNMZW5ndGgiLCJkZXN0SW5kZXgiLCJyZWxlYXNlIiwib3V0IiwiYnl0ZTEiLCJieXRlMiIsImNvZGVfdW5pdCIsImZyb21Db2RlUG9pbnQiLCJieXRlQXJyYXkiLCJudW1lcmljVmFsdWUiLCJwYXJzZUludCIsInN1YnN0ciIsImFycmF5SW5kZXhIYW5kbGVyIiwicHJvcEtleSIsInJlY2VpdmVyIiwibnVtIiwiaXNTYWZlSW50ZWdlciIsIlJlZmxlY3QiLCJQcm94eSIsImVuZE9mZnNldCIsImJ1ZmZlcldhcm5pbmdBbHJlYWR5RW1pdHRlZCIsIm5vZGVNb2R1bGVzQ2hlY2tDb3VudGVyIiwiYnVmZmVyV2FybmluZyIsImVtaXRXYXJuaW5nIiwiQUxMX1BST1BFUlRJRVMkMiIsIk9OTFlfRU5VTUVSQUJMRSQyIiwiQm9vbGVhblByb3RvdHlwZSIsIkJvb2xlYW4iLCJEYXRlUHJvdG90eXBlIiwiRGF0ZSIsIkVycm9yUHJvdG90eXBlIiwiTnVtYmVyUHJvdG90eXBlIiwiTWFwUHJvdG90eXBlIiwiUmVnRXhwUHJvdG90eXBlIiwiU3RyaW5nUHJvdG90eXBlIiwiU2V0UHJvdG90eXBlIiwiU2V0IiwiU3ltYm9sUHJvdG90eXBlIiwiaXNJb3MkMSIsIlBsYXRmb3JtIiwib3NuYW1lIiwiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCJoYXNPd25Qcm9wZXJ0eSQxIiwicHJvcGVydHlJc0VudW1lcmFibGUkMSIsImhleFNsaWNlIiwiYnVpbHRJbk9iamVjdHMiLCJpbnNwZWN0RGVmYXVsdE9wdGlvbnMiLCJzZWFsIiwiY29sb3JzIiwiY3VzdG9tSW5zcGVjdCIsInNob3dQcm94eSIsIm1heEFycmF5TGVuZ3RoIiwic29ydGVkIiwiZ2V0dGVycyIsImtPYmplY3RUeXBlIiwia0FycmF5VHlwZSIsImtBcnJheUV4dHJhc1R5cGUiLCJzdHJFc2NhcGVTZXF1ZW5jZXNSZWdFeHAiLCJzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlciIsInN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cFNpbmdsZSIsInN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyU2luZ2xlIiwia2V5U3RyUmVnRXhwIiwibnVtYmVyUmVnRXhwIiwibm9kZU1vZHVsZXNSZWdFeHAiLCJrTWluTGluZUxlbmd0aCIsImtXZWFrIiwia0l0ZXJhdG9yIiwia01hcEVudHJpZXMiLCJtZXRhIiwiZ2V0VXNlck9wdGlvbnMiLCJzdHlsaXplIiwidXNlck9wdGlvbnMiLCJvcHRzIiwiYnVkZ2V0IiwiaW5kZW50YXRpb25MdmwiLCJzZWVuIiwiY3VycmVudERlcHRoIiwic3R5bGl6ZU5vQ29sb3IiLCJvcHRLZXlzIiwic3R5bGl6ZVdpdGhDb2xvciIsImZvcm1hdFZhbHVlIiwiY3VzdG9tIiwiYXNzaWduIiwiYm9sZCIsIml0YWxpYyIsInVuZGVybGluZSIsImludmVyc2UiLCJ3aGl0ZSIsImdyZXkiLCJibGFjayIsImJsdWUiLCJjeWFuIiwiZ3JlZW4iLCJtYWdlbnRhIiwicmVkIiwieWVsbG93Iiwic3R5bGVzIiwic3BlY2lhbCIsImJpZ2ludCIsImJvb2xlYW4iLCJudWxsIiwiZGF0ZSIsImFkZFF1b3RlcyIsInF1b3RlcyIsImVzY2FwZUZuIiwic3RyRXNjYXBlIiwiZXNjYXBlVGVzdCIsImVzY2FwZVJlcGxhY2UiLCJzaW5nbGVRdW90ZSIsInBvaW50Iiwic3R5bGVUeXBlIiwiY29sb3IiLCJnZXRFbXB0eUZvcm1hdEFycmF5IiwiZ2V0Q29uc3RydWN0b3JOYW1lIiwiX2N0eCIsImZpcnN0UHJvdG8iLCJnZXRQcmVmaXgiLCJmYWxsYmFjayIsImdldEtleXMiLCJnZXRDdHhTdHlsZSIsImZpbmRUeXBlZENvbnN0cnVjdG9yIiwibGF6eU51bGxQcm90b3R5cGVDYWNoZSIsImNsYXp6V2l0aE51bGxQcm90b3R5cGUiLCJjYWNoZWRDbGFzcyIsIk51bGxQcm90b3R5cGUiLCJub1Byb3RvdHlwZUl0ZXJhdG9yIiwibmV3VmFsIiwiX2NsYXp6IiwiX2NsYXp6MiIsIl9jb25zdHJ1Y3RvciIsIl9jbGF6ejMiLCJmb3JtYXRSYXciLCJ0eXBlZEFycmF5IiwiZm9ybWF0UHJpbWl0aXZlIiwiY29udGV4dCIsIm1heWJlQ3VzdG9tIiwicmV0IiwiY2lyY3VsYXIiLCJiYXNlIiwiZm9ybWF0dGVyIiwiYnJhY2VzIiwibm9JdGVyYXRvciIsImV4dHJhc1R5cGUiLCJwcmVmaXgiLCJmb3JtYXRBcnJheSIsIl9wcmVmaXgiLCJmb3JtYXRTZXQiLCJfcHJlZml4MiIsImZvcm1hdE1hcCIsIl9wcmVmaXgzIiwiZm9ybWF0VHlwZWRBcnJheSIsImdldEl0ZXJhdG9yQnJhY2VzIiwiZm9ybWF0SXRlcmF0b3IiLCJnZXRGdW5jdGlvbkJhc2UiLCJyZWdFeHAiLCJfcHJlZml4NCIsImdldFRpbWUiLCJ0b0lTT1N0cmluZyIsIl9wcmVmaXg1IiwiZm9ybWF0RXJyb3IiLCJuYXRpdmVFcnJvclByb3BzIiwiYXJyYXlUeXBlIiwiX3ByZWZpeDYiLCJmb3JtYXRBcnJheUJ1ZmZlciIsImZvcm1hdE51bWJlciIsImZvcm1hdFByb21pc2UiLCJmb3JtYXRXZWFrU2V0IiwiZm9ybWF0V2Vha0NvbGxlY3Rpb24iLCJmb3JtYXRXZWFrTWFwIiwiZ2V0Qm94ZWRCYXNlIiwic3BlY2lhbEl0ZXJhdG9yIiwiY29uc3RydWN0b3JOYW1lIiwiZm9ybWF0UHJvcGVydHkiLCJfY29uc3RydWN0b3JOYW1lIiwiaGFuZGxlTWF4Q2FsbFN0YWNrU2l6ZSIsInJlZmVyZW5jZSIsInBvcCIsImNvbXBhcmF0b3IiLCJzcGxpY2UiLCJyZWR1Y2VUb1NpbmdsZVN0cmluZyIsIm5ld0xlbmd0aCIsInN0YWNrTGluZSIsImF0U3ltYm9sSW5kZXgiLCJzb3VyY2VQYXR0ZXJuIiwic3ltYm9sTmFtZSIsInNvdXJjZU1hdGNoIiwiZmlsZVBhdGgiLCJsaW5lTnVtYmVyIiwiY29sdW1uIiwiRmlsZXN5c3RlbSIsInJlc291cmNlc0RpcmVjdG9yeSIsInN0YWNrU3RhcnQiLCJuZXdTdGFjayIsIl9saW5lcyIsIm5vZGVNb2R1bGUiLCJfcG9zIiwiaW5kZW50YXRpb24iLCJfdmFsdWUiLCJfcmVjdXJzZVRpbWVzIiwiZXh0cmEiLCJkaWZmIiwibGFiZWwiLCJzcCIsInRtcCIsInByaW1pdGl2ZSIsIl90bXAiLCJncm91cEFycmF5RWxlbWVudHMiLCJvdXRwdXRMZW5ndGgiLCJzZXBhcmF0b3JTcGFjZSIsImRhdGFMZW4iLCJhcHByb3hDaGFySGVpZ2h0cyIsImF2ZXJhZ2VCaWFzIiwic3FydCIsImJpYXNlZE1heCIsImNvbHVtbnMiLCJtYXhMaW5lTGVuZ3RoIiwibGluZU1heExlbmd0aCIsIm9yZGVyIiwiX2oiLCJwYWRkaW5nIiwiX3BhZGRpbmciLCJpcyIsImZvcm1hdEJpZ0ludCIsImZvcm1hdFNwZWNpYWxBcnJheSIsImVtcHR5SXRlbXMiLCJlbmRpbmciLCJfZW5kaW5nIiwiX21lc3NhZ2UiLCJ2YWxMZW4iLCJlbGVtZW50Rm9ybWF0dGVyIiwiZm9ybWF0U2V0SXRlcklubmVyIiwiZm9ybWF0TWFwSXRlcklubmVyIiwiX3BvczIiLCJfa2V5cyIsImlzS2V5VmFsdWUiLCJjdXJyZW50RW50cnkiLCJpc0JlbG93QnJlYWtMZW5ndGgiLCJfaW5kZW50YXRpb24iLCJsbiIsImZvcm1hdFdpdGhPcHRpb25zIiwiZmlyc3RFcnJvckxpbmUiLCJDSVJDVUxBUl9FUlJPUl9NRVNTQUdFIiwidHJ5U3RyaW5naWZ5IiwiSlNPTiIsInN0cmluZ2lmeSIsImluc3BlY3RPcHRpb25zIiwidGVtcFN0ciIsImxhc3RQb3MiLCJuZXh0Q2hhciIsInRlbXBBcmciLCJjb25zdHIiLCJ0ZW1wTnVtIiwidGVtcEludGVnZXIiLCJ0ZW1wRmxvYXQiLCJuYXRpdmVEZWJ1ZyIsImRlYnVnIiwibmF0aXZlRXJyb3IiLCJuYXRpdmVJbmZvIiwibmF0aXZlTG9nIiwibmF0aXZlV2FybiIsIndhcm4iLCJrQ29sb3JJbnNwZWN0T3B0aW9ucyIsImtOb0NvbG9ySW5zcGVjdE9wdGlvbnMiLCJwcm9wZXJ0aWVzIiwidGV4dCIsImNvbG9yc2V0Iiwib3NWZXJzaW9uIiwidWlNb2R1bGUiLCJVSSIsIkFuZHJvaWQiLCJrcm9sbCIsImJpbmRpbmciLCJUaXRhbml1bSIsIlNFTUFOVElDX0NPTE9SX1RZUEVfTElHSFQiLCJTRU1BTlRJQ19DT0xPUl9UWVBFX0RBUksiLCJjdXJyZW50Q29sb3JUeXBlIiwiY29sb3JUeXBlIiwiZmV0Y2hTZW1hbnRpY0NvbG9yIiwiY29sb3JOYW1lIiwiQXBwIiwiaU9TIiwiY29sb3JzZXRGaWxlIiwiZ2V0RmlsZSIsImV4aXN0cyIsInBhcnNlIiwicmVhZCIsInNlbWFudGljQ29sb3JUeXBlIiwiX2FkZExpc3RlbmVyIiwiZW1pdHRlciIsImV2ZW50TmFtZSIsInByZXBlbmQiLCJfZXZlbnRzVG9MaXN0ZW5lcnMiLCJuZXdMaXN0ZW5lciIsImV2ZW50TGlzdGVuZXJzIiwiZ2V0TWF4TGlzdGVuZXJzIiwidyIsIm9uY2VXcmFwIiwicmVtb3ZlTGlzdGVuZXIiLCJ3cmFwcGVkRnVuYyIsIndyYXBwZXJUaGlzIiwiYm91bmQiLCJFdmVudEVtaXR0ZXIiLCJfbWF4TGlzdGVuZXJzIiwiYWRkTGlzdGVuZXIiLCJvbiIsInByZXBlbmRMaXN0ZW5lciIsIm9uY2UiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwiZm91bmRJbmRleCIsInVud3JhcHBlZExpc3RlbmVyIiwib2ZmIiwibGlzdGVuZXJDb3VudCIsImV2ZW50TmFtZXMiLCJsaXN0ZW5lcnMiLCJyYXciLCJsIiwicmF3TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsInNldE1heExpc3RlbmVycyIsInJlbW92ZUFsbExpc3RlbmVycyIsImFzc2VydEFyZ3VtZW50VHlwZSIsInR5cGVuYW1lIiwic3RhcnRUaW1lIiwic3RhbmRhcmRpemVBcmNoIiwicHJvY2VzcyQ1IiwiYWJvcnQiLCJhcmNoIiwiYXJjaGl0ZWN0dXJlIiwiYXJndiIsImNoZGlyIiwiY29uZmlnIiwiY29ubmVjdGVkIiwiY3B1VXNhZ2UiLCJ1c2VyIiwic3lzdGVtIiwiY3dkIiwiX19kaXJuYW1lIiwiYXNzZXRzIiwianNvbiIsInJlYWRBc3NldCIsImRlcGxveURhdGEiLCJkZWJ1Z2dlclBvcnQiLCJkaXNjb25uZWN0IiwiZGxvcGVuIiwid2FybmluZyIsImN0b3IiLCJkZXRhaWwiLCJpc0RlcHJlY2F0aW9uIiwibm9EZXByZWNhdGlvbiIsInRocm93RGVwcmVjYXRpb24iLCJsb2FkRW52SnNvbiIsImpzb25GaWxlIiwiQVBJIiwiZW52IiwiZXhlY0FyZ3YiLCJleGVjUGF0aCIsImV4aXRDb2RlIiwicGlkIiwicGxhdGZvcm0iLCJwcGlkIiwic3RkZXJyIiwiaXNUVFkiLCJjaHVuayIsImNhbGxiYWNrIiwic3Rkb3V0IiwidGl0bGUiLCJ0cmFjZURlcHJlY2F0aW9uIiwidW1hc2siLCJ1cHRpbWUiLCJkaWZmTXMiLCJtb2R1bGVzIiwianNjIiwiV0FSTklOR19QUkVGSVgiLCJ1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrIiwiaGFzVW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2siLCJzZXRVbmNhdWdodEV4Y2VwdGlvbkNhcHR1cmVDYWxsYmFjayIsImJhY2t0cmFjZSIsImZpbGVOYW1lIiwic291cmNlTmFtZSIsImNvbHVtbk51bWJlciIsImxpbmVPZmZzZXQiLCJDYWxsYmFja1dpdGhBcmdzIiwiZnVuYyIsImZ1biIsInRpY2tRdWV1ZSIsImltbWVkaWF0ZVF1ZXVlIiwiZHJhaW5pbmdUaWNrUXVldWUiLCJkcmFpblF1ZXVlc1RpbWVvdXQiLCJkcmFpblRpY2tRdWV1ZSIsInRpY2siLCJzaGlmdCIsImRyYWluUXVldWVzIiwiaW1tZWRpYXRlc1JlbWFpbmluZyIsInByb2Nlc3NJbW1lZGlhdGVRdWV1ZSIsImltbWVkaWF0ZURlYWRsaW5lIiwiaW1tZWRpYXRlIiwiRk9SV0FSRF9TTEFTSCIsIkJBQ0tXQVJEX1NMQVNIIiwiaXNXaW5kb3dzRGV2aWNlTmFtZSIsImNoYXJDb2RlIiwiaXNBYnNvbHV0ZSIsImlzUG9zaXgiLCJmaWxlcGF0aCIsImZpcnN0Q2hhciIsInRoaXJkQ2hhciIsImRpcm5hbWUiLCJoYWRUcmFpbGluZyIsImxhc3RJbmRleE9mIiwiZXh0bmFtZSIsImVuZEluZGV4IiwibGFzdEluZGV4V2luMzJTZXBhcmF0b3IiLCJjaGFyIiwiYmFzZW5hbWUiLCJleHQiLCJsYXN0Q2hhckNvZGUiLCJub3JtYWxpemUkMSIsImlzV2luZG93cyIsImhhZExlYWRpbmciLCJpc1VOQyIsInBhcnRzIiwic2VnbWVudCIsIm5vcm1hbGl6ZWQiLCJhc3NlcnRTZWdtZW50Iiwiam9pbiQxIiwicGF0aHMiLCJyZXNvbHZlZCIsImhpdFJvb3QiLCJyZWxhdGl2ZSIsInRvIiwidXBDb3VudCIsInJlbWFpbmluZ1BhdGgiLCJyb290IiwiZGlyIiwiYmFzZUxlbmd0aCIsInRvU3VidHJhY3QiLCJmaXJzdENoYXJDb2RlIiwidGhpcmRDaGFyQ29kZSIsImZvcm1hdCQxIiwicGF0aE9iamVjdCIsInRvTmFtZXNwYWNlZFBhdGgiLCJyZXNvbHZlZFBhdGgiLCJXaW4zMlBhdGgiLCJzZXAiLCJkZWxpbWl0ZXIiLCJQb3NpeFBhdGgiLCJwYXRoJDEiLCJ3aW4zMiIsInBvc2l4IiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJQb3NpeENvbnN0YW50cyIsIlVWX1VEUF9SRVVTRUFERFIiLCJlcnJubyIsIkUyQklHIiwiRUFDQ0VTIiwiRUFERFJJTlVTRSIsIkVBRERSTk9UQVZBSUwiLCJFQUZOT1NVUFBPUlQiLCJFQUdBSU4iLCJFQUxSRUFEWSIsIkVCQURGIiwiRUJBRE1TRyIsIkVCVVNZIiwiRUNBTkNFTEVEIiwiRUNISUxEIiwiRUNPTk5BQk9SVEVEIiwiRUNPTk5SRUZVU0VEIiwiRUNPTk5SRVNFVCIsIkVERUFETEsiLCJFREVTVEFERFJSRVEiLCJFRE9NIiwiRURRVU9UIiwiRUVYSVNUIiwiRUZBVUxUIiwiRUZCSUciLCJFSE9TVFVOUkVBQ0giLCJFSURSTSIsIkVJTFNFUSIsIkVJTlBST0dSRVNTIiwiRUlOVFIiLCJFSU5WQUwiLCJFSU8iLCJFSVNDT05OIiwiRUlTRElSIiwiRUxPT1AiLCJFTUZJTEUiLCJFTUxJTksiLCJFTVNHU0laRSIsIkVNVUxUSUhPUCIsIkVOQU1FVE9PTE9ORyIsIkVORVRET1dOIiwiRU5FVFJFU0VUIiwiRU5FVFVOUkVBQ0giLCJFTkZJTEUiLCJFTk9CVUZTIiwiRU5PREFUQSIsIkVOT0RFViIsIkVOT0VOVCIsIkVOT0VYRUMiLCJFTk9MQ0siLCJFTk9MSU5LIiwiRU5PTUVNIiwiRU5PTVNHIiwiRU5PUFJPVE9PUFQiLCJFTk9TUEMiLCJFTk9TUiIsIkVOT1NUUiIsIkVOT1NZUyIsIkVOT1RDT05OIiwiRU5PVERJUiIsIkVOT1RFTVBUWSIsIkVOT1RTT0NLIiwiRU5PVFNVUCIsIkVOT1RUWSIsIkVOWElPIiwiRU9QTk9UU1VQUCIsIkVPVkVSRkxPVyIsIkVQRVJNIiwiRVBJUEUiLCJFUFJPVE8iLCJFUFJPVE9OT1NVUFBPUlQiLCJFUFJPVE9UWVBFIiwiRVJBTkdFIiwiRVJPRlMiLCJFU1BJUEUiLCJFU1JDSCIsIkVTVEFMRSIsIkVUSU1FIiwiRVRJTUVET1VUIiwiRVRYVEJTWSIsIkVXT1VMREJMT0NLIiwiRVhERVYiLCJzaWduYWxzIiwiU0lHSFVQIiwiU0lHSU5UIiwiU0lHUVVJVCIsIlNJR0lMTCIsIlNJR1RSQVAiLCJTSUdBQlJUIiwiU0lHSU9UIiwiU0lHQlVTIiwiU0lHRlBFIiwiU0lHS0lMTCIsIlNJR1VTUjEiLCJTSUdTRUdWIiwiU0lHVVNSMiIsIlNJR1BJUEUiLCJTSUdBTFJNIiwiU0lHVEVSTSIsIlNJR0NITEQiLCJTSUdDT05UIiwiU0lHU1RPUCIsIlNJR1RTVFAiLCJTSUdUVElOIiwiU0lHVFRPVSIsIlNJR1VSRyIsIlNJR1hDUFUiLCJTSUdYRlNaIiwiU0lHVlRBTFJNIiwiU0lHUFJPRiIsIlNJR1dJTkNIIiwiU0lHSU8iLCJTSUdJTkZPIiwiU0lHU1lTIiwicHJpb3JpdHkiLCJQUklPUklUWV9MT1ciLCJQUklPUklUWV9CRUxPV19OT1JNQUwiLCJQUklPUklUWV9OT1JNQUwiLCJQUklPUklUWV9BQk9WRV9OT1JNQUwiLCJQUklPUklUWV9ISUdIIiwiUFJJT1JJVFlfSElHSEVTVCIsIk9TIiwiRU9MIiwiY3B1cyIsInByb2Nlc3NvckNvdW50IiwiYXJyYXkiLCJtb2RlbCIsInNwZWVkIiwidGltZXMiLCJuaWNlIiwic3lzIiwiaWRsZSIsImlycSIsImVuZGlhbm5lc3MiLCJnZXROYXRpdmVCeXRlT3JkZXIiLCJMSVRUTEVfRU5ESUFOIiwiZnJlZW1lbSIsImF2YWlsYWJsZU1lbW9yeSIsImdldFByaW9yaXR5IiwiaG9tZWRpciIsImFwcGxpY2F0aW9uRGF0YURpcmVjdG9yeSIsImhvc3RuYW1lIiwiYWRkcmVzcyIsImxvYWRhdmciLCJuZXR3b3JrSW50ZXJmYWNlcyIsInNldFByaW9yaXR5IiwidG1wZGlyIiwidGVtcERpcmVjdG9yeSIsInRvdGFsbWVtIiwidG90YWxNZW1vcnkiLCJ1c2VySW5mbyIsImd1aWQiLCJ1c2VybmFtZSIsInNoZWxsIiwiQXBwbGVNYXAiLCJjcHVNb2RlbEFuZFNwZWVkIiwidHJpbW1lZCIsIm1vZGVsQW5kU3BlZWQiLCJ0dHkiLCJpc2F0dHkiLCJSZWFkU3RyZWFtIiwiV3JpdGVTdHJlYW0iLCJNT05USFMiLCJ1dGlsIiwiaXNCb29sZWFuIiwiaXNOdWxsIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc051bWJlciIsImlzUHJpbWl0aXZlIiwiaXNTdHJpbmciLCJpc1N5bWJvbCIsImlzVW5kZWZpbmVkIiwidGltZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJwcmludCIsInB1dHMiLCJpbmhlcml0cyIsInN1cGVyQ29uc3RydWN0b3IiLCJwcm9taXNpZnkiLCJ3cmFwcGVkIiwiY2FsbGJhY2tpZnkiLCJjYXRjaCIsIndyYXBwZWRFcnJvciIsImRlcHJlY2F0ZSIsIndhcm5lZCIsIm5vb3AiLCJkZWJ1Z2xvZyIsIkRFRkFVTFRfTUVTU0FHRVMiLCJkZWVwU3RyaWN0RXF1YWwiLCJzdHJpY3RFcXVhbCIsImRlZXBFcXVhbCIsImVxdWFsIiwibm90RGVlcFN0cmljdEVxdWFsIiwibm90U3RyaWN0RXF1YWwiLCJub3REZWVwRXF1YWwiLCJub3RFcXVhbCIsIkNPTVBBUkVfVFlQRSIsIlNUUklDVE5FU1MiLCJTdHJpY3QiLCJMb29zZSIsIkFzc2VydGlvbkVycm9yIiwib3BlcmF0b3IiLCJnZW5lcmF0ZWRNZXNzYWdlIiwiYXNzZXJ0JDEiLCJ0aHJvd0Vycm9yIiwiY29tcGFyZU1hcHMiLCJzdHJpY3RuZXNzIiwicmVmZXJlbmNlcyIsImxvb3NlQ2hlY2tzIiwiYWRkIiwiZXhwZWN0ZWRLZXkiLCJleHBlY3RlZFZhbHVlIiwiZm91bmQiLCJfa2V5IiwiZGVsZXRlIiwiY29tcGFyZVNldHMiLCJhY3R1YWxUYWciLCJleHBlY3RlZFRhZyIsImFjdHVhbFByb3RvdHlwZSIsImV4cGVjdGVkUHJvdG90eXBlIiwiY29tcGFyaXNvbiIsImFjdHVhbEtleXMiLCJleHBlY3RlZEtleXMiLCJhY3R1YWxTeW1ib2xzIiwiZXhwZWN0ZWRTeW1ib2xzIiwiYWN0dWFsSXNFbnVtZXJhYmxlIiwiZXhwZWN0ZWRJc0VudW1lcmFibGUiLCJtZW1vaXplZEFjdHVhbCIsIm1lbW9pemVkRXhwZWN0ZWQiLCJfa2V5MiIsIk5PX0VYQ0VQVElPTiIsImV4ZWN1dGUiLCJpc1Byb21pc2VMaWtlIiwiZXhlY3V0ZVByb21pc2UiLCJfeCIsIl9leGVjdXRlUHJvbWlzZSIsImZuVHlwZSIsInRocm93cyIsImNoZWNrRXJyb3IiLCJyZWplY3RzIiwiX3JlZiIsImFzeW5jRm4iLCJfeDIiLCJfeDMiLCJfeDQiLCJkb2VzTm90VGhyb3ciLCJkb2VzTm90UmVqZWN0IiwiX3JlZjIiLCJfeDUiLCJfeDYiLCJfeDciLCJpZkVycm9yIiwic3RyaWN0IiwiU3RyaW5nRGVjb2RlciIsIl9pbXBsIiwiVXRmOFN0cmluZ0RlY29kZXIiLCJVdGYxNlN0cmluZ0RlY29kZXIiLCJCYXNlNjRTdHJpbmdEZWNvZGVyIiwiU3RyaW5nRGVjb2RlckltcGwiLCJieXRlQ291bnQiLCJjaGFyTGVuZ3RoIiwiTXVsdGlCeXRlU3RyaW5nRGVjb2RlckltcGwiLCJieXRlc1BlckNoYXIiLCJpbmNvbXBsZXRlIiwiX2NoZWNrSW5jb21wbGV0ZUJ5dGVzIiwiX2luY29tcGxldGVFbmQiLCJfaW5jb21wbGV0ZUJ1ZmZlckVtcHRpZWQiLCJsZWZ0IiwiYnl0ZXNDb3BpZWQiLCJpbmNvbXBsZXRlQ2hhckRhdGEiLCJieXRlc05lZWRlZCIsImluY29tcGxldGVDaGFySW5kZXgiLCJieXRlc1RvQ29weSIsImNoZWNrQ2hhckxlbmd0aEZvclVURjgiLCJfY2hhckxlbmd0aCIsIl9jaGFyTGVuZ3RoMiIsIm1vZHVsbyIsImJ5dGUiLCJTdHJpbmdEZWNvZGVyJDEiLCJpc0FuZHJvaWQkMSIsInByaW50ZWRXYXJuaW5ncyIsIm9uZVRpbWVXYXJuaW5nIiwidW5zdXBwb3J0ZWROb29wIiwibW9kdWxlTmFtZSIsImZxbiIsImFzeW5jVW5zdXBwb3J0ZWROb29wIiwibWF5YmVDYWxsYmFjayIsIkNPUFlfRklMRV9DSFVOS19TSVpFIiwiZmlsZURlc2NyaXB0b3JzIiwiZmlsZURlc2NyaXB0b3JDb3VudCIsIkZMQUdTX1RPX1RJX01PREUiLCJNT0RFX0FQUEVORCIsIk1PREVfV1JJVEUiLCJwZXJtaXNzaW9uRGVuaWVkIiwic3lzY2FsbCIsIm1ha2VFcnJvciIsIm5vU3VjaEZpbGUiLCJmaWxlQWxyZWFkeUV4aXN0cyIsIm5vdEFEaXJlY3RvcnkiLCJkaXJlY3RvcnlOb3RFbXB0eSIsImlsbGVnYWxPcGVyYXRpb25PbkFEaXJlY3RvcnkiLCJmcyIsIk9fUkRPTkxZIiwiT19XUk9OTFkiLCJPX1JEV1IiLCJTX0lGTVQiLCJTX0lGUkVHIiwiU19JRkRJUiIsIlNfSUZDSFIiLCJTX0lGQkxLIiwiU19JRklGTyIsIlNfSUZMTksiLCJTX0lGU09DSyIsIk9fQ1JFQVQiLCJPX0VYQ0wiLCJPX05PQ1RUWSIsIk9fVFJVTkMiLCJPX0FQUEVORCIsIk9fRElSRUNUT1JZIiwiT19OT0ZPTExPVyIsIk9fU1lOQyIsIk9fRFNZTkMiLCJPX1NZTUxJTksiLCJPX05PTkJMT0NLIiwiU19JUldYVSIsIlNfSVJVU1IiLCJTX0lXVVNSIiwiU19JWFVTUiIsIlNfSVJXWEciLCJTX0lSR1JQIiwiU19JV0dSUCIsIlNfSVhHUlAiLCJTX0lSV1hPIiwiU19JUk9USCIsIlNfSVdPVEgiLCJTX0lYT1RIIiwiRl9PSyIsIlJfT0siLCJXX09LIiwiWF9PSyIsIlVWX0ZTX0NPUFlGSUxFX0VYQ0wiLCJDT1BZRklMRV9FWENMIiwiU3RhdHMiLCJfZmlsZSIsImRldiIsImlubyIsIm5saW5rIiwiZ2lkIiwicmRldiIsImJsa3NpemUiLCJibG9ja3MiLCJhdGltZU1zIiwibXRpbWVNcyIsImN0aW1lTXMiLCJiaXJ0aHRpbWVNcyIsImF0aW1lIiwibXRpbWUiLCJjdGltZSIsImJpcnRodGltZSIsImdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlIiwiY3JlYXRlZEF0IiwibW9kaWZpZWRBdCIsImlzRmlsZSIsImlzRGlyZWN0b3J5IiwiaXNCbG9ja0RldmljZSIsImlzQ2hhcmFjdGVyRGV2aWNlIiwiaXNTeW1ib2xpY0xpbmsiLCJzeW1ib2xpY0xpbmsiLCJpc0ZJRk8iLCJpc1NvY2tldCIsImFjY2VzcyIsImFjY2Vzc1N5bmMiLCJmaWxlSGFuZGxlIiwiZXhlY3V0YWJsZSIsImFwcGVuZEZpbGUiLCJmaWxlIiwibWVyZ2VEZWZhdWx0T3B0aW9ucyIsImZsYWciLCJ3cml0ZUZpbGUiLCJhcHBlbmRGaWxlU3luYyIsIndyaXRlRmlsZVN5bmMiLCJjaG1vZCIsImNobW9kU3luYyIsImZkIiwiY2xvc2VTeW5jIiwic3RyZWFtIiwic3RyZWFtRm9yRGVzY3JpcHRvciIsImNvcHlGaWxlIiwic3JjRmlsZSIsInNyY1N0cmVhbSIsImRlc3RGaWxlIiwiZGVzdFN0cmVhbSIsInBpcGUiLCJjb3B5RmlsZVN5bmMiLCJleGlzdHNTeW5jIiwiZmNobW9kIiwiZmNobW9kU3luYyIsImZjaG93biIsImZjaG93blN5bmMiLCJmZGF0YXN5bmMiLCJmZGF0YXN5bmNTeW5jIiwiZnN0YXQiLCJzdGF0cyIsImZzdGF0U3luYyIsIl9vcHRpb25zIiwicGF0aEZvckZpbGVEZXNjcmlwdG9yIiwic3RhdFN5bmMiLCJsc3RhdCIsImxzdGF0U3luYyIsIm1rZGlyIiwicmVjdXJzaXZlIiwibWtkaXJTeW5jIiwidGlGaWxlIiwiY3JlYXRlRGlyZWN0b3J5IiwibWtkdGVtcCIsInRyeU1rZHRlbXAiLCJnZW5lcmF0ZWQiLCJyYW5kb21DaGFyYWN0ZXJzIiwibWtkdGVtcFN5bmMiLCJyZXRyeUNvdW50IiwiTUFYX1JFVFJJRVMiLCJfcGF0aCIsImZpbGVEZXNjcmlwdG9yIiwib3BlblN5bmMiLCJfbW9kZSIsImNyZWF0ZUZpbGUiLCJ0aU1vZGUiLCJjcmVhdGVGaWxlRGVzY3JpcHRvciIsInRpRmlsZVN0cmVhbSIsInJlYWRPYmoiLCJzdWNjZXNzIiwiYnl0ZXNQcm9jZXNzZWQiLCJyZWFkU3luYyIsIl9wb3NpdGlvbiIsImZpbGVTdHJlYW0iLCJyZWFkZGlyIiwicmVhZGRpclN5bmMiLCJ3aXRoRmlsZVR5cGVzIiwibGlzdGluZyIsImdldERpcmVjdG9yeUxpc3RpbmciLCJyZWFkRmlsZVBvc3RPcGVuIiwiZmlsZVNpemUiLCJzb3VyY2VTdHJlYW0iLCJyZWFkQWxsT2JqIiwicmVhZEZpbGUiLCJ3YXNGaWxlRGVzY3JpcHRvciIsImhhbmRsZUJ1ZmZlciIsImVuY29kZUJ1ZmZlciIsInJlYWRGaWxlU3luYyIsInJlYWxwYXRoIiwicmVzdWx0RXhpc3RzIiwic2VnbWVudHMiLCJwYXJ0aWFsRmlsZVBhdGgiLCJ0cnlQYXRoIiwicGFydGlhbEV4aXN0cyIsInJlYWxwYXRoU3luYyIsInJlbmFtZSIsIm9sZFBhdGgiLCJuZXdQYXRoIiwicmVuYW1lU3luYyIsIl9lcnIyIiwidGVtcFBhdGgiLCJtb3ZlIiwidW5saW5rIiwiX2VyciIsInRtcEZpbGUiLCJybWRpciIsInJtZGlyU3luYyIsImRlbGV0ZURpcmVjdG9yeSIsInN1YkZpbGVzIiwic3ltbGluayIsInN5bWxpbmtTeW5jIiwidHJ1bmNhdGUiLCJieXRlc1JlYWQiLCJ0cnVuY2F0ZVN5bmMiLCJ1bmxpbmtTeW5jIiwiZGVsZXRlRmlsZSIsInVud2F0Y2hGaWxlIiwidXRpbWVzIiwidXRpbWVzU3luYyIsIndhdGNoIiwid2F0Y2hGaWxlIiwiZmluaXNoIiwid3JpdGVTeW5jIiwid3JpdGVUaUZpbGVTdHJlYW0iLCJ3cml0ZU9iaiIsIndyaXRlQnVmZmVyIiwid3JpdGVTdHJpbmciLCJ3cml0ZUJ1ZmZlclN5bmMiLCJ3cml0ZVN0cmluZ1N5bmMiLCJGaWxlRGVzY3JpcHRvciIsInBpcGVWaWFXcml0ZVN0cmVhbSIsInBpcGVWaWFQdW1wIiwid3JpdGVTdHJlYW0iLCJwdW1wIiwiYnl0ZXNXcml0dGVuIiwiYnl0ZXNXcml0dGVuVGhpc0NodW5rIiwicG9pbnRlciIsImRlZmF1bHRzIiwib3B0aW9uc1R5cGUiLCJtZXJnZWQiLCJjYiIsIl9lbmNvZGluZyIsImJpbmRpbmdzIiwicmVkaXJlY3RzIiwiaXNIaWphY2thYmxlTW9kdWxlSWQiLCJvcmlnaW5hbFJlcXVpcmUiLCJyZXF1aXJlIiwibW9kdWxlSWQiLCJvcmlnaW5hbE1vZHVsZVJlcXVpcmUiLCJNb2R1bGUiLCJyZWdpc3RlciIsInJlZGlyZWN0IiwiZmV0Y2hTY3JpcHRzRnJvbUpzb24iLCJKU09OX0ZJTEVfTkFNRSIsInNldHRpbmdzIiwic2NyaXB0cyIsImZldGNoU2NyaXB0c0Zyb21SZXNvdXJjZXNEaXJlY3RvcnkiLCJyZXNvdXJjZURpcmVjdG9yeSIsInJlc291cmNlRGlyZWN0b3J5UGF0aExlbmd0aCIsIm5hdGl2ZVBhdGgiLCJib290c3RyYXBTY3JpcHRzIiwibG9hZEZyb20iLCJmaWxlTmFtZUFycmF5Iiwic2VhcmNoIiwiYm9vdHN0cmFwUGF0aCIsImxvYWRBc3luYyIsImZpbmlzaGVkIiwibG9hZEJvb3RzdHJhcFNjcmlwdHMiLCJib290c3RyYXBJbmRleCIsImRvTG9hZCIsImJvb3RzdHJhcCIsIm9uQm9vdHN0cmFwRXhlY3V0aW9uRmluaXNoZWQiLCJmaXJlRXZlbnQiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLElBQUlBLGNBQWMsR0FBRyxPQUFPQyxVQUFQLEtBQXNCLFdBQXRCLEdBQW9DQSxVQUFwQyxHQUFpRCxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5QyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5QyxPQUFPQyxJQUFQLEtBQWdCLFdBQWhCLEdBQThCQSxJQUE5QixHQUFxQyxFQUE3TDs7QUFFQSxTQUFTQyxvQkFBVCxDQUE4QkMsRUFBOUIsRUFBa0NDLE1BQWxDLEVBQTBDO0FBQ3pDLFNBQU9BLE1BQU0sR0FBRyxFQUFFQyxPQUFPLEVBQUUsRUFBWCxFQUFULEVBQTBCRixFQUFF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QUFJLEdBQUcsQ0FBQyxTQUFELEVBQVksU0FBWixFQUF1QixTQUF2QixFQUFrQyxTQUFsQyxFQUE2QyxTQUE3QyxFQUF3RCxTQUF4RCxFQUFtRSxTQUFuRSxFQUE4RSxTQUE5RSxFQUF5RixLQUF6RixFQUFnRyxLQUFoRyxFQUF1RyxLQUF2RyxFQUE4RyxTQUE5RyxFQUF5SCxLQUF6SCxFQUFnSSxLQUFoSSxFQUF1SSxTQUF2SSxFQUFrSixTQUFsSixFQUE2SixTQUE3SixFQUF3SyxTQUF4SyxFQUFtTCxTQUFuTCxFQUE4TCxTQUE5TCxFQUF5TSxTQUF6TSxFQUFvTixTQUFwTixFQUErTixTQUEvTixFQUEwTyxTQUExTyxFQUFxUCxTQUFyUCxFQUFnUSxTQUFoUSxFQUEyUSxTQUEzUSxFQUFzUixTQUF0UixFQUFpUyxTQUFqUyxFQUE0UyxTQUE1UyxFQUF1VCxTQUF2VCxFQUFrVSxTQUFsVSxFQUE2VSxFQUE3VSxFQUFpVixFQUFqVixFQUFxVixFQUFyVixFQUF5VixFQUF6VixFQUE2VixFQUE3VixFQUFpVyxFQUFqVyxFQUFxVyxFQUFyVyxFQUF5VyxLQUF6VyxFQUFnWCxFQUFoWCxFQUFvWCxFQUFwWCxFQUF3WCxFQUF4WCxFQUE0WCxFQUE1WCxFQUFnWSxFQUFoWSxFQUFvWSxFQUFwWSxFQUF3WSxFQUF4WSxFQUE0WSxFQUE1WSxFQUFnWixFQUFoWixFQUFvWixFQUFwWixFQUF3WixFQUF4WixFQUE0WixFQUE1WixFQUFnYSxFQUFoYSxFQUFvYSxFQUFwYSxFQUF3YSxFQUF4YSxFQUE0YSxFQUE1YSxFQUFnYixFQUFoYixFQUFvYixFQUFwYixFQUF3YixFQUF4YixFQUE0YixFQUE1YixFQUFnYyxFQUFoYyxFQUFvYyxFQUFwYyxFQUF3YyxFQUF4YyxFQUE0YyxFQUE1YyxFQUFnZCxFQUFoZCxFQUFvZCxFQUFwZCxFQUF3ZCxFQUF4ZCxFQUE0ZCxFQUE1ZCxFQUFnZSxFQUFoZSxFQUFvZSxFQUFwZSxFQUF3ZSxFQUF4ZSxFQUE0ZSxFQUE1ZSxFQUFnZixFQUFoZixFQUFvZixFQUFwZixFQUF3ZixF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QUFBLE9BQU8sQ0FBQyxzQkFBRCxDQUFQO0FBQ0QsQ0FGRCxDQUVFLE9BQU9sNUMsQ0FBUCxFQUFVLENBQUUsQyxDQUFDO0FBQ2ZxNkMsU0FBUyxDQUFDLFlBQVk7QUFDcEI7QUFDQTtBQUNBbkIsRUFBQUEsT0FBTyxDQUFDLE9BQUQsQ0FBUCxDQUhvQixDQUdGO0FBQ2xCO0FBQ0E7OztBQUdBcm1DLEVBQUFBLEVBQUUsQ0FBQzJiLEdBQUgsQ0FBT29zQixTQUFQLENBQWlCLFNBQWpCO0FBQ0QsQ0FUUSxDQUFUIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWxfMSA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fFxuICBjaGVjayh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdykgfHxcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIGZhaWxzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbnZhciBkZXNjcmlwdG9ycyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cbnZhciBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmICFuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxudmFyIGYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6IG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG52YXIgb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUgPSB7XG5cdGY6IGZcbn07XG5cbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciBjbGFzc29mUmF3ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG52YXIgc3BsaXQgPSAnJy5zcGxpdDtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBpbmRleGVkT2JqZWN0ID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgcmV0dXJuICFPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mUmF3KGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0LmNhbGwoaXQsICcnKSA6IE9iamVjdChpdCk7XG59IDogT2JqZWN0O1xuXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcblxuXG5cbnZhciB0b0luZGV4ZWRPYmplY3QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpO1xufTtcblxudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xudmFyIHRvUHJpbWl0aXZlID0gZnVuY3Rpb24gKGlucHV0LCBQUkVGRVJSRURfU1RSSU5HKSB7XG4gIGlmICghaXNPYmplY3QoaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUFJFRkVSUkVEX1NUUklORyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpbnB1dC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUFJFRkVSUkVEX1NUUklORyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cbnZhciBoYXMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cbnZhciBkb2N1bWVudCQxID0gZ2xvYmFsXzEuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudCQxKSAmJiBpc09iamVjdChkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQpO1xuXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBFWElTVFMgPyBkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG4vLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG52YXIgaWU4RG9tRGVmaW5lID0gIWRlc2NyaXB0b3JzICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT0gNztcbn0pO1xuXG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxudmFyIGYkMSA9IGRlc2NyaXB0b3JzID8gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoaWU4RG9tRGVmaW5lKSB0cnkge1xuICAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSB7XG5cdGY6IGYkMVxufTtcblxudmFyIGFuT2JqZWN0ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhpdCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG52YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG52YXIgZiQyID0gZGVzY3JpcHRvcnMgPyBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChpZThEb21EZWZpbmUpIHRyeSB7XG4gICAgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxudmFyIG9iamVjdERlZmluZVByb3BlcnR5ID0ge1xuXHRmOiBmJDJcbn07XG5cbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBkZXNjcmlwdG9ycyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIG9iamVjdERlZmluZVByb3BlcnR5LmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbnZhciBzZXRHbG9iYWwgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShnbG9iYWxfMSwga2V5LCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsXzFba2V5XSA9IHZhbHVlO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbF8xW1NIQVJFRF0gfHwgc2V0R2xvYmFsKFNIQVJFRCwge30pO1xuXG52YXIgc2hhcmVkU3RvcmUgPSBzdG9yZTtcblxudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSBGdW5jdGlvbi50b1N0cmluZztcblxuLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGAzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICh0eXBlb2Ygc2hhcmVkU3RvcmUuaW5zcGVjdFNvdXJjZSAhPSAnZnVuY3Rpb24nKSB7XG4gIHNoYXJlZFN0b3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZy5jYWxsKGl0KTtcbiAgfTtcbn1cblxudmFyIGluc3BlY3RTb3VyY2UgPSBzaGFyZWRTdG9yZS5pbnNwZWN0U291cmNlO1xuXG52YXIgV2Vha01hcCA9IGdsb2JhbF8xLldlYWtNYXA7XG5cbnZhciBuYXRpdmVXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KGluc3BlY3RTb3VyY2UoV2Vha01hcCkpO1xuXG52YXIgc2hhcmVkID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHNoYXJlZFN0b3JlW2tleV0gfHwgKHNoYXJlZFN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjYuMScsXG4gIG1vZGU6ICAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxOSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xufSk7XG5cbnZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG5cbnZhciB1aWQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyBTdHJpbmcoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNik7XG59O1xuXG52YXIga2V5cyA9IHNoYXJlZCgna2V5cycpO1xuXG52YXIgc2hhcmVkS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG52YXIgaGlkZGVuS2V5cyA9IHt9O1xuXG52YXIgV2Vha01hcCQxID0gZ2xvYmFsXzEuV2Vha01hcDtcbnZhciBzZXQsIGdldCwgaGFzJDE7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMkMShpdCkgPyBnZXQoaXQpIDogc2V0KGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0KGl0KSB8fCAoc3RhdGUgPSBnZXQoaXQpKS50eXBlICE9PSBUWVBFKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAobmF0aXZlV2Vha01hcCkge1xuICB2YXIgc3RvcmUkMSA9IG5ldyBXZWFrTWFwJDEoKTtcbiAgdmFyIHdtZ2V0ID0gc3RvcmUkMS5nZXQ7XG4gIHZhciB3bWhhcyA9IHN0b3JlJDEuaGFzO1xuICB2YXIgd21zZXQgPSBzdG9yZSQxLnNldDtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIHdtc2V0LmNhbGwoc3RvcmUkMSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldC5jYWxsKHN0b3JlJDEsIGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzJDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMuY2FsbChzdG9yZSQxLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXMoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMkMSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXMoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxudmFyIGludGVybmFsU3RhdGUgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMkMSxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cbnZhciByZWRlZmluZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZS5nZXQ7XG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlLmVuZm9yY2U7XG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB1bnNhZmUgPSBvcHRpb25zID8gISFvcHRpb25zLnVuc2FmZSA6IGZhbHNlO1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5lbnVtZXJhYmxlIDogZmFsc2U7XG4gIHZhciBub1RhcmdldEdldCA9IG9wdGlvbnMgPyAhIW9wdGlvbnMubm9UYXJnZXRHZXQgOiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgJiYgIWhhcyh2YWx1ZSwgJ25hbWUnKSkgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHZhbHVlLCAnbmFtZScsIGtleSk7XG4gICAgZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/IGtleSA6ICcnKTtcbiAgfVxuICBpZiAoTyA9PT0gZ2xvYmFsXzEpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIHNldEdsb2JhbChrZXksIHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoIXVuc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gIH0gZWxzZSBpZiAoIW5vVGFyZ2V0R2V0ICYmIE9ba2V5XSkge1xuICAgIHNpbXBsZSA9IHRydWU7XG4gIH1cbiAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gIGVsc2UgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KE8sIGtleSwgdmFsdWUpO1xuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlKHRoaXMpO1xufSk7XG59KTtcblxudmFyIHBhdGggPSBnbG9iYWxfMTtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICByZXR1cm4gdHlwZW9mIHZhcmlhYmxlID09ICdmdW5jdGlvbicgPyB2YXJpYWJsZSA6IHVuZGVmaW5lZDtcbn07XG5cbnZhciBnZXRCdWlsdEluID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihwYXRoW25hbWVzcGFjZV0pIHx8IGFGdW5jdGlvbihnbG9iYWxfMVtuYW1lc3BhY2VdKVxuICAgIDogcGF0aFtuYW1lc3BhY2VdICYmIHBhdGhbbmFtZXNwYWNlXVttZXRob2RdIHx8IGdsb2JhbF8xW25hbWVzcGFjZV0gJiYgZ2xvYmFsXzFbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgVG9JbnRlZ2VyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvaW50ZWdlclxudmFyIHRvSW50ZWdlciA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNOYU4oYXJndW1lbnQgPSArYXJndW1lbnQpID8gMCA6IChhcmd1bWVudCA+IDAgPyBmbG9vciA6IGNlaWwpKGFyZ3VtZW50KTtcbn07XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG52YXIgdG9MZW5ndGggPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXIoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4kMSA9IE1hdGgubWluO1xuXG4vLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcbi8vIExldCBpbnRlZ2VyIGJlID8gVG9JbnRlZ2VyKGluZGV4KS5cbi8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGludGVnZXIsIGxlbmd0aCkuXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4kMShpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbnZhciBhcnJheUluY2x1ZGVzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG5cbnZhciBpbmRleE9mID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xuXG5cbnZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhcyhoaWRkZW5LZXlzLCBrZXkpICYmIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG52YXIgZW51bUJ1Z0tleXMgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuXG52YXIgaGlkZGVuS2V5cyQxID0gZW51bUJ1Z0tleXMuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xudmFyIGYkMyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gb2JqZWN0S2V5c0ludGVybmFsKE8sIGhpZGRlbktleXMkMSk7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyA9IHtcblx0ZjogZiQzXG59O1xuXG52YXIgZiQ0ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IHtcblx0ZjogZiQ0XG59O1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgb3duS2V5cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scy5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcblxudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXModGFyZ2V0LCBrZXkpKSBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gIH1cbn07XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogdHlwZW9mIGRldGVjdGlvbiA9PSAnZnVuY3Rpb24nID8gZmFpbHMoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5cbnZhciBpc0ZvcmNlZF8xID0gaXNGb3JjZWQ7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mO1xuXG5cblxuXG5cblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5ub1RhcmdldEdldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiovXG52YXIgX2V4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gIGlmIChHTE9CQUwpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxfMTtcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxfMVtUQVJHRVRdIHx8IHNldEdsb2JhbChUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsXzFbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMubm9UYXJnZXRHZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSh0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZF8xKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxuXG52YXIgTmF0aXZlU3ltYm9sID0gZ2xvYmFsXzEuU3ltYm9sO1xuXG5pZiAoZGVzY3JpcHRvcnMgJiYgdHlwZW9mIE5hdGl2ZVN5bWJvbCA9PSAnZnVuY3Rpb24nICYmICghKCdkZXNjcmlwdGlvbicgaW4gTmF0aXZlU3ltYm9sLnByb3RvdHlwZSkgfHxcbiAgLy8gU2FmYXJpIDEyIGJ1Z1xuICBOYXRpdmVTeW1ib2woKS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkXG4pKSB7XG4gIHZhciBFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmUgPSB7fTtcbiAgLy8gd3JhcCBTeW1ib2wgY29uc3RydWN0b3IgZm9yIGNvcnJlY3Qgd29yayB3aXRoIHVuZGVmaW5lZCBkZXNjcmlwdGlvblxuICB2YXIgU3ltYm9sV3JhcHBlciA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDwgMSB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IFN0cmluZyhhcmd1bWVudHNbMF0pO1xuICAgIHZhciByZXN1bHQgPSB0aGlzIGluc3RhbmNlb2YgU3ltYm9sV3JhcHBlclxuICAgICAgPyBuZXcgTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKVxuICAgICAgLy8gaW4gRWRnZSAxMywgU3RyaW5nKFN5bWJvbCh1bmRlZmluZWQpKSA9PT0gJ1N5bWJvbCh1bmRlZmluZWQpJ1xuICAgICAgOiBkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkID8gTmF0aXZlU3ltYm9sKCkgOiBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pO1xuICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gJycpIEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZVtyZXN1bHRdID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKFN5bWJvbFdyYXBwZXIsIE5hdGl2ZVN5bWJvbCk7XG4gIHZhciBzeW1ib2xQcm90b3R5cGUgPSBTeW1ib2xXcmFwcGVyLnByb3RvdHlwZSA9IE5hdGl2ZVN5bWJvbC5wcm90b3R5cGU7XG4gIHN5bWJvbFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN5bWJvbFdyYXBwZXI7XG5cbiAgdmFyIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgbmF0aXZlID0gU3RyaW5nKE5hdGl2ZVN5bWJvbCgndGVzdCcpKSA9PSAnU3ltYm9sKHRlc3QpJztcbiAgdmFyIHJlZ2V4cCA9IC9eU3ltYm9sXFwoKC4qKVxcKVteKV0rJC87XG4gIGRlZmluZVByb3BlcnR5KHN5bWJvbFByb3RvdHlwZSwgJ2Rlc2NyaXB0aW9uJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgdmFyIHN5bWJvbCA9IGlzT2JqZWN0KHRoaXMpID8gdGhpcy52YWx1ZU9mKCkgOiB0aGlzO1xuICAgICAgdmFyIHN0cmluZyA9IHN5bWJvbFRvU3RyaW5nLmNhbGwoc3ltYm9sKTtcbiAgICAgIGlmIChoYXMoRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlLCBzeW1ib2wpKSByZXR1cm4gJyc7XG4gICAgICB2YXIgZGVzYyA9IG5hdGl2ZSA/IHN0cmluZy5zbGljZSg3LCAtMSkgOiBzdHJpbmcucmVwbGFjZShyZWdleHAsICckMScpO1xuICAgICAgcmV0dXJuIGRlc2MgPT09ICcnID8gdW5kZWZpbmVkIDogZGVzYztcbiAgICB9XG4gIH0pO1xuXG4gIF9leHBvcnQoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCB7XG4gICAgU3ltYm9sOiBTeW1ib2xXcmFwcGVyXG4gIH0pO1xufVxuXG52YXIgbmF0aXZlU3ltYm9sID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICByZXR1cm4gIVN0cmluZyhTeW1ib2woKSk7XG59KTtcblxudmFyIHVzZVN5bWJvbEFzVWlkID0gbmF0aXZlU3ltYm9sXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAmJiAhU3ltYm9sLnNoYW1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG5cbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xudmFyIFN5bWJvbCQxID0gZ2xvYmFsXzEuU3ltYm9sO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IHVzZVN5bWJvbEFzVWlkID8gU3ltYm9sJDEgOiBTeW1ib2wkMSAmJiBTeW1ib2wkMS53aXRob3V0U2V0dGVyIHx8IHVpZDtcblxudmFyIHdlbGxLbm93blN5bWJvbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkpIHtcbiAgICBpZiAobmF0aXZlU3ltYm9sICYmIGhhcyhTeW1ib2wkMSwgbmFtZSkpIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbCQxW25hbWVdO1xuICAgIGVsc2UgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKCdTeW1ib2wuJyArIG5hbWUpO1xuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG52YXIgZiQ1ID0gd2VsbEtub3duU3ltYm9sO1xuXG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbCA9IHtcblx0ZjogZiQ1XG59O1xuXG52YXIgZGVmaW5lUHJvcGVydHkkMSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSBmdW5jdGlvbiAoTkFNRSkge1xuICB2YXIgU3ltYm9sID0gcGF0aC5TeW1ib2wgfHwgKHBhdGguU3ltYm9sID0ge30pO1xuICBpZiAoIWhhcyhTeW1ib2wsIE5BTUUpKSBkZWZpbmVQcm9wZXJ0eSQxKFN5bWJvbCwgTkFNRSwge1xuICAgIHZhbHVlOiB3cmFwcGVkV2VsbEtub3duU3ltYm9sLmYoTkFNRSlcbiAgfSk7XG59O1xuXG4vLyBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wuYXN5bmNpdGVyYXRvclxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdhc3luY0l0ZXJhdG9yJyk7XG5cbi8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY2xhc3NvZlJhdyhhcmcpID09ICdBcnJheSc7XG59O1xuXG52YXIgYUZ1bmN0aW9uJDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhpdCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYmluZENvbnRleHQgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24kMShmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0KTtcbiAgICB9O1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuLy8gYEZsYXR0ZW5JbnRvQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtRmxhdHRlbkludG9BcnJheVxudmFyIGZsYXR0ZW5JbnRvQXJyYXkgPSBmdW5jdGlvbiAodGFyZ2V0LCBvcmlnaW5hbCwgc291cmNlLCBzb3VyY2VMZW4sIHN0YXJ0LCBkZXB0aCwgbWFwcGVyLCB0aGlzQXJnKSB7XG4gIHZhciB0YXJnZXRJbmRleCA9IHN0YXJ0O1xuICB2YXIgc291cmNlSW5kZXggPSAwO1xuICB2YXIgbWFwRm4gPSBtYXBwZXIgPyBiaW5kQ29udGV4dChtYXBwZXIsIHRoaXNBcmcsIDMpIDogZmFsc2U7XG4gIHZhciBlbGVtZW50O1xuXG4gIHdoaWxlIChzb3VyY2VJbmRleCA8IHNvdXJjZUxlbikge1xuICAgIGlmIChzb3VyY2VJbmRleCBpbiBzb3VyY2UpIHtcbiAgICAgIGVsZW1lbnQgPSBtYXBGbiA/IG1hcEZuKHNvdXJjZVtzb3VyY2VJbmRleF0sIHNvdXJjZUluZGV4LCBvcmlnaW5hbCkgOiBzb3VyY2Vbc291cmNlSW5kZXhdO1xuXG4gICAgICBpZiAoZGVwdGggPiAwICYmIGlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICAgICAgdGFyZ2V0SW5kZXggPSBmbGF0dGVuSW50b0FycmF5KHRhcmdldCwgb3JpZ2luYWwsIGVsZW1lbnQsIHRvTGVuZ3RoKGVsZW1lbnQubGVuZ3RoKSwgdGFyZ2V0SW5kZXgsIGRlcHRoIC0gMSkgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhcmdldEluZGV4ID49IDB4MUZGRkZGRkZGRkZGRkYpIHRocm93IFR5cGVFcnJvcignRXhjZWVkIHRoZSBhY2NlcHRhYmxlIGFycmF5IGxlbmd0aCcpO1xuICAgICAgICB0YXJnZXRbdGFyZ2V0SW5kZXhdID0gZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0SW5kZXgrKztcbiAgICB9XG4gICAgc291cmNlSW5kZXgrKztcbiAgfVxuICByZXR1cm4gdGFyZ2V0SW5kZXg7XG59O1xuXG52YXIgZmxhdHRlbkludG9BcnJheV8xID0gZmxhdHRlbkludG9BcnJheTtcblxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG52YXIgdG9PYmplY3QgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XG59O1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG4vLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5LCBsZW5ndGgpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsQXJyYXkpKSB7XG4gICAgQyA9IG9yaWdpbmFsQXJyYXkuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGVsc2UgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gbmV3IChDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEMpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xufTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5mbGF0YCBtZXRob2Rcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWZsYXRNYXBcbl9leHBvcnQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlIH0sIHtcbiAgZmxhdDogZnVuY3Rpb24gZmxhdCgvKiBkZXB0aEFyZyA9IDEgKi8pIHtcbiAgICB2YXIgZGVwdGhBcmcgPSBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkO1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHNvdXJjZUxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICBBLmxlbmd0aCA9IGZsYXR0ZW5JbnRvQXJyYXlfMShBLCBPLCBPLCBzb3VyY2VMZW4sIDAsIGRlcHRoQXJnID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoQXJnKSk7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZsYXRNYXBgIG1ldGhvZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZmxhdE1hcFxuX2V4cG9ydCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUgfSwge1xuICBmbGF0TWFwOiBmdW5jdGlvbiBmbGF0TWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgc291cmNlTGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBBO1xuICAgIGFGdW5jdGlvbiQxKGNhbGxiYWNrZm4pO1xuICAgIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgQS5sZW5ndGggPSBmbGF0dGVuSW50b0FycmF5XzEoQSwgTywgTywgc291cmNlTGVuLCAwLCAxLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG52YXIgbmF0aXZlUmV2ZXJzZSA9IFtdLnJldmVyc2U7XG52YXIgdGVzdCA9IFsxLCAyXTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5yZXZlcnNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZXZlcnNlXG4vLyBmaXggZm9yIFNhZmFyaSAxMi4wIGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4ODc5NFxuX2V4cG9ydCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogU3RyaW5nKHRlc3QpID09PSBTdHJpbmcodGVzdC5yZXZlcnNlKCkpIH0sIHtcbiAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICBpZiAoaXNBcnJheSh0aGlzKSkgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gbmF0aXZlUmV2ZXJzZS5jYWxsKHRoaXMpO1xuICB9XG59KTtcblxudmFyIHNsb3BweUFycmF5TWV0aG9kID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBhcmd1bWVudCkge1xuICB2YXIgbWV0aG9kID0gW11bTUVUSE9EX05BTUVdO1xuICByZXR1cm4gIW1ldGhvZCB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGwsbm8tdGhyb3ctbGl0ZXJhbFxuICAgIG1ldGhvZC5jYWxsKG51bGwsIGFyZ3VtZW50IHx8IGZ1bmN0aW9uICgpIHsgdGhyb3cgMTsgfSwgMSk7XG4gIH0pO1xufTtcblxudmFyIHRlc3QkMSA9IFtdO1xudmFyIG5hdGl2ZVNvcnQgPSB0ZXN0JDEuc29ydDtcblxuLy8gSUU4LVxudmFyIEZBSUxTX09OX1VOREVGSU5FRCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdGVzdCQxLnNvcnQodW5kZWZpbmVkKTtcbn0pO1xuLy8gVjggYnVnXG52YXIgRkFJTFNfT05fTlVMTCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdGVzdCQxLnNvcnQobnVsbCk7XG59KTtcbi8vIE9sZCBXZWJLaXRcbnZhciBTTE9QUFlfTUVUSE9EID0gc2xvcHB5QXJyYXlNZXRob2QoJ3NvcnQnKTtcblxudmFyIEZPUkNFRCA9IEZBSUxTX09OX1VOREVGSU5FRCB8fCAhRkFJTFNfT05fTlVMTCB8fCBTTE9QUFlfTUVUSE9EO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvcnRcbl9leHBvcnQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkXG4gICAgICA/IG5hdGl2ZVNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSlcbiAgICAgIDogbmF0aXZlU29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpLCBhRnVuY3Rpb24kMShjb21wYXJlZm4pKTtcbiAgfVxufSk7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIG9iamVjdEtleXNJbnRlcm5hbChPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbnZhciBvYmplY3REZWZpbmVQcm9wZXJ0aWVzID0gZGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgb2JqZWN0RGVmaW5lUHJvcGVydHkuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBQcm9wZXJ0aWVzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG5cbnZhciBodG1sID0gZ2V0QnVpbHRJbignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG5cbnZhciBHVCA9ICc+JztcbnZhciBMVCA9ICc8JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbnZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIEFjdGl2ZVggT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuICBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsOyAvLyBhdm9pZCBtZW1vcnkgbGVha1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgKi9cbiAgICBhY3RpdmVYRG9jdW1lbnQgPSBkb2N1bWVudC5kb21haW4gJiYgbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGlnbm9yZSAqLyB9XG4gIE51bGxQcm90b09iamVjdCA9IGFjdGl2ZVhEb2N1bWVudCA/IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KSA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpO1xuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IG9iamVjdERlZmluZVByb3BlcnRpZXMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cbnZhciBVTlNDT1BBQkxFUyA9IHdlbGxLbm93blN5bWJvbCgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuaWYgKEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHtcbiAgb2JqZWN0RGVmaW5lUHJvcGVydHkuZihBcnJheVByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IG9iamVjdENyZWF0ZShudWxsKVxuICB9KTtcbn1cblxuLy8gYWRkIGEga2V5IHRvIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG5cbi8vIHRoaXMgbWV0aG9kIHdhcyBhZGRlZCB0byB1bnNjb3BhYmxlcyBhZnRlciBpbXBsZW1lbnRhdGlvblxuLy8gaW4gcG9wdWxhciBlbmdpbmVzLCBzbyBpdCdzIG1vdmVkIHRvIGEgc2VwYXJhdGUgbW9kdWxlXG5cblxuYWRkVG9VbnNjb3BhYmxlcygnZmxhdCcpO1xuXG4vLyB0aGlzIG1ldGhvZCB3YXMgYWRkZWQgdG8gdW5zY29wYWJsZXMgYWZ0ZXIgaW1wbGVtZW50YXRpb25cbi8vIGluIHBvcHVsYXIgZW5naW5lcywgc28gaXQncyBtb3ZlZCB0byBhIHNlcGFyYXRlIG1vZHVsZVxuXG5cbmFkZFRvVW5zY29wYWJsZXMoJ2ZsYXRNYXAnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCQyID0ge307XG5cbnRlc3QkMltUT19TVFJJTkdfVEFHXSA9ICd6JztcblxudmFyIHRvU3RyaW5nVGFnU3VwcG9ydCA9IFN0cmluZyh0ZXN0JDIpID09PSAnW29iamVjdCB6XSc7XG5cbnZhciBUT19TVFJJTkdfVEFHJDEgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxudmFyIGNsYXNzb2YgPSB0b1N0cmluZ1RhZ1N1cHBvcnQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRyQxKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcblxudmFyIGNvcnJlY3RQcm90b3R5cGVHZXR0ZXIgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcblxudmFyIElFX1BST1RPJDEgPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2ZcbnZhciBvYmplY3RHZXRQcm90b3R5cGVPZiA9IGNvcnJlY3RQcm90b3R5cGVHZXR0ZXIgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8kMSkpIHJldHVybiBPW0lFX1BST1RPJDFdO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG59O1xuXG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpICYmIGl0ICE9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3Qgc2V0IFwiICsgU3RyaW5nKGl0KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIG9iamVjdFNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG4gIHRyeSB7XG4gICAgc2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0O1xuICAgIHNldHRlci5jYWxsKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICBhbk9iamVjdChPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyLmNhbGwoTywgcHJvdG8pO1xuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQyID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxuXG5cblxuXG52YXIgRGF0YVZpZXcgPSBnbG9iYWxfMS5EYXRhVmlldztcbnZhciBEYXRhVmlld1Byb3RvdHlwZSA9IERhdGFWaWV3ICYmIERhdGFWaWV3LnByb3RvdHlwZTtcbnZhciBJbnQ4QXJyYXkkMSA9IGdsb2JhbF8xLkludDhBcnJheTtcbnZhciBJbnQ4QXJyYXlQcm90b3R5cGUgPSBJbnQ4QXJyYXkkMSAmJiBJbnQ4QXJyYXkkMS5wcm90b3R5cGU7XG52YXIgVWludDhDbGFtcGVkQXJyYXkkMSA9IGdsb2JhbF8xLlVpbnQ4Q2xhbXBlZEFycmF5O1xudmFyIFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlID0gVWludDhDbGFtcGVkQXJyYXkkMSAmJiBVaW50OENsYW1wZWRBcnJheSQxLnByb3RvdHlwZTtcbnZhciBUeXBlZEFycmF5ID0gSW50OEFycmF5JDEgJiYgb2JqZWN0R2V0UHJvdG90eXBlT2YoSW50OEFycmF5JDEpO1xudmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBJbnQ4QXJyYXlQcm90b3R5cGUgJiYgb2JqZWN0R2V0UHJvdG90eXBlT2YoSW50OEFycmF5UHJvdG90eXBlKTtcbnZhciBPYmplY3RQcm90b3R5cGUkMSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaXNQcm90b3R5cGVPZiA9IE9iamVjdFByb3RvdHlwZSQxLmlzUHJvdG90eXBlT2Y7XG5cbnZhciBUT19TVFJJTkdfVEFHJDIgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgVFlQRURfQVJSQVlfVEFHID0gdWlkKCdUWVBFRF9BUlJBWV9UQUcnKTtcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSID0gISEoZ2xvYmFsXzEuQXJyYXlCdWZmZXIgJiYgRGF0YVZpZXcpO1xuLy8gRml4aW5nIG5hdGl2ZSB0eXBlZCBhcnJheXMgaW4gT3BlcmEgUHJlc3RvIGNyYXNoZXMgdGhlIGJyb3dzZXIsIHNlZSAjNTk1XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyA9IE5BVElWRV9BUlJBWV9CVUZGRVIgJiYgISFvYmplY3RTZXRQcm90b3R5cGVPZiAmJiBjbGFzc29mKGdsb2JhbF8xLm9wZXJhKSAhPT0gJ09wZXJhJztcbnZhciBUWVBFRF9BUlJBWV9UQUdfUkVRSVJFRCA9IGZhbHNlO1xudmFyIE5BTUU7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcbiAgSW50OEFycmF5OiAxLFxuICBVaW50OEFycmF5OiAxLFxuICBVaW50OENsYW1wZWRBcnJheTogMSxcbiAgSW50MTZBcnJheTogMixcbiAgVWludDE2QXJyYXk6IDIsXG4gIEludDMyQXJyYXk6IDQsXG4gIFVpbnQzMkFycmF5OiA0LFxuICBGbG9hdDMyQXJyYXk6IDQsXG4gIEZsb2F0NjRBcnJheTogOFxufTtcblxudmFyIGlzVmlldyA9IGZ1bmN0aW9uIGlzVmlldyhpdCkge1xuICB2YXIga2xhc3MgPSBjbGFzc29mKGl0KTtcbiAgcmV0dXJuIGtsYXNzID09PSAnRGF0YVZpZXcnIHx8IGhhcyhUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpO1xufTtcblxudmFyIGlzVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIGhhcyhUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwgY2xhc3NvZihpdCkpO1xufTtcblxudmFyIGFUeXBlZEFycmF5ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc1R5cGVkQXJyYXkoaXQpKSByZXR1cm4gaXQ7XG4gIHRocm93IFR5cGVFcnJvcignVGFyZ2V0IGlzIG5vdCBhIHR5cGVkIGFycmF5Jyk7XG59O1xuXG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChDKSB7XG4gIGlmIChvYmplY3RTZXRQcm90b3R5cGVPZikge1xuICAgIGlmIChpc1Byb3RvdHlwZU9mLmNhbGwoVHlwZWRBcnJheSwgQykpIHJldHVybiBDO1xuICB9IGVsc2UgZm9yICh2YXIgQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIGlmIChoYXMoVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIE5BTUUpKSB7XG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbF8xW0FSUkFZXTtcbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIChDID09PSBUeXBlZEFycmF5Q29uc3RydWN0b3IgfHwgaXNQcm90b3R5cGVPZi5jYWxsKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgQykpKSB7XG4gICAgICByZXR1cm4gQztcbiAgICB9XG4gIH0gdGhyb3cgVHlwZUVycm9yKCdUYXJnZXQgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3InKTtcbn07XG5cbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gZnVuY3Rpb24gKEtFWSwgcHJvcGVydHksIGZvcmNlZCkge1xuICBpZiAoIWRlc2NyaXB0b3JzKSByZXR1cm47XG4gIGlmIChmb3JjZWQpIGZvciAodmFyIEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbF8xW0FSUkFZXTtcbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIGhhcyhUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlLCBLRVkpKSB7XG4gICAgICBkZWxldGUgVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZVtLRVldO1xuICAgIH1cbiAgfVxuICBpZiAoIVR5cGVkQXJyYXlQcm90b3R5cGVbS0VZXSB8fCBmb3JjZWQpIHtcbiAgICByZWRlZmluZShUeXBlZEFycmF5UHJvdG90eXBlLCBLRVksIGZvcmNlZCA/IHByb3BlcnR5XG4gICAgICA6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgJiYgSW50OEFycmF5UHJvdG90eXBlW0tFWV0gfHwgcHJvcGVydHkpO1xuICB9XG59O1xuXG52YXIgZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZCA9IGZ1bmN0aW9uIChLRVksIHByb3BlcnR5LCBmb3JjZWQpIHtcbiAgdmFyIEFSUkFZLCBUeXBlZEFycmF5Q29uc3RydWN0b3I7XG4gIGlmICghZGVzY3JpcHRvcnMpIHJldHVybjtcbiAgaWYgKG9iamVjdFNldFByb3RvdHlwZU9mKSB7XG4gICAgaWYgKGZvcmNlZCkgZm9yIChBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsXzFbQVJSQVldO1xuICAgICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBoYXMoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVkpKSB7XG4gICAgICAgIGRlbGV0ZSBUeXBlZEFycmF5Q29uc3RydWN0b3JbS0VZXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFUeXBlZEFycmF5W0tFWV0gfHwgZm9yY2VkKSB7XG4gICAgICAvLyBWOCB+IENocm9tZSA0OS01MCBgJVR5cGVkQXJyYXklYCBtZXRob2RzIGFyZSBub24td3JpdGFibGUgbm9uLWNvbmZpZ3VyYWJsZVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlZGVmaW5lKFR5cGVkQXJyYXksIEtFWSwgZm9yY2VkID8gcHJvcGVydHkgOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIEludDhBcnJheSQxW0tFWV0gfHwgcHJvcGVydHkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICAgIH0gZWxzZSByZXR1cm47XG4gIH1cbiAgZm9yIChBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbF8xW0FSUkFZXTtcbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmICghVHlwZWRBcnJheUNvbnN0cnVjdG9yW0tFWV0gfHwgZm9yY2VkKSkge1xuICAgICAgcmVkZWZpbmUoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVksIHByb3BlcnR5KTtcbiAgICB9XG4gIH1cbn07XG5cbmZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICBpZiAoIWdsb2JhbF8xW05BTUVdKSBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTID0gZmFsc2U7XG59XG5cbi8vIFdlYktpdCBidWcgLSB0eXBlZCBhcnJheXMgY29uc3RydWN0b3JzIHByb3RvdHlwZSBpcyBPYmplY3QucHJvdG90eXBlXG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgfHwgdHlwZW9mIFR5cGVkQXJyYXkgIT0gJ2Z1bmN0aW9uJyB8fCBUeXBlZEFycmF5ID09PSBGdW5jdGlvbi5wcm90b3R5cGUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICBUeXBlZEFycmF5ID0gZnVuY3Rpb24gVHlwZWRBcnJheSgpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG4gIH07XG4gIGlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTKSBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICBpZiAoZ2xvYmFsXzFbTkFNRV0pIG9iamVjdFNldFByb3RvdHlwZU9mKGdsb2JhbF8xW05BTUVdLCBUeXBlZEFycmF5KTtcbiAgfVxufVxuXG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgfHwgIVR5cGVkQXJyYXlQcm90b3R5cGUgfHwgVHlwZWRBcnJheVByb3RvdHlwZSA9PT0gT2JqZWN0UHJvdG90eXBlJDEpIHtcbiAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkucHJvdG90eXBlO1xuICBpZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgaWYgKGdsb2JhbF8xW05BTUVdKSBvYmplY3RTZXRQcm90b3R5cGVPZihnbG9iYWxfMVtOQU1FXS5wcm90b3R5cGUsIFR5cGVkQXJyYXlQcm90b3R5cGUpO1xuICB9XG59XG5cbi8vIFdlYktpdCBidWcgLSBvbmUgbW9yZSBvYmplY3QgaW4gVWludDhDbGFtcGVkQXJyYXkgcHJvdG90eXBlIGNoYWluXG5pZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyAmJiBvYmplY3RHZXRQcm90b3R5cGVPZihVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSkgIT09IFR5cGVkQXJyYXlQcm90b3R5cGUpIHtcbiAgb2JqZWN0U2V0UHJvdG90eXBlT2YoVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUsIFR5cGVkQXJyYXlQcm90b3R5cGUpO1xufVxuXG5pZiAoZGVzY3JpcHRvcnMgJiYgIWhhcyhUeXBlZEFycmF5UHJvdG90eXBlLCBUT19TVFJJTkdfVEFHJDIpKSB7XG4gIFRZUEVEX0FSUkFZX1RBR19SRVFJUkVEID0gdHJ1ZTtcbiAgZGVmaW5lUHJvcGVydHkkMihUeXBlZEFycmF5UHJvdG90eXBlLCBUT19TVFJJTkdfVEFHJDIsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHRoaXMpID8gdGhpc1tUWVBFRF9BUlJBWV9UQUddIDogdW5kZWZpbmVkO1xuICB9IH0pO1xuICBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIGlmIChnbG9iYWxfMVtOQU1FXSkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShnbG9iYWxfMVtOQU1FXSwgVFlQRURfQVJSQVlfVEFHLCBOQU1FKTtcbiAgfVxufVxuXG4vLyBXZWJLaXQgYnVnIC0gdGhlIHNhbWUgcGFyZW50IHByb3RvdHlwZSBmb3IgdHlwZWQgYXJyYXlzIGFuZCBkYXRhIHZpZXdcbmlmIChOQVRJVkVfQVJSQVlfQlVGRkVSICYmIG9iamVjdFNldFByb3RvdHlwZU9mICYmIG9iamVjdEdldFByb3RvdHlwZU9mKERhdGFWaWV3UHJvdG90eXBlKSAhPT0gT2JqZWN0UHJvdG90eXBlJDEpIHtcbiAgb2JqZWN0U2V0UHJvdG90eXBlT2YoRGF0YVZpZXdQcm90b3R5cGUsIE9iamVjdFByb3RvdHlwZSQxKTtcbn1cblxudmFyIGFycmF5QnVmZmVyVmlld0NvcmUgPSB7XG4gIE5BVElWRV9BUlJBWV9CVUZGRVI6IE5BVElWRV9BUlJBWV9CVUZGRVIsXG4gIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1M6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MsXG4gIFRZUEVEX0FSUkFZX1RBRzogVFlQRURfQVJSQVlfVEFHX1JFUUlSRUQgJiYgVFlQRURfQVJSQVlfVEFHLFxuICBhVHlwZWRBcnJheTogYVR5cGVkQXJyYXksXG4gIGFUeXBlZEFycmF5Q29uc3RydWN0b3I6IGFUeXBlZEFycmF5Q29uc3RydWN0b3IsXG4gIGV4cG9ydFR5cGVkQXJyYXlNZXRob2Q6IGV4cG9ydFR5cGVkQXJyYXlNZXRob2QsXG4gIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2Q6IGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QsXG4gIGlzVmlldzogaXNWaWV3LFxuICBpc1R5cGVkQXJyYXk6IGlzVHlwZWRBcnJheSxcbiAgVHlwZWRBcnJheTogVHlwZWRBcnJheSxcbiAgVHlwZWRBcnJheVByb3RvdHlwZTogVHlwZWRBcnJheVByb3RvdHlwZVxufTtcblxudmFyIHJlZGVmaW5lQWxsID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgYW5JbnN0YW5jZSA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCAnICsgKG5hbWUgPyBuYW1lICsgJyAnIDogJycpICsgJ2ludm9jYXRpb24nKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG4vLyBgVG9JbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2luZGV4XG52YXIgdG9JbmRleCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIHZhciBudW1iZXIgPSB0b0ludGVnZXIoaXQpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgobnVtYmVyKTtcbiAgaWYgKG51bWJlciAhPT0gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBsZW5ndGggb3IgaW5kZXgnKTtcbiAgcmV0dXJuIGxlbmd0aDtcbn07XG5cbi8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93LXJlc3RyaWN0ZWQtbmFtZXNcbnZhciBJbmZpbml0eSQxID0gMSAvIDA7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgZmxvb3IkMSA9IE1hdGguZmxvb3I7XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG5cbnZhciBwYWNrID0gZnVuY3Rpb24gKG51bWJlciwgbWFudGlzc2FMZW5ndGgsIGJ5dGVzKSB7XG4gIHZhciBidWZmZXIgPSBuZXcgQXJyYXkoYnl0ZXMpO1xuICB2YXIgZXhwb25lbnRMZW5ndGggPSBieXRlcyAqIDggLSBtYW50aXNzYUxlbmd0aCAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZXhwb25lbnRMZW5ndGgpIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSBtYW50aXNzYUxlbmd0aCA9PT0gMjMgPyBwb3coMiwgLTI0KSAtIHBvdygyLCAtNzcpIDogMDtcbiAgdmFyIHNpZ24gPSBudW1iZXIgPCAwIHx8IG51bWJlciA9PT0gMCAmJiAxIC8gbnVtYmVyIDwgMCA/IDEgOiAwO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgZXhwb25lbnQsIG1hbnRpc3NhLCBjO1xuICBudW1iZXIgPSBhYnMobnVtYmVyKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICBpZiAobnVtYmVyICE9IG51bWJlciB8fCBudW1iZXIgPT09IEluZmluaXR5JDEpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgbWFudGlzc2EgPSBudW1iZXIgIT0gbnVtYmVyID8gMSA6IDA7XG4gICAgZXhwb25lbnQgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGV4cG9uZW50ID0gZmxvb3IkMShsb2cobnVtYmVyKSAvIExOMik7XG4gICAgaWYgKG51bWJlciAqIChjID0gcG93KDIsIC1leHBvbmVudCkpIDwgMSkge1xuICAgICAgZXhwb25lbnQtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGV4cG9uZW50ICsgZUJpYXMgPj0gMSkge1xuICAgICAgbnVtYmVyICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtYmVyICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmIChudW1iZXIgKiBjID49IDIpIHtcbiAgICAgIGV4cG9uZW50Kys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmIChleHBvbmVudCArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG1hbnRpc3NhID0gMDtcbiAgICAgIGV4cG9uZW50ID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGV4cG9uZW50ICsgZUJpYXMgPj0gMSkge1xuICAgICAgbWFudGlzc2EgPSAobnVtYmVyICogYyAtIDEpICogcG93KDIsIG1hbnRpc3NhTGVuZ3RoKTtcbiAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbWFudGlzc2EgPSBudW1iZXIgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtYW50aXNzYUxlbmd0aCk7XG4gICAgICBleHBvbmVudCA9IDA7XG4gICAgfVxuICB9XG4gIGZvciAoOyBtYW50aXNzYUxlbmd0aCA+PSA4OyBidWZmZXJbaW5kZXgrK10gPSBtYW50aXNzYSAmIDI1NSwgbWFudGlzc2EgLz0gMjU2LCBtYW50aXNzYUxlbmd0aCAtPSA4KTtcbiAgZXhwb25lbnQgPSBleHBvbmVudCA8PCBtYW50aXNzYUxlbmd0aCB8IG1hbnRpc3NhO1xuICBleHBvbmVudExlbmd0aCArPSBtYW50aXNzYUxlbmd0aDtcbiAgZm9yICg7IGV4cG9uZW50TGVuZ3RoID4gMDsgYnVmZmVyW2luZGV4KytdID0gZXhwb25lbnQgJiAyNTUsIGV4cG9uZW50IC89IDI1NiwgZXhwb25lbnRMZW5ndGggLT0gOCk7XG4gIGJ1ZmZlclstLWluZGV4XSB8PSBzaWduICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufTtcblxudmFyIHVucGFjayA9IGZ1bmN0aW9uIChidWZmZXIsIG1hbnRpc3NhTGVuZ3RoKSB7XG4gIHZhciBieXRlcyA9IGJ1ZmZlci5sZW5ndGg7XG4gIHZhciBleHBvbmVudExlbmd0aCA9IGJ5dGVzICogOCAtIG1hbnRpc3NhTGVuZ3RoIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBleHBvbmVudExlbmd0aCkgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IGV4cG9uZW50TGVuZ3RoIC0gNztcbiAgdmFyIGluZGV4ID0gYnl0ZXMgLSAxO1xuICB2YXIgc2lnbiA9IGJ1ZmZlcltpbmRleC0tXTtcbiAgdmFyIGV4cG9uZW50ID0gc2lnbiAmIDEyNztcbiAgdmFyIG1hbnRpc3NhO1xuICBzaWduID4+PSA3O1xuICBmb3IgKDsgbkJpdHMgPiAwOyBleHBvbmVudCA9IGV4cG9uZW50ICogMjU2ICsgYnVmZmVyW2luZGV4XSwgaW5kZXgtLSwgbkJpdHMgLT0gOCk7XG4gIG1hbnRpc3NhID0gZXhwb25lbnQgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgZXhwb25lbnQgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbWFudGlzc2FMZW5ndGg7XG4gIGZvciAoOyBuQml0cyA+IDA7IG1hbnRpc3NhID0gbWFudGlzc2EgKiAyNTYgKyBidWZmZXJbaW5kZXhdLCBpbmRleC0tLCBuQml0cyAtPSA4KTtcbiAgaWYgKGV4cG9uZW50ID09PSAwKSB7XG4gICAgZXhwb25lbnQgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZXhwb25lbnQgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbWFudGlzc2EgPyBOYU4gOiBzaWduID8gLUluZmluaXR5JDEgOiBJbmZpbml0eSQxO1xuICB9IGVsc2Uge1xuICAgIG1hbnRpc3NhID0gbWFudGlzc2EgKyBwb3coMiwgbWFudGlzc2FMZW5ndGgpO1xuICAgIGV4cG9uZW50ID0gZXhwb25lbnQgLSBlQmlhcztcbiAgfSByZXR1cm4gKHNpZ24gPyAtMSA6IDEpICogbWFudGlzc2EgKiBwb3coMiwgZXhwb25lbnQgLSBtYW50aXNzYUxlbmd0aCk7XG59O1xuXG52YXIgaWVlZTc1NCA9IHtcbiAgcGFjazogcGFjayxcbiAgdW5wYWNrOiB1bnBhY2tcbn07XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmlsbGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsbFxudmFyIGFycmF5RmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICB2YXIgZW5kID0gYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxudmFyIGRlZmluZVByb3BlcnR5JDMgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXG5cblxudmFyIFRPX1NUUklOR19UQUckMyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcblxudmFyIHNldFRvU3RyaW5nVGFnID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQykge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IFNUQVRJQyA/IGl0IDogaXQucHJvdG90eXBlLCBUT19TVFJJTkdfVEFHJDMpKSB7XG4gICAgZGVmaW5lUHJvcGVydHkkMyhpdCwgVE9fU1RSSU5HX1RBRyQzLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcbiAgfVxufTtcblxudmFyIE5BVElWRV9BUlJBWV9CVUZGRVIkMSA9IGFycmF5QnVmZmVyVmlld0NvcmUuTkFUSVZFX0FSUkFZX0JVRkZFUjtcblxuXG5cblxuXG5cblxuXG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZjtcbnZhciBkZWZpbmVQcm9wZXJ0eSQ0ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxuXG5cblxudmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlLmdldDtcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZS5zZXQ7XG52YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbnZhciBEQVRBX1ZJRVcgPSAnRGF0YVZpZXcnO1xudmFyIFBST1RPVFlQRSQxID0gJ3Byb3RvdHlwZSc7XG52YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCc7XG52YXIgV1JPTkdfSU5ERVggPSAnV3JvbmcgaW5kZXgnO1xudmFyIE5hdGl2ZUFycmF5QnVmZmVyID0gZ2xvYmFsXzFbQVJSQVlfQlVGRkVSXTtcbnZhciAkQXJyYXlCdWZmZXIgPSBOYXRpdmVBcnJheUJ1ZmZlcjtcbnZhciAkRGF0YVZpZXcgPSBnbG9iYWxfMVtEQVRBX1ZJRVddO1xudmFyIFJhbmdlRXJyb3IkMSA9IGdsb2JhbF8xLlJhbmdlRXJyb3I7XG5cbnZhciBwYWNrSUVFRTc1NCA9IGllZWU3NTQucGFjaztcbnZhciB1bnBhY2tJRUVFNzU0ID0gaWVlZTc1NC51bnBhY2s7XG5cbnZhciBwYWNrSW50OCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIFtudW1iZXIgJiAweEZGXTtcbn07XG5cbnZhciBwYWNrSW50MTYgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBbbnVtYmVyICYgMHhGRiwgbnVtYmVyID4+IDggJiAweEZGXTtcbn07XG5cbnZhciBwYWNrSW50MzIgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBbbnVtYmVyICYgMHhGRiwgbnVtYmVyID4+IDggJiAweEZGLCBudW1iZXIgPj4gMTYgJiAweEZGLCBudW1iZXIgPj4gMjQgJiAweEZGXTtcbn07XG5cbnZhciB1bnBhY2tJbnQzMiA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlclszXSA8PCAyNCB8IGJ1ZmZlclsyXSA8PCAxNiB8IGJ1ZmZlclsxXSA8PCA4IHwgYnVmZmVyWzBdO1xufTtcblxudmFyIHBhY2tGbG9hdDMyID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gcGFja0lFRUU3NTQobnVtYmVyLCAyMywgNCk7XG59O1xuXG52YXIgcGFja0Zsb2F0NjQgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChudW1iZXIsIDUyLCA4KTtcbn07XG5cbnZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGtleSkge1xuICBkZWZpbmVQcm9wZXJ0eSQ0KENvbnN0cnVjdG9yW1BST1RPVFlQRSQxXSwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKVtrZXldOyB9IH0pO1xufTtcblxudmFyIGdldCQxID0gZnVuY3Rpb24gKHZpZXcsIGNvdW50LCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChpbmRleCk7XG4gIHZhciBzdG9yZSA9IGdldEludGVybmFsU3RhdGUodmlldyk7XG4gIGlmIChpbnRJbmRleCArIGNvdW50ID4gc3RvcmUuYnl0ZUxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvciQxKFdST05HX0lOREVYKTtcbiAgdmFyIGJ5dGVzID0gZ2V0SW50ZXJuYWxTdGF0ZShzdG9yZS5idWZmZXIpLmJ5dGVzO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHN0b3JlLmJ5dGVPZmZzZXQ7XG4gIHZhciBwYWNrID0gYnl0ZXMuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xuICByZXR1cm4gaXNMaXR0bGVFbmRpYW4gPyBwYWNrIDogcGFjay5yZXZlcnNlKCk7XG59O1xuXG52YXIgc2V0JDEgPSBmdW5jdGlvbiAodmlldywgY291bnQsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChpbmRleCk7XG4gIHZhciBzdG9yZSA9IGdldEludGVybmFsU3RhdGUodmlldyk7XG4gIGlmIChpbnRJbmRleCArIGNvdW50ID4gc3RvcmUuYnl0ZUxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvciQxKFdST05HX0lOREVYKTtcbiAgdmFyIGJ5dGVzID0gZ2V0SW50ZXJuYWxTdGF0ZShzdG9yZS5idWZmZXIpLmJ5dGVzO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHN0b3JlLmJ5dGVPZmZzZXQ7XG4gIHZhciBwYWNrID0gY29udmVyc2lvbigrdmFsdWUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIGJ5dGVzW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGNvdW50IC0gaSAtIDFdO1xufTtcblxuaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSJDEpIHtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0b0luZGV4KGxlbmd0aCk7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgICBieXRlczogYXJyYXlGaWxsLmNhbGwobmV3IEFycmF5KGJ5dGVMZW5ndGgpLCAwKSxcbiAgICAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGhcbiAgICB9KTtcbiAgICBpZiAoIWRlc2NyaXB0b3JzKSB0aGlzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGdldEludGVybmFsU3RhdGUoYnVmZmVyKS5ieXRlTGVuZ3RoO1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yJDEoJ1dyb25nIG9mZnNldCcpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aChieXRlTGVuZ3RoKTtcbiAgICBpZiAob2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvciQxKFdST05HX0xFTkdUSCk7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGgsXG4gICAgICBieXRlT2Zmc2V0OiBvZmZzZXRcbiAgICB9KTtcbiAgICBpZiAoIWRlc2NyaXB0b3JzKSB7XG4gICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG4gICAgICB0aGlzLmJ5dGVPZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICB9O1xuXG4gIGlmIChkZXNjcmlwdG9ycykge1xuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsICdieXRlTGVuZ3RoJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgJ2J1ZmZlcicpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsICdieXRlTGVuZ3RoJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgJ2J5dGVPZmZzZXQnKTtcbiAgfVxuXG4gIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEUkMV0sIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQkMSh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXSA8PCAyNCA+PiAyNDtcbiAgICB9LFxuICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0JDEodGhpcywgMSwgYnl0ZU9mZnNldClbMF07XG4gICAgfSxcbiAgICBnZXRJbnQxNjogZnVuY3Rpb24gZ2V0SW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0JDEodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuICAgIH0sXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0JDEodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbiAgICB9LFxuICAgIGdldEludDMyOiBmdW5jdGlvbiBnZXRJbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSW50MzIoZ2V0JDEodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJbnQzMihnZXQkMSh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQkMSh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCksIDIzKTtcbiAgICB9LFxuICAgIGdldEZsb2F0NjQ6IGZ1bmN0aW9uIGdldEZsb2F0NjQoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0JDEodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpLCA1Mik7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQkMSh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSW50OCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQkMSh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSW50OCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0SW50MTY6IGZ1bmN0aW9uIHNldEludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQkMSh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSW50MTYsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRVaW50MTY6IGZ1bmN0aW9uIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0JDEodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0ludDE2LCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc2V0SW50MzI6IGZ1bmN0aW9uIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQkMSh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSW50MzIsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRVaW50MzI6IGZ1bmN0aW9uIHNldFVpbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0JDEodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0ludDMyLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc2V0RmxvYXQzMjogZnVuY3Rpb24gc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0JDEodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0Zsb2F0MzIsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQkMSh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRmxvYXQ2NCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgTmF0aXZlQXJyYXlCdWZmZXIoMSk7XG4gIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKC0xKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcigxLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcihOYU4pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIHJldHVybiBOYXRpdmVBcnJheUJ1ZmZlci5uYW1lICE9IEFSUkFZX0JVRkZFUjtcbiAgfSkpIHtcbiAgICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyKTtcbiAgICAgIHJldHVybiBuZXcgTmF0aXZlQXJyYXlCdWZmZXIodG9JbmRleChsZW5ndGgpKTtcbiAgICB9O1xuICAgIHZhciBBcnJheUJ1ZmZlclByb3RvdHlwZSA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEUkMV0gPSBOYXRpdmVBcnJheUJ1ZmZlcltQUk9UT1RZUEUkMV07XG4gICAgZm9yICh2YXIga2V5cyQxID0gZ2V0T3duUHJvcGVydHlOYW1lcyhOYXRpdmVBcnJheUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMkMS5sZW5ndGggPiBqOykge1xuICAgICAgaWYgKCEoKGtleSA9IGtleXMkMVtqKytdKSBpbiAkQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSgkQXJyYXlCdWZmZXIsIGtleSwgTmF0aXZlQXJyYXlCdWZmZXJba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIEFycmF5QnVmZmVyUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9XG4gIC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuICB2YXIgdGVzdFZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpO1xuICB2YXIgbmF0aXZlU2V0SW50OCA9ICREYXRhVmlld1tQUk9UT1RZUEUkMV0uc2V0SW50ODtcbiAgdGVzdFZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdGVzdFZpZXcuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KTtcbiAgaWYgKHRlc3RWaWV3LmdldEludDgoMCkgfHwgIXRlc3RWaWV3LmdldEludDgoMSkpIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEUkMV0sIHtcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBuYXRpdmVTZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBuYXRpdmVTZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH1cbiAgfSwgeyB1bnNhZmU6IHRydWUgfSk7XG59XG5cbnNldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbnNldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcblxudmFyIGFycmF5QnVmZmVyID0ge1xuICBBcnJheUJ1ZmZlcjogJEFycmF5QnVmZmVyLFxuICBEYXRhVmlldzogJERhdGFWaWV3XG59O1xuXG52YXIgU1BFQ0lFUyQxID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbnZhciBzZXRTcGVjaWVzID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUpIHtcbiAgdmFyIENvbnN0cnVjdG9yID0gZ2V0QnVpbHRJbihDT05TVFJVQ1RPUl9OQU1FKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxuICBpZiAoZGVzY3JpcHRvcnMgJiYgQ29uc3RydWN0b3IgJiYgIUNvbnN0cnVjdG9yW1NQRUNJRVMkMV0pIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgU1BFQ0lFUyQxLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICB9KTtcbiAgfVxufTtcblxudmFyIEFSUkFZX0JVRkZFUiQxID0gJ0FycmF5QnVmZmVyJztcbnZhciBBcnJheUJ1ZmZlciQxID0gYXJyYXlCdWZmZXJbQVJSQVlfQlVGRkVSJDFdO1xudmFyIE5hdGl2ZUFycmF5QnVmZmVyJDEgPSBnbG9iYWxfMVtBUlJBWV9CVUZGRVIkMV07XG5cbi8vIGBBcnJheUJ1ZmZlcmAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5YnVmZmVyLWNvbnN0cnVjdG9yXG5fZXhwb3J0KHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IE5hdGl2ZUFycmF5QnVmZmVyJDEgIT09IEFycmF5QnVmZmVyJDEgfSwge1xuICBBcnJheUJ1ZmZlcjogQXJyYXlCdWZmZXIkMVxufSk7XG5cbnNldFNwZWNpZXMoQVJSQVlfQlVGRkVSJDEpO1xuXG52YXIgU1BFQ0lFUyQyID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbi8vIGBTcGVjaWVzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3BlY2llc2NvbnN0cnVjdG9yXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gKE8sIGRlZmF1bHRDb25zdHJ1Y3Rvcikge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVMkMl0pID09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb25zdHJ1Y3RvciA6IGFGdW5jdGlvbiQxKFMpO1xufTtcblxudmFyIEFycmF5QnVmZmVyJDIgPSBhcnJheUJ1ZmZlci5BcnJheUJ1ZmZlcjtcbnZhciBEYXRhVmlldyQxID0gYXJyYXlCdWZmZXIuRGF0YVZpZXc7XG52YXIgbmF0aXZlQXJyYXlCdWZmZXJTbGljZSA9IEFycmF5QnVmZmVyJDIucHJvdG90eXBlLnNsaWNlO1xuXG52YXIgSU5DT1JSRUNUX1NMSUNFID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIW5ldyBBcnJheUJ1ZmZlciQyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pO1xuXG4vLyBgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5YnVmZmVyLnByb3RvdHlwZS5zbGljZVxuX2V4cG9ydCh7IHRhcmdldDogJ0FycmF5QnVmZmVyJywgcHJvdG86IHRydWUsIHVuc2FmZTogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfU0xJQ0UgfSwge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIGlmIChuYXRpdmVBcnJheUJ1ZmZlclNsaWNlICE9PSB1bmRlZmluZWQgJiYgZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuYXRpdmVBcnJheUJ1ZmZlclNsaWNlLmNhbGwoYW5PYmplY3QodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBhbk9iamVjdCh0aGlzKS5ieXRlTGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcbiAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBBcnJheUJ1ZmZlciQyKSkodG9MZW5ndGgoZmluIC0gZmlyc3QpKTtcbiAgICB2YXIgdmlld1NvdXJjZSA9IG5ldyBEYXRhVmlldyQxKHRoaXMpO1xuICAgIHZhciB2aWV3VGFyZ2V0ID0gbmV3IERhdGFWaWV3JDEocmVzdWx0KTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlIChmaXJzdCA8IGZpbikge1xuICAgICAgdmlld1RhcmdldC5zZXRVaW50OChpbmRleCsrLCB2aWV3U291cmNlLmdldFVpbnQ4KGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG4vLyBhIHN0cmluZyBvZiBhbGwgdmFsaWQgdW5pY29kZSB3aGl0ZXNwYWNlc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbnZhciB3aGl0ZXNwYWNlcyA9ICdcXHUwMDA5XFx1MDAwQVxcdTAwMEJcXHUwMDBDXFx1MDAwRFxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxudmFyIHdoaXRlc3BhY2UgPSAnWycgKyB3aGl0ZXNwYWNlcyArICddJztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyB3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJyk7XG52YXIgcnRyaW0gPSBSZWdFeHAod2hpdGVzcGFjZSArIHdoaXRlc3BhY2UgKyAnKiQnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltLCB0cmltU3RhcnQsIHRyaW1FbmQsIHRyaW1MZWZ0LCB0cmltUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCQxID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcykge1xuICAgIHZhciBzdHJpbmcgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICAgIGlmIChUWVBFICYgMSkgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfTtcbn07XG5cbnZhciBzdHJpbmdUcmltID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1MZWZ0LCB0cmltU3RhcnQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1zdGFydFxuICBzdGFydDogY3JlYXRlTWV0aG9kJDEoMSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbVJpZ2h0LCB0cmltRW5kIH1gIG1ldGhvZHNcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltZW5kXG4gIGVuZDogY3JlYXRlTWV0aG9kJDEoMiksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cbiAgdHJpbTogY3JlYXRlTWV0aG9kJDEoMylcbn07XG5cbnZhciB0cmltID0gc3RyaW5nVHJpbS50cmltO1xuXG5cbnZhciBuYXRpdmVQYXJzZUZsb2F0ID0gZ2xvYmFsXzEucGFyc2VGbG9hdDtcbnZhciBGT1JDRUQkMSA9IDEgLyBuYXRpdmVQYXJzZUZsb2F0KHdoaXRlc3BhY2VzICsgJy0wJykgIT09IC1JbmZpbml0eTtcblxuLy8gYHBhcnNlRmxvYXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcGFyc2VmbG9hdC1zdHJpbmdcbnZhciBfcGFyc2VGbG9hdCA9IEZPUkNFRCQxID8gZnVuY3Rpb24gcGFyc2VGbG9hdChzdHJpbmcpIHtcbiAgdmFyIHRyaW1tZWRTdHJpbmcgPSB0cmltKFN0cmluZyhzdHJpbmcpKTtcbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZVBhcnNlRmxvYXQodHJpbW1lZFN0cmluZyk7XG4gIHJldHVybiByZXN1bHQgPT09IDAgJiYgdHJpbW1lZFN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogbmF0aXZlUGFyc2VGbG9hdDtcblxuLy8gYE51bWJlci5wYXJzZUZsb2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW51bWJlci5wYXJzZUZsb2F0XG5fZXhwb3J0KHsgdGFyZ2V0OiAnTnVtYmVyJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBOdW1iZXIucGFyc2VGbG9hdCAhPSBfcGFyc2VGbG9hdCB9LCB7XG4gIHBhcnNlRmxvYXQ6IF9wYXJzZUZsb2F0XG59KTtcblxudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZjtcblxuLy8gYE9iamVjdC57IGVudHJpZXMsIHZhbHVlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kJDIgPSBmdW5jdGlvbiAoVE9fRU5UUklFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoaXQpO1xuICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhPKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBpKSB7XG4gICAgICBrZXkgPSBrZXlzW2krK107XG4gICAgICBpZiAoIWRlc2NyaXB0b3JzIHx8IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoTywga2V5KSkge1xuICAgICAgICByZXN1bHQucHVzaChUT19FTlRSSUVTID8gW2tleSwgT1trZXldXSA6IE9ba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG52YXIgb2JqZWN0VG9BcnJheSA9IHtcbiAgLy8gYE9iamVjdC5lbnRyaWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmVudHJpZXNcbiAgZW50cmllczogY3JlYXRlTWV0aG9kJDIodHJ1ZSksXG4gIC8vIGBPYmplY3QudmFsdWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnZhbHVlc1xuICB2YWx1ZXM6IGNyZWF0ZU1ldGhvZCQyKGZhbHNlKVxufTtcblxudmFyICRlbnRyaWVzID0gb2JqZWN0VG9BcnJheS5lbnRyaWVzO1xuXG4vLyBgT2JqZWN0LmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmVudHJpZXNcbl9leHBvcnQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlIH0sIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhPKSB7XG4gICAgcmV0dXJuICRlbnRyaWVzKE8pO1xuICB9XG59KTtcblxudmFyIGl0ZXJhdG9ycyA9IHt9O1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUkMSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoaXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZSQxW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcblxudmFyIElURVJBVE9SJDEgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1IkMV1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgaXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIEVOVFJJRVMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHZhciByZXR1cm5NZXRob2QgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldHVybk1ldGhvZCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXR1cm5NZXRob2QuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG52YXIgaXRlcmF0ZV8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xudmFyIFJlc3VsdCA9IGZ1bmN0aW9uIChzdG9wcGVkLCByZXN1bHQpIHtcbiAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcbiAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xuXG52YXIgaXRlcmF0ZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBmbiwgdGhhdCwgQVNfRU5UUklFUywgSVNfSVRFUkFUT1IpIHtcbiAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kQ29udGV4dChmbiwgdGhhdCwgQVNfRU5UUklFUyA/IDIgOiAxKTtcbiAgdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgbmV4dCwgc3RlcDtcblxuICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoJ1RhcmdldCBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdCA9IEFTX0VOVFJJRVNcbiAgICAgICAgICA/IGJvdW5kRnVuY3Rpb24oYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pXG4gICAgICAgICAgOiBib3VuZEZ1bmN0aW9uKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gICAgfVxuICAgIGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpO1xuICB9XG5cbiAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gIHdoaWxlICghKHN0ZXAgPSBuZXh0LmNhbGwoaXRlcmF0b3IpKS5kb25lKSB7XG4gICAgcmVzdWx0ID0gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgYm91bmRGdW5jdGlvbiwgc3RlcC52YWx1ZSwgQVNfRU5UUklFUyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ29iamVjdCcgJiYgcmVzdWx0ICYmIHJlc3VsdCBpbnN0YW5jZW9mIFJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG59O1xuXG5pdGVyYXRlLnN0b3AgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIHJldHVybiBuZXcgUmVzdWx0KHRydWUsIHJlc3VsdCk7XG59O1xufSk7XG5cbnZhciBjcmVhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUoa2V5KTtcbiAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgb2JqZWN0RGVmaW5lUHJvcGVydHkuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XG59O1xuXG4vLyBgT2JqZWN0LmZyb21FbnRyaWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC1mcm9tLWVudHJpZXNcbl9leHBvcnQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlIH0sIHtcbiAgZnJvbUVudHJpZXM6IGZ1bmN0aW9uIGZyb21FbnRyaWVzKGl0ZXJhYmxlKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIGl0ZXJhdGVfMShpdGVyYWJsZSwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgIGNyZWF0ZVByb3BlcnR5KG9iaiwgaywgdik7XG4gICAgfSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG59KTtcblxudmFyICR2YWx1ZXMgPSBvYmplY3RUb0FycmF5LnZhbHVlcztcblxuLy8gYE9iamVjdC52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnZhbHVlc1xuX2V4cG9ydCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUgfSwge1xuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcyhPKSB7XG4gICAgcmV0dXJuICR2YWx1ZXMoTyk7XG4gIH1cbn0pO1xuXG52YXIgbmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yID0gZ2xvYmFsXzEuUHJvbWlzZTtcblxudmFyIElURVJBVE9SJDIgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciBjYWxsZWQgPSAwO1xuICB2YXIgaXRlcmF0b3JXaXRoUmV0dXJuID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGRvbmU6ICEhY2FsbGVkKysgfTtcbiAgICB9LFxuICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SJDJdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcbiAgaWYgKCFTS0lQX0NMT1NJTkcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgSVRFUkFUSU9OX1NVUFBPUlQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgb2JqZWN0W0lURVJBVE9SJDJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IElURVJBVElPTl9TVVBQT1JUID0gdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhlYyhvYmplY3QpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBJVEVSQVRJT05fU1VQUE9SVDtcbn07XG5cbnZhciB1c2VyQWdlbnQgPSBnZXRCdWlsdEluKCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG5cbnZhciBpc0lvcyA9IC8oaXBob25lfGlwb2R8aXBhZCkuKmFwcGxld2Via2l0L2kudGVzdCh1c2VyQWdlbnQpO1xuXG52YXIgbG9jYXRpb24gPSBnbG9iYWxfMS5sb2NhdGlvbjtcbnZhciBzZXQkMiA9IGdsb2JhbF8xLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhciA9IGdsb2JhbF8xLmNsZWFySW1tZWRpYXRlO1xudmFyIHByb2Nlc3MkMSA9IGdsb2JhbF8xLnByb2Nlc3M7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWxfMS5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbF8xLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG5cbnZhciBydW4gPSBmdW5jdGlvbiAoaWQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcblxudmFyIHJ1bm5lciA9IGZ1bmN0aW9uIChpZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJ1bihpZCk7XG4gIH07XG59O1xuXG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuKGV2ZW50LmRhdGEpO1xufTtcblxudmFyIHBvc3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgLy8gb2xkIGVuZ2luZXMgaGF2ZSBub3QgbG9jYXRpb24ub3JpZ2luXG4gIGdsb2JhbF8xLnBvc3RNZXNzYWdlKGlkICsgJycsIGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QpO1xufTtcblxuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXQkMiB8fCAhY2xlYXIpIHtcbiAgc2V0JDIgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbikpLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXIgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAoY2xhc3NvZlJhdyhwcm9jZXNzJDEpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzJDEubmV4dFRpY2socnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhydW5uZXIoaWQpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIC8vIGV4Y2VwdCBpT1MgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjI0XG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwgJiYgIWlzSW9zKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBiaW5kQ29udGV4dChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsXzEuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsXzEuaW1wb3J0U2NyaXB0cyAmJiAhZmFpbHMocG9zdCkpIHtcbiAgICBkZWZlciA9IHBvc3Q7XG4gICAgZ2xvYmFsXzEuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bihpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQocnVubmVyKGlkKSwgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgdGFzayA9IHtcbiAgc2V0OiBzZXQkMixcbiAgY2xlYXI6IGNsZWFyXG59O1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcblxudmFyIG1hY3JvdGFzayA9IHRhc2suc2V0O1xuXG5cbnZhciBNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFsXzEuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWxfMS5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MkMiA9IGdsb2JhbF8xLnByb2Nlc3M7XG52YXIgUHJvbWlzZSQxID0gZ2xvYmFsXzEuUHJvbWlzZTtcbnZhciBJU19OT0RFID0gY2xhc3NvZlJhdyhwcm9jZXNzJDIpID09ICdwcm9jZXNzJztcbi8vIE5vZGUuanMgMTEgc2hvd3MgRXhwZXJpbWVudGFsV2FybmluZyBvbiBnZXR0aW5nIGBxdWV1ZU1pY3JvdGFza2BcbnZhciBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMihnbG9iYWxfMSwgJ3F1ZXVlTWljcm90YXNrJyk7XG52YXIgcXVldWVNaWNyb3Rhc2sgPSBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgJiYgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yLnZhbHVlO1xuXG52YXIgZmx1c2gsIGhlYWQsIGxhc3QsIG5vdGlmeSwgdG9nZ2xlLCBub2RlLCBwcm9taXNlLCB0aGVuO1xuXG4vLyBtb2Rlcm4gZW5naW5lcyBoYXZlIHF1ZXVlTWljcm90YXNrIG1ldGhvZFxuaWYgKCFxdWV1ZU1pY3JvdGFzaykge1xuICBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoSVNfTk9ERSAmJiAocGFyZW50ID0gcHJvY2VzcyQyLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmIChJU19OT0RFKSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2VzcyQyLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIH0gZWxzZSBpZiAoTXV0YXRpb25PYnNlcnZlciAmJiAhaXNJb3MpIHtcbiAgICB0b2dnbGUgPSB0cnVlO1xuICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmIChQcm9taXNlJDEgJiYgUHJvbWlzZSQxLnJlc29sdmUpIHtcbiAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuICAgIHByb21pc2UgPSBQcm9taXNlJDEucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIHRoZW4gPSBwcm9taXNlLnRoZW47XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhlbi5jYWxsKHByb21pc2UsIGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsXzEsIGZsdXNoKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBtaWNyb3Rhc2sgPSBxdWV1ZU1pY3JvdGFzayB8fCBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICBpZiAoIWhlYWQpIHtcbiAgICBoZWFkID0gdGFzaztcbiAgICBub3RpZnkoKTtcbiAgfSBsYXN0ID0gdGFzaztcbn07XG5cbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24kMShyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhRnVuY3Rpb24kMShyZWplY3QpO1xufTtcblxuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbnZhciBmJDYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcblxudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0ge1xuXHRmOiBmJDZcbn07XG5cbnZhciBwcm9taXNlUmVzb2x2ZSA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuXG52YXIgaG9zdFJlcG9ydEVycm9ycyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBjb25zb2xlID0gZ2xvYmFsXzEuY29uc29sZTtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBjb25zb2xlLmVycm9yKGEpIDogY29uc29sZS5lcnJvcihhLCBiKTtcbiAgfVxufTtcblxudmFyIHBlcmZvcm0gPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSwgdmFsdWU6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCB2YWx1ZTogZXJyb3IgfTtcbiAgfVxufTtcblxudmFyIHByb2Nlc3MkMyA9IGdsb2JhbF8xLnByb2Nlc3M7XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzJDMgJiYgcHJvY2VzcyQzLnZlcnNpb25zO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIHZlcnNpb24gPSBtYXRjaFswXSArIG1hdGNoWzFdO1xufSBlbHNlIGlmICh1c2VyQWdlbnQpIHtcbiAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSBtYXRjaFsxXTtcbiAgfVxufVxuXG52YXIgdjhWZXJzaW9uID0gdmVyc2lvbiAmJiArdmVyc2lvbjtcblxudmFyIHRhc2skMSA9IHRhc2suc2V0O1xuXG5cblxuXG5cblxuXG5cblxuXG52YXIgU1BFQ0lFUyQzID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDEgPSBpbnRlcm5hbFN0YXRlLmdldDtcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDEgPSBpbnRlcm5hbFN0YXRlLnNldDtcbnZhciBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSA9IGludGVybmFsU3RhdGUuZ2V0dGVyRm9yKFBST01JU0UpO1xudmFyIFByb21pc2VDb25zdHJ1Y3RvciA9IG5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvcjtcbnZhciBUeXBlRXJyb3IkMSA9IGdsb2JhbF8xLlR5cGVFcnJvcjtcbnZhciBkb2N1bWVudCQyID0gZ2xvYmFsXzEuZG9jdW1lbnQ7XG52YXIgcHJvY2VzcyQ0ID0gZ2xvYmFsXzEucHJvY2VzcztcbnZhciAkZmV0Y2ggPSBnZXRCdWlsdEluKCdmZXRjaCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5JDEgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mO1xudmFyIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDE7XG52YXIgSVNfTk9ERSQxID0gY2xhc3NvZlJhdyhwcm9jZXNzJDQpID09ICdwcm9jZXNzJztcbnZhciBESVNQQVRDSF9FVkVOVCA9ICEhKGRvY3VtZW50JDIgJiYgZG9jdW1lbnQkMi5jcmVhdGVFdmVudCAmJiBnbG9iYWxfMS5kaXNwYXRjaEV2ZW50KTtcbnZhciBVTkhBTkRMRURfUkVKRUNUSU9OID0gJ3VuaGFuZGxlZHJlamVjdGlvbic7XG52YXIgUkVKRUNUSU9OX0hBTkRMRUQgPSAncmVqZWN0aW9uaGFuZGxlZCc7XG52YXIgUEVORElORyA9IDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG52YXIgSEFORExFRCA9IDE7XG52YXIgVU5IQU5ETEVEID0gMjtcbnZhciBJbnRlcm5hbCwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFByb21pc2VXcmFwcGVyLCBuYXRpdmVUaGVuO1xuXG52YXIgRk9SQ0VEJDIgPSBpc0ZvcmNlZF8xKFBST01JU0UsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIEdMT0JBTF9DT1JFX0pTX1BST01JU0UgPSBpbnNwZWN0U291cmNlKFByb21pc2VDb25zdHJ1Y3RvcikgIT09IFN0cmluZyhQcm9taXNlQ29uc3RydWN0b3IpO1xuICBpZiAoIUdMT0JBTF9DT1JFX0pTX1BST01JU0UpIHtcbiAgICAvLyBWOCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODMwNTY1XG4gICAgLy8gV2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgICBpZiAodjhWZXJzaW9uID09PSA2NikgcmV0dXJuIHRydWU7XG4gICAgLy8gVW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIGlmICghSVNfTk9ERSQxICYmIHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgIT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gV2UgY2FuJ3QgdXNlIEBAc3BlY2llcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcbiAgaWYgKHY4VmVyc2lvbiA+PSA1MSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoUHJvbWlzZUNvbnN0cnVjdG9yKSkgcmV0dXJuIGZhbHNlO1xuICAvLyBEZXRlY3QgY29ycmVjdG5lc3Mgb2Ygc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICB2YXIgcHJvbWlzZSA9IFByb21pc2VDb25zdHJ1Y3Rvci5yZXNvbHZlKDEpO1xuICB2YXIgRmFrZVByb21pc2UgPSBmdW5jdGlvbiAoZXhlYykge1xuICAgIGV4ZWMoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xuICB9O1xuICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yID0ge307XG4gIGNvbnN0cnVjdG9yW1NQRUNJRVMkM10gPSBGYWtlUHJvbWlzZTtcbiAgcmV0dXJuICEocHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZSk7XG59KTtcblxudmFyIElOQ09SUkVDVF9JVEVSQVRJT04gPSBGT1JDRUQkMiB8fCAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICBQcm9taXNlQ29uc3RydWN0b3IuYWxsKGl0ZXJhYmxlKVsnY2F0Y2gnXShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xuXG52YXIgbm90aWZ5JDEgPSBmdW5jdGlvbiAocHJvbWlzZSwgc3RhdGUsIGlzUmVqZWN0KSB7XG4gIGlmIChzdGF0ZS5ub3RpZmllZCkgcmV0dXJuO1xuICBzdGF0ZS5ub3RpZmllZCA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHN0YXRlLnJlYWN0aW9ucztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB2YXIgb2sgPSBzdGF0ZS5zdGF0ZSA9PSBGVUxGSUxMRUQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFyIHJlYWN0aW9uID0gY2hhaW5baW5kZXgrK107XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuLCBleGl0ZWQ7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5yZWplY3Rpb24gPT09IFVOSEFORExFRCkgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSwgc3RhdGUpO1xuICAgICAgICAgICAgc3RhdGUucmVqZWN0aW9uID0gSEFORExFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gY2FuIHRocm93XG4gICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IkMSgnUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLnJlYWN0aW9ucyA9IFtdO1xuICAgIHN0YXRlLm5vdGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFzdGF0ZS5yZWplY3Rpb24pIG9uVW5oYW5kbGVkKHByb21pc2UsIHN0YXRlKTtcbiAgfSk7XG59O1xuXG52YXIgZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBwcm9taXNlLCByZWFzb24pIHtcbiAgdmFyIGV2ZW50LCBoYW5kbGVyO1xuICBpZiAoRElTUEFUQ0hfRVZFTlQpIHtcbiAgICBldmVudCA9IGRvY3VtZW50JDIuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZXZlbnQucmVhc29uID0gcmVhc29uO1xuICAgIGV2ZW50LmluaXRFdmVudChuYW1lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZ2xvYmFsXzEuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0gZWxzZSBldmVudCA9IHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiByZWFzb24gfTtcbiAgaWYgKGhhbmRsZXIgPSBnbG9iYWxfMVsnb24nICsgbmFtZV0pIGhhbmRsZXIoZXZlbnQpO1xuICBlbHNlIGlmIChuYW1lID09PSBVTkhBTkRMRURfUkVKRUNUSU9OKSBob3N0UmVwb3J0RXJyb3JzKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCByZWFzb24pO1xufTtcblxudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UsIHN0YXRlKSB7XG4gIHRhc2skMS5jYWxsKGdsb2JhbF8xLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG4gICAgdmFyIElTX1VOSEFORExFRCA9IGlzVW5oYW5kbGVkKHN0YXRlKTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChJU19VTkhBTkRMRUQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoSVNfTk9ERSQxKSB7XG4gICAgICAgICAgcHJvY2VzcyQ0LmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoVU5IQU5ETEVEX1JFSkVDVElPTiwgcHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgc3RhdGUucmVqZWN0aW9uID0gSVNfTk9ERSQxIHx8IGlzVW5oYW5kbGVkKHN0YXRlKSA/IFVOSEFORExFRCA6IEhBTkRMRUQ7XG4gICAgICBpZiAocmVzdWx0LmVycm9yKSB0aHJvdyByZXN1bHQudmFsdWU7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUucmVqZWN0aW9uICE9PSBIQU5ETEVEICYmICFzdGF0ZS5wYXJlbnQ7XG59O1xuXG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSwgc3RhdGUpIHtcbiAgdGFzayQxLmNhbGwoZ2xvYmFsXzEsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoSVNfTk9ERSQxKSB7XG4gICAgICBwcm9jZXNzJDQuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBkaXNwYXRjaEV2ZW50KFJFSkVDVElPTl9IQU5ETEVELCBwcm9taXNlLCBzdGF0ZS52YWx1ZSk7XG4gIH0pO1xufTtcblxudmFyIGJpbmQgPSBmdW5jdGlvbiAoZm4sIHByb21pc2UsIHN0YXRlLCB1bndyYXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGZuKHByb21pc2UsIHN0YXRlLCB2YWx1ZSwgdW53cmFwKTtcbiAgfTtcbn07XG5cbnZhciBpbnRlcm5hbFJlamVjdCA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gIHN0YXRlLnN0YXRlID0gUkVKRUNURUQ7XG4gIG5vdGlmeSQxKHByb21pc2UsIHN0YXRlLCB0cnVlKTtcbn07XG5cbnZhciBpbnRlcm5hbFJlc29sdmUgPSBmdW5jdGlvbiAocHJvbWlzZSwgc3RhdGUsIHZhbHVlLCB1bndyYXApIHtcbiAgaWYgKHN0YXRlLmRvbmUpIHJldHVybjtcbiAgc3RhdGUuZG9uZSA9IHRydWU7XG4gIGlmICh1bndyYXApIHN0YXRlID0gdW53cmFwO1xuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yJDEoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICB2YXIgdGhlbiA9IGlzVGhlbmFibGUodmFsdWUpO1xuICAgIGlmICh0aGVuKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsXG4gICAgICAgICAgICBiaW5kKGludGVybmFsUmVzb2x2ZSwgcHJvbWlzZSwgd3JhcHBlciwgc3RhdGUpLFxuICAgICAgICAgICAgYmluZChpbnRlcm5hbFJlamVjdCwgcHJvbWlzZSwgd3JhcHBlciwgc3RhdGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpbnRlcm5hbFJlamVjdChwcm9taXNlLCB3cmFwcGVyLCBlcnJvciwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHN0YXRlLnN0YXRlID0gRlVMRklMTEVEO1xuICAgICAgbm90aWZ5JDEocHJvbWlzZSwgc3RhdGUsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW50ZXJuYWxSZWplY3QocHJvbWlzZSwgeyBkb25lOiBmYWxzZSB9LCBlcnJvciwgc3RhdGUpO1xuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKEZPUkNFRCQyKSB7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gIFByb21pc2VDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsIFByb21pc2VDb25zdHJ1Y3RvciwgUFJPTUlTRSk7XG4gICAgYUZ1bmN0aW9uJDEoZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihiaW5kKGludGVybmFsUmVzb2x2ZSwgdGhpcywgc3RhdGUpLCBiaW5kKGludGVybmFsUmVqZWN0LCB0aGlzLCBzdGF0ZSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpbnRlcm5hbFJlamVjdCh0aGlzLCBzdGF0ZSwgZXJyb3IpO1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHNldEludGVybmFsU3RhdGUkMSh0aGlzLCB7XG4gICAgICB0eXBlOiBQUk9NSVNFLFxuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICBub3RpZmllZDogZmFsc2UsXG4gICAgICBwYXJlbnQ6IGZhbHNlLFxuICAgICAgcmVhY3Rpb25zOiBbXSxcbiAgICAgIHJlamVjdGlvbjogZmFsc2UsXG4gICAgICBzdGF0ZTogUEVORElORyxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZSwge1xuICAgIC8vIGBQcm9taXNlLnByb3RvdHlwZS50aGVuYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcm9taXNlLnByb3RvdHlwZS50aGVuXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUodGhpcyk7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gSVNfTk9ERSQxID8gcHJvY2VzcyQ0LmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHN0YXRlLnBhcmVudCA9IHRydWU7XG4gICAgICBzdGF0ZS5yZWFjdGlvbnMucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAoc3RhdGUuc3RhdGUgIT0gUEVORElORykgbm90aWZ5JDEodGhpcywgc3RhdGUsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gYFByb21pc2UucHJvdG90eXBlLmNhdGNoYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcm9taXNlLnByb3RvdHlwZS5jYXRjaFxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlJDEocHJvbWlzZSk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBiaW5kKGludGVybmFsUmVzb2x2ZSwgcHJvbWlzZSwgc3RhdGUpO1xuICAgIHRoaXMucmVqZWN0ID0gYmluZChpbnRlcm5hbFJlamVjdCwgcHJvbWlzZSwgc3RhdGUpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09IFByb21pc2VDb25zdHJ1Y3RvciB8fCBDID09PSBQcm9taXNlV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xuXG4gIGlmICggdHlwZW9mIG5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgbmF0aXZlVGhlbiA9IG5hdGl2ZVByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUudGhlbjtcblxuICAgIC8vIHdyYXAgbmF0aXZlIFByb21pc2UjdGhlbiBmb3IgbmF0aXZlIGFzeW5jIGZ1bmN0aW9uc1xuICAgIHJlZGVmaW5lKG5hdGl2ZVByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBuYXRpdmVUaGVuLmNhbGwodGhhdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NDBcbiAgICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcblxuICAgIC8vIHdyYXAgZmV0Y2ggcmVzdWx0XG4gICAgaWYgKHR5cGVvZiAkZmV0Y2ggPT0gJ2Z1bmN0aW9uJykgX2V4cG9ydCh7IGdsb2JhbDogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgZmV0Y2g6IGZ1bmN0aW9uIGZldGNoKGlucHV0IC8qICwgaW5pdCAqLykge1xuICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoUHJvbWlzZUNvbnN0cnVjdG9yLCAkZmV0Y2guYXBwbHkoZ2xvYmFsXzEsIGFyZ3VtZW50cykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbl9leHBvcnQoeyBnbG9iYWw6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogRk9SQ0VEJDIgfSwge1xuICBQcm9taXNlOiBQcm9taXNlQ29uc3RydWN0b3Jcbn0pO1xuXG5zZXRUb1N0cmluZ1RhZyhQcm9taXNlQ29uc3RydWN0b3IsIFBST01JU0UsIGZhbHNlKTtcbnNldFNwZWNpZXMoUFJPTUlTRSk7XG5cblByb21pc2VXcmFwcGVyID0gZ2V0QnVpbHRJbihQUk9NSVNFKTtcblxuLy8gc3RhdGljc1xuX2V4cG9ydCh7IHRhcmdldDogUFJPTUlTRSwgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQkMiB9LCB7XG4gIC8vIGBQcm9taXNlLnJlamVjdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UucmVqZWN0XG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDEodGhpcyk7XG4gICAgY2FwYWJpbGl0eS5yZWplY3QuY2FsbCh1bmRlZmluZWQsIHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG5fZXhwb3J0KHsgdGFyZ2V0OiBQUk9NSVNFLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICBGT1JDRUQkMiB9LCB7XG4gIC8vIGBQcm9taXNlLnJlc29sdmVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlc29sdmVcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKCB0aGlzLCB4KTtcbiAgfVxufSk7XG5cbl9leHBvcnQoeyB0YXJnZXQ6IFBST01JU0UsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIC8vIGBQcm9taXNlLmFsbGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UuYWxsXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRwcm9taXNlUmVzb2x2ZSA9IGFGdW5jdGlvbiQxKEMucmVzb2x2ZSk7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIGl0ZXJhdGVfMShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgJHByb21pc2VSZXNvbHZlLmNhbGwoQywgcHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyBgUHJvbWlzZS5yYWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJvbWlzZS5yYWNlXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxKEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHByb21pc2VSZXNvbHZlID0gYUZ1bmN0aW9uJDEoQy5yZXNvbHZlKTtcbiAgICAgIGl0ZXJhdGVfMShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgJHByb21pc2VSZXNvbHZlLmNhbGwoQywgcHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxuLy8gU2FmYXJpIGJ1ZyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjAwODI5XG52YXIgTk9OX0dFTkVSSUMgPSAhIW5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIG5hdGl2ZVByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGVbJ2ZpbmFsbHknXS5jYWxsKHsgdGhlbjogZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9IH0sIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KTtcblxuLy8gYFByb21pc2UucHJvdG90eXBlLmZpbmFsbHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUuZmluYWxseVxuX2V4cG9ydCh7IHRhcmdldDogJ1Byb21pc2UnLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBOT05fR0VORVJJQyB9LCB7XG4gICdmaW5hbGx5JzogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICAgIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGdldEJ1aWx0SW4oJ1Byb21pc2UnKSk7XG4gICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2Ygb25GaW5hbGx5ID09ICdmdW5jdGlvbic7XG4gICAgcmV0dXJuIHRoaXMudGhlbihcbiAgICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4geDsgfSk7XG4gICAgICB9IDogb25GaW5hbGx5LFxuICAgICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IGU7IH0pO1xuICAgICAgfSA6IG9uRmluYWxseVxuICAgICk7XG4gIH1cbn0pO1xuXG4vLyBwYXRjaCBuYXRpdmUgUHJvbWlzZS5wcm90b3R5cGUgZm9yIG5hdGl2ZSBhc3luYyBmdW5jdGlvbnNcbmlmICggdHlwZW9mIG5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFuYXRpdmVQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlWydmaW5hbGx5J10pIHtcbiAgcmVkZWZpbmUobmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ2ZpbmFsbHknLCBnZXRCdWlsdEluKCdQcm9taXNlJykucHJvdG90eXBlWydmaW5hbGx5J10pO1xufVxuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXRgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5yZXBlYXRcbnZhciBzdHJpbmdSZXBlYXQgPSAnJy5yZXBlYXQgfHwgZnVuY3Rpb24gcmVwZWF0KGNvdW50KSB7XG4gIHZhciBzdHIgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIG4gPSB0b0ludGVnZXIoY291bnQpO1xuICBpZiAobiA8IDAgfHwgbiA9PSBJbmZpbml0eSkgdGhyb3cgUmFuZ2VFcnJvcignV3JvbmcgbnVtYmVyIG9mIHJlcGV0aXRpb25zJyk7XG4gIGZvciAoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSkgaWYgKG4gJiAxKSByZXN1bHQgKz0gc3RyO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcblxuXG5cblxudmFyIGNlaWwkMSA9IE1hdGguY2VpbDtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyBwYWRTdGFydCwgcGFkRW5kIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QkMyA9IGZ1bmN0aW9uIChJU19FTkQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgbWF4TGVuZ3RoLCBmaWxsU3RyaW5nKSB7XG4gICAgdmFyIFMgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICAgIHZhciBzdHJpbmdMZW5ndGggPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlsbFN0ciA9IGZpbGxTdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcgJyA6IFN0cmluZyhmaWxsU3RyaW5nKTtcbiAgICB2YXIgaW50TWF4TGVuZ3RoID0gdG9MZW5ndGgobWF4TGVuZ3RoKTtcbiAgICB2YXIgZmlsbExlbiwgc3RyaW5nRmlsbGVyO1xuICAgIGlmIChpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoIHx8IGZpbGxTdHIgPT0gJycpIHJldHVybiBTO1xuICAgIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGg7XG4gICAgc3RyaW5nRmlsbGVyID0gc3RyaW5nUmVwZWF0LmNhbGwoZmlsbFN0ciwgY2VpbCQxKGZpbGxMZW4gLyBmaWxsU3RyLmxlbmd0aCkpO1xuICAgIGlmIChzdHJpbmdGaWxsZXIubGVuZ3RoID4gZmlsbExlbikgc3RyaW5nRmlsbGVyID0gc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICAgIHJldHVybiBJU19FTkQgPyBTICsgc3RyaW5nRmlsbGVyIDogc3RyaW5nRmlsbGVyICsgUztcbiAgfTtcbn07XG5cbnZhciBzdHJpbmdQYWQgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnBhZFN0YXJ0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5wYWRzdGFydFxuICBzdGFydDogY3JlYXRlTWV0aG9kJDMoZmFsc2UpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5wYWRFbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnBhZGVuZFxuICBlbmQ6IGNyZWF0ZU1ldGhvZCQzKHRydWUpXG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMjgwXG5cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tdW5zYWZlLXJlZ2V4XG52YXIgd2Via2l0U3RyaW5nUGFkQnVnID0gL1ZlcnNpb25cXC8xMFxcLlxcZCsoXFwuXFxkKyk/KCBNb2JpbGVcXC9cXHcrKT8gU2FmYXJpXFwvLy50ZXN0KHVzZXJBZ2VudCk7XG5cbnZhciAkcGFkRW5kID0gc3RyaW5nUGFkLmVuZDtcblxuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5wYWRFbmRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5wYWRlbmRcbl9leHBvcnQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiB3ZWJraXRTdHJpbmdQYWRCdWcgfSwge1xuICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgcmV0dXJuICRwYWRFbmQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgJHBhZFN0YXJ0ID0gc3RyaW5nUGFkLnN0YXJ0O1xuXG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnBhZFN0YXJ0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucGFkc3RhcnRcbl9leHBvcnQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiB3ZWJraXRTdHJpbmdQYWRCdWcgfSwge1xuICBwYWRTdGFydDogZnVuY3Rpb24gcGFkU3RhcnQobWF4TGVuZ3RoIC8qICwgZmlsbFN0cmluZyA9ICcgJyAqLykge1xuICAgIHJldHVybiAkcGFkU3RhcnQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXQtcmVnZXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIHJlZ2V4cEZsYWdzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC5kb3RBbGwpIHJlc3VsdCArPSAncyc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIGJhYmVsLW1pbmlmeSB0cmFuc3BpbGVzIFJlZ0V4cCgnYScsICd5JykgLT4gL2EveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yLFxuLy8gc28gd2UgdXNlIGFuIGludGVybWVkaWF0ZSBmdW5jdGlvbi5cbmZ1bmN0aW9uIFJFKHMsIGYpIHtcbiAgcmV0dXJuIFJlZ0V4cChzLCBmKTtcbn1cblxudmFyIFVOU1VQUE9SVEVEX1kgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGJhYmVsLW1pbmlmeSB0cmFuc3BpbGVzIFJlZ0V4cCgnYScsICd5JykgLT4gL2EveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG4gIHZhciByZSA9IFJFKCdhJywgJ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ2FiY2QnKSAhPSBudWxsO1xufSk7XG5cbnZhciBCUk9LRU5fQ0FSRVQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc3MzY4N1xuICB2YXIgcmUgPSBSRSgnXnInLCAnZ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ3N0cicpICE9IG51bGw7XG59KTtcblxudmFyIHJlZ2V4cFN0aWNreUhlbHBlcnMgPSB7XG5cdFVOU1VQUE9SVEVEX1k6IFVOU1VQUE9SVEVEX1ksXG5cdEJST0tFTl9DQVJFVDogQlJPS0VOX0NBUkVUXG59O1xuXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbi8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxuLy8gU3RyaW5nI3JlcGxhY2UgcG9seWZpbGwgdXNlcyAuL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMsXG4vLyB3aGljaCBsb2FkcyB0aGlzIGZpbGUgYmVmb3JlIHBhdGNoaW5nIHRoZSBtZXRob2QuXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcblxudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS87XG4gIHZhciByZTIgPSAvYiovZztcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMSwgJ2EnKTtcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMS5sYXN0SW5kZXggIT09IDAgfHwgcmUyLmxhc3RJbmRleCAhPT0gMDtcbn0pKCk7XG5cbnZhciBVTlNVUFBPUlRFRF9ZJDEgPSByZWdleHBTdGlja3lIZWxwZXJzLlVOU1VQUE9SVEVEX1kgfHwgcmVnZXhwU3RpY2t5SGVscGVycy5CUk9LRU5fQ0FSRVQ7XG5cbi8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwLCBjb3BpZWQgZnJvbSBlczUtc2hpbSdzIFN0cmluZyNzcGxpdCBwYXRjaC5cbnZhciBOUENHX0lOQ0xVREVEID0gLygpPz8vLmV4ZWMoJycpWzFdICE9PSB1bmRlZmluZWQ7XG5cbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEIHx8IFVOU1VQUE9SVEVEX1kkMTtcblxuaWYgKFBBVENIKSB7XG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHIpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBsYXN0SW5kZXgsIHJlQ29weSwgbWF0Y2gsIGk7XG4gICAgdmFyIHN0aWNreSA9IFVOU1VQUE9SVEVEX1kkMSAmJiByZS5zdGlja3k7XG4gICAgdmFyIGZsYWdzID0gcmVnZXhwRmxhZ3MuY2FsbChyZSk7XG4gICAgdmFyIHNvdXJjZSA9IHJlLnNvdXJjZTtcbiAgICB2YXIgY2hhcnNBZGRlZCA9IDA7XG4gICAgdmFyIHN0ckNvcHkgPSBzdHI7XG5cbiAgICBpZiAoc3RpY2t5KSB7XG4gICAgICBmbGFncyA9IGZsYWdzLnJlcGxhY2UoJ3knLCAnJyk7XG4gICAgICBpZiAoZmxhZ3MuaW5kZXhPZignZycpID09PSAtMSkge1xuICAgICAgICBmbGFncyArPSAnZyc7XG4gICAgICB9XG5cbiAgICAgIHN0ckNvcHkgPSBTdHJpbmcoc3RyKS5zbGljZShyZS5sYXN0SW5kZXgpO1xuICAgICAgLy8gU3VwcG9ydCBhbmNob3JlZCBzdGlja3kgYmVoYXZpb3IuXG4gICAgICBpZiAocmUubGFzdEluZGV4ID4gMCAmJiAoIXJlLm11bHRpbGluZSB8fCByZS5tdWx0aWxpbmUgJiYgc3RyW3JlLmxhc3RJbmRleCAtIDFdICE9PSAnXFxuJykpIHtcbiAgICAgICAgc291cmNlID0gJyg/OiAnICsgc291cmNlICsgJyknO1xuICAgICAgICBzdHJDb3B5ID0gJyAnICsgc3RyQ29weTtcbiAgICAgICAgY2hhcnNBZGRlZCsrO1xuICAgICAgfVxuICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIHN0ciBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXig/OicgKyBzb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICB9XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyBzb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuXG4gICAgbWF0Y2ggPSBuYXRpdmVFeGVjLmNhbGwoc3RpY2t5ID8gcmVDb3B5IDogcmUsIHN0ckNvcHkpO1xuXG4gICAgaWYgKHN0aWNreSkge1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoLmlucHV0ID0gbWF0Y2guaW5wdXQuc2xpY2UoY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoLmluZGV4ID0gcmUubGFzdEluZGV4O1xuICAgICAgICByZS5sYXN0SW5kZXggKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICBuYXRpdmVSZXBsYWNlLmNhbGwobWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcbn1cblxudmFyIHJlZ2V4cEV4ZWMgPSBwYXRjaGVkRXhlYztcblxudmFyIFNQRUNJRVMkNCA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG52YXIgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyAjcmVwbGFjZSBuZWVkcyBidWlsdC1pbiBzdXBwb3J0IGZvciBuYW1lZCBncm91cHMuXG4gIC8vICNtYXRjaCB3b3JrcyBmaW5lIGJlY2F1c2UgaXQganVzdCByZXR1cm4gdGhlIGV4ZWMgcmVzdWx0cywgZXZlbiBpZiBpdCBoYXNcbiAgLy8gYSBcImdyb3BzXCIgcHJvcGVydHkuXG4gIHZhciByZSA9IC8uLztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0Lmdyb3VwcyA9IHsgYTogJzcnIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuICcnLnJlcGxhY2UocmUsICckPGE+JykgIT09ICc3Jztcbn0pO1xuXG4vLyBJRSA8PSAxMSByZXBsYWNlcyAkMCB3aXRoIHRoZSB3aG9sZSBtYXRjaCwgYXMgaWYgaXQgd2FzICQmXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MDI0NjY2L2dldHRpbmctaWUtdG8tcmVwbGFjZS1hLXJlZ2V4LXdpdGgtdGhlLWxpdGVyYWwtc3RyaW5nLTBcbnZhciBSRVBMQUNFX0tFRVBTXyQwID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdhJy5yZXBsYWNlKC8uLywgJyQwJykgPT09ICckMCc7XG59KSgpO1xuXG4vLyBDaHJvbWUgNTEgaGFzIGEgYnVnZ3kgXCJzcGxpdFwiIGltcGxlbWVudGF0aW9uIHdoZW4gUmVnRXhwI2V4ZWMgIT09IG5hdGl2ZUV4ZWNcbi8vIFdlZXggSlMgaGFzIGZyb3plbiBidWlsdC1pbiBwcm90b3R5cGVzLCBzbyB1c2UgdHJ5IC8gY2F0Y2ggd3JhcHBlclxudmFyIFNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9IC8oPzopLztcbiAgdmFyIG9yaWdpbmFsRXhlYyA9IHJlLmV4ZWM7XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmlnaW5hbEV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgdmFyIHJlc3VsdCA9ICdhYicuc3BsaXQocmUpO1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCAhPT0gMiB8fCByZXN1bHRbMF0gIT09ICdhJyB8fCByZXN1bHRbMV0gIT09ICdiJztcbn0pO1xuXG52YXIgZml4UmVnZXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSBmdW5jdGlvbiAoS0VZLCBsZW5ndGgsIGV4ZWMsIHNoYW0pIHtcbiAgdmFyIFNZTUJPTCA9IHdlbGxLbm93blN5bWJvbChLRVkpO1xuXG4gIHZhciBERUxFR0FURVNfVE9fU1lNQk9MID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdHJpbmcgbWV0aG9kcyBjYWxsIHN5bWJvbC1uYW1lZCBSZWdFcCBtZXRob2RzXG4gICAgdmFyIE8gPSB7fTtcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pO1xuXG4gIHZhciBERUxFR0FURVNfVE9fRVhFQyA9IERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTeW1ib2wtbmFtZWQgUmVnRXhwIG1ldGhvZHMgY2FsbCAuZXhlY1xuICAgIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHJlID0gL2EvO1xuXG4gICAgaWYgKEtFWSA9PT0gJ3NwbGl0Jykge1xuICAgICAgLy8gV2UgY2FuJ3QgdXNlIHJlYWwgcmVnZXggaGVyZSBzaW5jZSBpdCBjYXVzZXMgZGVvcHRpbWl6YXRpb25cbiAgICAgIC8vIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uIGluIFY4XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzA2XG4gICAgICByZSA9IHt9O1xuICAgICAgLy8gUmVnRXhwW0BAc3BsaXRdIGRvZXNuJ3QgY2FsbCB0aGUgcmVnZXgncyBleGVjIG1ldGhvZCwgYnV0IGZpcnN0IGNyZWF0ZXNcbiAgICAgIC8vIGEgbmV3IG9uZS4gV2UgbmVlZCB0byByZXR1cm4gdGhlIHBhdGNoZWQgcmVnZXggd2hlbiBjcmVhdGluZyB0aGUgbmV3IG9uZS5cbiAgICAgIHJlLmNvbnN0cnVjdG9yID0ge307XG4gICAgICByZS5jb25zdHJ1Y3RvcltTUEVDSUVTJDRdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG4gICAgICByZS5mbGFncyA9ICcnO1xuICAgICAgcmVbU1lNQk9MXSA9IC8uL1tTWU1CT0xdO1xuICAgIH1cblxuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IGV4ZWNDYWxsZWQgPSB0cnVlOyByZXR1cm4gbnVsbDsgfTtcblxuICAgIHJlW1NZTUJPTF0oJycpO1xuICAgIHJldHVybiAhZXhlY0NhbGxlZDtcbiAgfSk7XG5cbiAgaWYgKFxuICAgICFERUxFR0FURVNfVE9fU1lNQk9MIHx8XG4gICAgIURFTEVHQVRFU19UT19FWEVDIHx8XG4gICAgKEtFWSA9PT0gJ3JlcGxhY2UnICYmICEoUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgJiYgUkVQTEFDRV9LRUVQU18kMCkpIHx8XG4gICAgKEtFWSA9PT0gJ3NwbGl0JyAmJiAhU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDKVxuICApIHtcbiAgICB2YXIgbmF0aXZlUmVnRXhwTWV0aG9kID0gLy4vW1NZTUJPTF07XG4gICAgdmFyIG1ldGhvZHMgPSBleGVjKFNZTUJPTCwgJydbS0VZXSwgZnVuY3Rpb24gKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICBpZiAocmVnZXhwLmV4ZWMgPT09IHJlZ2V4cEV4ZWMpIHtcbiAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgLy8gcG9seWZpbGxlZCBmdW5jdGlvbiksIGxlYXNpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZVJlZ0V4cE1ldGhvZC5jYWxsKHJlZ2V4cCwgc3RyLCBhcmcyKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBuYXRpdmVNZXRob2QuY2FsbChzdHIsIHJlZ2V4cCwgYXJnMikgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlIH07XG4gICAgfSwgeyBSRVBMQUNFX0tFRVBTXyQwOiBSRVBMQUNFX0tFRVBTXyQwIH0pO1xuICAgIHZhciBzdHJpbmdNZXRob2QgPSBtZXRob2RzWzBdO1xuICAgIHZhciByZWdleE1ldGhvZCA9IG1ldGhvZHNbMV07XG5cbiAgICByZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmluZ01ldGhvZCk7XG4gICAgcmVkZWZpbmUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByZWdleE1ldGhvZC5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxuICAgICAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG4gICAgICAvLyAyMS4yLjUuOSBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXShzdHJpbmcpXG4gICAgICA6IGZ1bmN0aW9uIChzdHJpbmcpIHsgcmV0dXJuIHJlZ2V4TWV0aG9kLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cblxuICBpZiAoc2hhbSkgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KFJlZ0V4cC5wcm90b3R5cGVbU1lNQk9MXSwgJ3NoYW0nLCB0cnVlKTtcbn07XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnsgY29kZVBvaW50QXQsIGF0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QkNCA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgICB2YXIgUyA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGZpcnN0ID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuICAgICAgICA/IENPTlZFUlRfVE9fU1RSSU5HID8gUy5jaGFyQXQocG9zaXRpb24pIDogZmlyc3RcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklORyA/IFMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgMikgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxudmFyIHN0cmluZ011bHRpYnl0ZSA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0XG4gIGNvZGVBdDogY3JlYXRlTWV0aG9kJDQoZmFsc2UpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5hdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbiAgY2hhckF0OiBjcmVhdGVNZXRob2QkNCh0cnVlKVxufTtcblxudmFyIGNoYXJBdCA9IHN0cmluZ011bHRpYnl0ZS5jaGFyQXQ7XG5cbi8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gZnVuY3Rpb24gKFMsIGluZGV4LCB1bmljb2RlKSB7XG4gIHJldHVybiBpbmRleCArICh1bmljb2RlID8gY2hhckF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07XG5cbi8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcbnZhciByZWdleHBFeGVjQWJzdHJhY3QgPSBmdW5jdGlvbiAoUiwgUykge1xuICB2YXIgZXhlYyA9IFIuZXhlYztcbiAgaWYgKHR5cGVvZiBleGVjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlc3VsdCA9IGV4ZWMuY2FsbChSLCBTKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignUmVnRXhwIGV4ZWMgbWV0aG9kIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIE9iamVjdCBvciBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoY2xhc3NvZlJhdyhSKSAhPT0gJ1JlZ0V4cCcpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZ0V4cCNleGVjIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXInKTtcbiAgfVxuXG4gIHJldHVybiByZWdleHBFeGVjLmNhbGwoUiwgUyk7XG59O1xuXG52YXIgbWF4JDEgPSBNYXRoLm1heDtcbnZhciBtaW4kMiA9IE1hdGgubWluO1xudmFyIGZsb29yJDIgPSBNYXRoLmZsb29yO1xudmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTID0gL1xcJChbJCYnYF18XFxkXFxkP3w8W14+XSo+KS9nO1xudmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEID0gL1xcJChbJCYnYF18XFxkXFxkPykvZztcblxudmFyIG1heWJlVG9TdHJpbmcgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyBpdCA6IFN0cmluZyhpdCk7XG59O1xuXG4vLyBAQHJlcGxhY2UgbG9naWNcbmZpeFJlZ2V4cFdlbGxLbm93blN5bWJvbExvZ2ljKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24gKFJFUExBQ0UsIG5hdGl2ZVJlcGxhY2UsIG1heWJlQ2FsbE5hdGl2ZSwgcmVhc29uKSB7XG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUucmVwbGFjZWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlXG4gICAgZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG4gICAgICB2YXIgTyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgICB2YXIgcmVwbGFjZXIgPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcbiAgICAgIHJldHVybiByZXBsYWNlciAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcmVwbGFjZXIuY2FsbChzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgICA6IG5hdGl2ZVJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHJlcGxhY2VcbiAgICBmdW5jdGlvbiAocmVnZXhwLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIGlmIChyZWFzb24uUkVQTEFDRV9LRUVQU18kMCB8fCAodHlwZW9mIHJlcGxhY2VWYWx1ZSA9PT0gJ3N0cmluZycgJiYgcmVwbGFjZVZhbHVlLmluZGV4T2YoJyQwJykgPT09IC0xKSkge1xuICAgICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZVJlcGxhY2UsIHJlZ2V4cCwgdGhpcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG5cbiAgICAgIHZhciBmdW5jdGlvbmFsUmVwbGFjZSA9IHR5cGVvZiByZXBsYWNlVmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgICBpZiAoIWZ1bmN0aW9uYWxSZXBsYWNlKSByZXBsYWNlVmFsdWUgPSBTdHJpbmcocmVwbGFjZVZhbHVlKTtcblxuICAgICAgdmFyIGdsb2JhbCA9IHJ4Lmdsb2JhbDtcbiAgICAgIGlmIChnbG9iYWwpIHtcbiAgICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVnZXhwRXhlY0Fic3RyYWN0KHJ4LCBTKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG5cbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIGlmICghZ2xvYmFsKSBicmVhaztcblxuICAgICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuXG4gICAgICAgIHZhciBtYXRjaGVkID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG1heCQxKG1pbiQyKHRvSW50ZWdlcihyZXN1bHQuaW5kZXgpLCBTLmxlbmd0aCksIDApO1xuICAgICAgICB2YXIgY2FwdHVyZXMgPSBbXTtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgIC8vICAgY2FwdHVyZXMgPSByZXN1bHQuc2xpY2UoMSkubWFwKG1heWJlVG9TdHJpbmcpXG4gICAgICAgIC8vIGJ1dCBmb3Igc29tZSByZWFzb24gYG5hdGl2ZVNsaWNlLmNhbGwocmVzdWx0LCAxLCByZXN1bHQubGVuZ3RoKWAgKGNhbGxlZCBpblxuICAgICAgICAvLyB0aGUgc2xpY2UgcG9seWZpbGwgd2hlbiBzbGljaW5nIG5hdGl2ZSBhcnJheXMpIFwiZG9lc24ndCB3b3JrXCIgaW4gc2FmYXJpIDkgYW5kXG4gICAgICAgIC8vIGNhdXNlcyBhIGNyYXNoIChodHRwczovL3Bhc3RlYmluLmNvbS9OMjFRemVRQSkgd2hlbiB0cnlpbmcgdG8gZGVidWcgaXQuXG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSBjYXB0dXJlcy5wdXNoKG1heWJlVG9TdHJpbmcocmVzdWx0W2pdKSk7XG4gICAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3VwcztcbiAgICAgICAgaWYgKGZ1bmN0aW9uYWxSZXBsYWNlKSB7XG4gICAgICAgICAgdmFyIHJlcGxhY2VyQXJncyA9IFttYXRjaGVkXS5jb25jYXQoY2FwdHVyZXMsIHBvc2l0aW9uLCBTKTtcbiAgICAgICAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSByZXBsYWNlckFyZ3MucHVzaChuYW1lZENhcHR1cmVzKTtcbiAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBTdHJpbmcocmVwbGFjZVZhbHVlLmFwcGx5KHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgUywgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSBuZXh0U291cmNlUG9zaXRpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdCArPSBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24pO1xuICAgIH1cbiAgXTtcblxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXRzdWJzdGl0dXRpb25cbiAgZnVuY3Rpb24gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIHN0ciwgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlbWVudCkge1xuICAgIHZhciB0YWlsUG9zID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcbiAgICB2YXIgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEO1xuICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcbiAgICAgIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MUztcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZVJlcGxhY2UuY2FsbChyZXBsYWNlbWVudCwgc3ltYm9scywgZnVuY3Rpb24gKG1hdGNoLCBjaCkge1xuICAgICAgdmFyIGNhcHR1cmU7XG4gICAgICBzd2l0Y2ggKGNoLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICckJzogcmV0dXJuICckJztcbiAgICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xuICAgICAgICBjYXNlICdgJzogcmV0dXJuIHN0ci5zbGljZSgwLCBwb3NpdGlvbik7XG4gICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzdHIuc2xpY2UodGFpbFBvcyk7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIGNhcHR1cmUgPSBuYW1lZENhcHR1cmVzW2NoLnNsaWNlKDEsIC0xKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIFxcZFxcZD9cbiAgICAgICAgICB2YXIgbiA9ICtjaDtcbiAgICAgICAgICBpZiAobiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmbG9vciQyKG4gLyAxMCk7XG4gICAgICAgICAgICBpZiAoZiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgaWYgKGYgPD0gbSkgcmV0dXJuIGNhcHR1cmVzW2YgLSAxXSA9PT0gdW5kZWZpbmVkID8gY2guY2hhckF0KDEpIDogY2FwdHVyZXNbZiAtIDFdICsgY2guY2hhckF0KDEpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXB0dXJlID0gY2FwdHVyZXNbbiAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhcHR1cmUgPT09IHVuZGVmaW5lZCA/ICcnIDogY2FwdHVyZTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbnZhciBub24gPSAnXFx1MjAwQlxcdTAwODVcXHUxODBFJztcblxuLy8gY2hlY2sgdGhhdCBhIG1ldGhvZCB3b3JrcyB3aXRoIHRoZSBjb3JyZWN0IGxpc3Rcbi8vIG9mIHdoaXRlc3BhY2VzIGFuZCBoYXMgYSBjb3JyZWN0IG5hbWVcbnZhciBmb3JjZWRTdHJpbmdUcmltTWV0aG9kID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIHJldHVybiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhd2hpdGVzcGFjZXNbTUVUSE9EX05BTUVdKCkgfHwgbm9uW01FVEhPRF9OQU1FXSgpICE9IG5vbiB8fCB3aGl0ZXNwYWNlc1tNRVRIT0RfTkFNRV0ubmFtZSAhPT0gTUVUSE9EX05BTUU7XG4gIH0pO1xufTtcblxudmFyICR0cmltID0gc3RyaW5nVHJpbS50cmltO1xuXG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltXG5fZXhwb3J0KHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCgndHJpbScpIH0sIHtcbiAgdHJpbTogZnVuY3Rpb24gdHJpbSgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcyk7XG4gIH1cbn0pO1xuXG52YXIgJHRyaW1FbmQgPSBzdHJpbmdUcmltLmVuZDtcblxuXG52YXIgRk9SQ0VEJDMgPSBmb3JjZWRTdHJpbmdUcmltTWV0aG9kKCd0cmltRW5kJyk7XG5cbnZhciB0cmltRW5kID0gRk9SQ0VEJDMgPyBmdW5jdGlvbiB0cmltRW5kKCkge1xuICByZXR1cm4gJHRyaW1FbmQodGhpcyk7XG59IDogJycudHJpbUVuZDtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltRW5kLCB0cmltUmlnaHQgfWAgbWV0aG9kc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5fZXhwb3J0KHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEJDMgfSwge1xuICB0cmltRW5kOiB0cmltRW5kLFxuICB0cmltUmlnaHQ6IHRyaW1FbmRcbn0pO1xuXG52YXIgJHRyaW1TdGFydCA9IHN0cmluZ1RyaW0uc3RhcnQ7XG5cblxudmFyIEZPUkNFRCQ0ID0gZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCgndHJpbVN0YXJ0Jyk7XG5cbnZhciB0cmltU3RhcnQgPSBGT1JDRUQkNCA/IGZ1bmN0aW9uIHRyaW1TdGFydCgpIHtcbiAgcmV0dXJuICR0cmltU3RhcnQodGhpcyk7XG59IDogJycudHJpbVN0YXJ0O1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1TdGFydCwgdHJpbUxlZnQgfWAgbWV0aG9kc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5fZXhwb3J0KHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEJDQgfSwge1xuICB0cmltU3RhcnQ6IHRyaW1TdGFydCxcbiAgdHJpbUxlZnQ6IHRyaW1TdGFydFxufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG5cblxudmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMSA9IGFycmF5QnVmZmVyVmlld0NvcmUuTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUztcblxudmFyIEFycmF5QnVmZmVyJDMgPSBnbG9iYWxfMS5BcnJheUJ1ZmZlcjtcbnZhciBJbnQ4QXJyYXkkMiA9IGdsb2JhbF8xLkludDhBcnJheTtcblxudmFyIHR5cGVkQXJyYXlzQ29uc3RydWN0b3JzUmVxdWlyZXNXcmFwcGVycyA9ICFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDEgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgSW50OEFycmF5JDIoMSk7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBuZXcgSW50OEFycmF5JDIoLTEpO1xufSkgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgbmV3IEludDhBcnJheSQyKCk7XG4gIG5ldyBJbnQ4QXJyYXkkMihudWxsKTtcbiAgbmV3IEludDhBcnJheSQyKDEuNSk7XG4gIG5ldyBJbnQ4QXJyYXkkMihpdGVyYWJsZSk7XG59LCB0cnVlKSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIFNhZmFyaSAoMTErKSBidWcgLSBhIHJlYXNvbiB3aHkgZXZlbiBTYWZhcmkgMTMgc2hvdWxkIGxvYWQgYSB0eXBlZCBhcnJheSBwb2x5ZmlsbFxuICByZXR1cm4gbmV3IEludDhBcnJheSQyKG5ldyBBcnJheUJ1ZmZlciQzKDIpLCAxLCB1bmRlZmluZWQpLmxlbmd0aCAhPT0gMTtcbn0pO1xuXG52YXIgdG9Qb3NpdGl2ZUludGVnZXIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IHRvSW50ZWdlcihpdCk7XG4gIGlmIChyZXN1bHQgPCAwKSB0aHJvdyBSYW5nZUVycm9yKFwiVGhlIGFyZ3VtZW50IGNhbid0IGJlIGxlc3MgdGhhbiAwXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIHRvT2Zmc2V0ID0gZnVuY3Rpb24gKGl0LCBCWVRFUykge1xuICB2YXIgb2Zmc2V0ID0gdG9Qb3NpdGl2ZUludGVnZXIoaXQpO1xuICBpZiAob2Zmc2V0ICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCcpO1xuICByZXR1cm4gb2Zmc2V0O1xufTtcblxudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IkMSA9IGFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxudmFyIHR5cGVkQXJyYXlGcm9tID0gZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBmbiwgdGhpc0FyZyAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KHNvdXJjZSk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKE8pO1xuICB2YXIgaSwgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yLCBuZXh0O1xuICBpZiAoaXRlcmF0b3JNZXRob2QgIT0gdW5kZWZpbmVkICYmICFpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlcmF0b3JNZXRob2QpKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYXRvck1ldGhvZC5jYWxsKE8pO1xuICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgIE8gPSBbXTtcbiAgICB3aGlsZSAoIShzdGVwID0gbmV4dC5jYWxsKGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgICAgTy5wdXNoKHN0ZXAudmFsdWUpO1xuICAgIH1cbiAgfVxuICBpZiAobWFwcGluZyAmJiBhcmd1bWVudHNMZW5ndGggPiAyKSB7XG4gICAgbWFwZm4gPSBiaW5kQ29udGV4dChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgfVxuICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHJlc3VsdCA9IG5ldyAoYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQxKHRoaXMpKShsZW5ndGgpO1xuICBmb3IgKGkgPSAwOyBsZW5ndGggPiBpOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgcHVzaCA9IFtdLnB1c2g7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBmb3JFYWNoLCBtYXAsIGZpbHRlciwgc29tZSwgZXZlcnksIGZpbmQsIGZpbmRJbmRleCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kJDUgPSBmdW5jdGlvbiAoVFlQRSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQsIHNwZWNpZmljQ3JlYXRlKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBpbmRleGVkT2JqZWN0KE8pO1xuICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZENvbnRleHQoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjcmVhdGUgPSBzcGVjaWZpY0NyZWF0ZSB8fCBhcnJheVNwZWNpZXNDcmVhdGU7XG4gICAgdmFyIHRhcmdldCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlLCByZXN1bHQ7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWx1ZSA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgdGFyZ2V0W2luZGV4XSA9IHJlc3VsdDsgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCkgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWx1ZTsgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHB1c2guY2FsbCh0YXJnZXQsIHZhbHVlKTsgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgIC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XG4gIH07XG59O1xuXG52YXIgYXJyYXlJdGVyYXRpb24gPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4gIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCQ1KDApLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcbiAgbWFwOiBjcmVhdGVNZXRob2QkNSgxKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gIGZpbHRlcjogY3JlYXRlTWV0aG9kJDUoMiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG4gIHNvbWU6IGNyZWF0ZU1ldGhvZCQ1KDMpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmV2ZXJ5XG4gIGV2ZXJ5OiBjcmVhdGVNZXRob2QkNSg0KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcbiAgZmluZDogY3JlYXRlTWV0aG9kJDUoNSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRJbmRleFxuICBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCQ1KDYpXG59O1xuXG4vLyBtYWtlcyBzdWJjbGFzc2luZyB3b3JrIGNvcnJlY3QgZm9yIHdyYXBwZWQgYnVpbHQtaW5zXG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSBmdW5jdGlvbiAoJHRoaXMsIGR1bW15LCBXcmFwcGVyKSB7XG4gIHZhciBOZXdUYXJnZXQsIE5ld1RhcmdldFByb3RvdHlwZTtcbiAgaWYgKFxuICAgIC8vIGl0IGNhbiB3b3JrIG9ubHkgd2l0aCBuYXRpdmUgYHNldFByb3RvdHlwZU9mYFxuICAgIG9iamVjdFNldFByb3RvdHlwZU9mICYmXG4gICAgLy8gd2UgaGF2ZW4ndCBjb21wbGV0ZWx5IGNvcnJlY3QgcHJlLUVTNiB3YXkgZm9yIGdldHRpbmcgYG5ldy50YXJnZXRgLCBzbyB1c2UgdGhpc1xuICAgIHR5cGVvZiAoTmV3VGFyZ2V0ID0gZHVtbXkuY29uc3RydWN0b3IpID09ICdmdW5jdGlvbicgJiZcbiAgICBOZXdUYXJnZXQgIT09IFdyYXBwZXIgJiZcbiAgICBpc09iamVjdChOZXdUYXJnZXRQcm90b3R5cGUgPSBOZXdUYXJnZXQucHJvdG90eXBlKSAmJlxuICAgIE5ld1RhcmdldFByb3RvdHlwZSAhPT0gV3JhcHBlci5wcm90b3R5cGVcbiAgKSBvYmplY3RTZXRQcm90b3R5cGVPZigkdGhpcywgTmV3VGFyZ2V0UHJvdG90eXBlKTtcbiAgcmV0dXJuICR0aGlzO1xufTtcblxudmFyIHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mO1xuXG52YXIgZm9yRWFjaCA9IGFycmF5SXRlcmF0aW9uLmZvckVhY2g7XG5cblxuXG5cblxuXG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuZ2V0O1xudmFyIHNldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlLnNldDtcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIFJhbmdlRXJyb3IgPSBnbG9iYWxfMS5SYW5nZUVycm9yO1xudmFyIEFycmF5QnVmZmVyID0gYXJyYXlCdWZmZXIuQXJyYXlCdWZmZXI7XG52YXIgRGF0YVZpZXcgPSBhcnJheUJ1ZmZlci5EYXRhVmlldztcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5OQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTO1xudmFyIFRZUEVEX0FSUkFZX1RBRyA9IGFycmF5QnVmZmVyVmlld0NvcmUuVFlQRURfQVJSQVlfVEFHO1xudmFyIFR5cGVkQXJyYXkgPSBhcnJheUJ1ZmZlclZpZXdDb3JlLlR5cGVkQXJyYXk7XG52YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IGFycmF5QnVmZmVyVmlld0NvcmUuVHlwZWRBcnJheVByb3RvdHlwZTtcbnZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xudmFyIGlzVHlwZWRBcnJheSA9IGFycmF5QnVmZmVyVmlld0NvcmUuaXNUeXBlZEFycmF5O1xudmFyIEJZVEVTX1BFUl9FTEVNRU5UID0gJ0JZVEVTX1BFUl9FTEVNRU5UJztcbnZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoJztcblxudmFyIGZyb21MaXN0ID0gZnVuY3Rpb24gKEMsIGxpc3QpIHtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gbmV3IChhVHlwZWRBcnJheUNvbnN0cnVjdG9yKEMpKShsZW5ndGgpO1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIG5hdGl2ZURlZmluZVByb3BlcnR5KGl0LCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcylba2V5XTtcbiAgfSB9KTtcbn07XG5cbnZhciBpc0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBrbGFzcztcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihpdCkpID09ICdBcnJheUJ1ZmZlcicgfHwga2xhc3MgPT0gJ1NoYXJlZEFycmF5QnVmZmVyJztcbn07XG5cbnZhciBpc1R5cGVkQXJyYXlJbmRleCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICByZXR1cm4gaXNUeXBlZEFycmF5KHRhcmdldClcbiAgICAmJiB0eXBlb2Yga2V5ICE9ICdzeW1ib2wnXG4gICAgJiYga2V5IGluIHRhcmdldFxuICAgICYmIFN0cmluZygra2V5KSA9PSBTdHJpbmcoa2V5KTtcbn07XG5cbnZhciB3cmFwcGVkR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG4gIHJldHVybiBpc1R5cGVkQXJyYXlJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgPyBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMiwgdGFyZ2V0W2tleV0pXG4gICAgOiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xufTtcblxudmFyIHdyYXBwZWREZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIGlmIChpc1R5cGVkQXJyYXlJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgJiYgaXNPYmplY3QoZGVzY3JpcHRvcilcbiAgICAmJiBoYXMoZGVzY3JpcHRvciwgJ3ZhbHVlJylcbiAgICAmJiAhaGFzKGRlc2NyaXB0b3IsICdnZXQnKVxuICAgICYmICFoYXMoZGVzY3JpcHRvciwgJ3NldCcpXG4gICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAmJiAhZGVzY3JpcHRvci5jb25maWd1cmFibGVcbiAgICAmJiAoIWhhcyhkZXNjcmlwdG9yLCAnd3JpdGFibGUnKSB8fCBkZXNjcmlwdG9yLndyaXRhYmxlKVxuICAgICYmICghaGFzKGRlc2NyaXB0b3IsICdlbnVtZXJhYmxlJykgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlKVxuICApIHtcbiAgICB0YXJnZXRba2V5XSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xufTtcblxuaWYgKGRlc2NyaXB0b3JzKSB7XG4gIGlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykge1xuICAgIG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mID0gd3JhcHBlZEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICBvYmplY3REZWZpbmVQcm9wZXJ0eS5mID0gd3JhcHBlZERlZmluZVByb3BlcnR5O1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnYnVmZmVyJyk7XG4gICAgYWRkR2V0dGVyKFR5cGVkQXJyYXlQcm90b3R5cGUsICdieXRlT2Zmc2V0Jyk7XG4gICAgYWRkR2V0dGVyKFR5cGVkQXJyYXlQcm90b3R5cGUsICdieXRlTGVuZ3RoJyk7XG4gICAgYWRkR2V0dGVyKFR5cGVkQXJyYXlQcm90b3R5cGUsICdsZW5ndGgnKTtcbiAgfVxuXG4gIF9leHBvcnQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIH0sIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IHdyYXBwZWRHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgZGVmaW5lUHJvcGVydHk6IHdyYXBwZWREZWZpbmVQcm9wZXJ0eVxuICB9KTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCB3cmFwcGVyLCBDTEFNUEVEKSB7XG4gICAgdmFyIEJZVEVTID0gVFlQRS5tYXRjaCgvXFxkKyQvKVswXSAvIDg7XG4gICAgdmFyIENPTlNUUlVDVE9SX05BTUUgPSBUWVBFICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknO1xuICAgIHZhciBHRVRURVIgPSAnZ2V0JyArIFRZUEU7XG4gICAgdmFyIFNFVFRFUiA9ICdzZXQnICsgVFlQRTtcbiAgICB2YXIgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsXzFbQ09OU1RSVUNUT1JfTkFNRV07XG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbiAgICB2YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgdmFyIGV4cG9ydGVkID0ge307XG5cbiAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICB2YXIgZGF0YSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICByZXR1cm4gZGF0YS52aWV3W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEuYnl0ZU9mZnNldCwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICBpZiAoQ0xBTVBFRCkgdmFsdWUgPSAodmFsdWUgPSByb3VuZCh2YWx1ZSkpIDwgMCA/IDAgOiB2YWx1ZSA+IDB4RkYgPyAweEZGIDogdmFsdWUgJiAweEZGO1xuICAgICAgZGF0YS52aWV3W1NFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEuYnl0ZU9mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIH07XG5cbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgbmF0aXZlRGVmaW5lUHJvcGVydHkodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTKSB7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCBvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5Q29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUpO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgYnl0ZU9mZnNldCA9IDA7XG4gICAgICAgIHZhciBidWZmZXIsIGJ5dGVMZW5ndGgsIGxlbmd0aDtcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgICAgIGxlbmd0aCA9IHRvSW5kZXgoZGF0YSk7XG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGxlbmd0aCAqIEJZVEVTO1xuICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICBieXRlT2Zmc2V0ID0gdG9PZmZzZXQob2Zmc2V0LCBCWVRFUyk7XG4gICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgaWYgKCRsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCRsZW4gJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBieXRlT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPCAwKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCgkbGVuZ3RoKSAqIEJZVEVTO1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggKyBieXRlT2Zmc2V0ID4gJGxlbikgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5KGRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVkQXJyYXlGcm9tLmNhbGwoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHtcbiAgICAgICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgICAgICBieXRlT2Zmc2V0OiBieXRlT2Zmc2V0LFxuICAgICAgICAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgdmlldzogbmV3IERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkgYWRkRWxlbWVudCh0aGF0LCBpbmRleCsrKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob2JqZWN0U2V0UHJvdG90eXBlT2YpIG9iamVjdFNldFByb3RvdHlwZU9mKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgVHlwZWRBcnJheSk7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUgPSBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlID0gb2JqZWN0Q3JlYXRlKFR5cGVkQXJyYXlQcm90b3R5cGUpO1xuICAgIH0gZWxzZSBpZiAodHlwZWRBcnJheXNDb25zdHJ1Y3RvcnNSZXF1aXJlc1dyYXBwZXJzKSB7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uIChkdW1teSwgZGF0YSwgdHlwZWRBcnJheU9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKGR1bW15LCBUeXBlZEFycmF5Q29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUpO1xuICAgICAgICByZXR1cm4gaW5oZXJpdElmUmVxdWlyZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHJldHVybiBuZXcgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKHRvSW5kZXgoZGF0YSkpO1xuICAgICAgICAgIGlmIChpc0FycmF5QnVmZmVyKGRhdGEpKSByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IoZGF0YSwgdG9PZmZzZXQodHlwZWRBcnJheU9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiB0eXBlZEFycmF5T2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKGRhdGEsIHRvT2Zmc2V0KHR5cGVkQXJyYXlPZmZzZXQsIEJZVEVTKSlcbiAgICAgICAgICAgICAgOiBuZXcgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKGRhdGEpO1xuICAgICAgICAgIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkpIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuICAgICAgICAgIHJldHVybiB0eXBlZEFycmF5RnJvbS5jYWxsKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgZGF0YSk7XG4gICAgICAgIH0oKSwgZHVtbXksIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcik7XG4gICAgICB9KTtcblxuICAgICAgaWYgKG9iamVjdFNldFByb3RvdHlwZU9mKSBvYmplY3RTZXRQcm90b3R5cGVPZihUeXBlZEFycmF5Q29uc3RydWN0b3IsIFR5cGVkQXJyYXkpO1xuICAgICAgZm9yRWFjaChnZXRPd25Qcm9wZXJ0eU5hbWVzKE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBrZXksIE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcltrZXldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlO1xuICAgIH1cblxuICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUuY29uc3RydWN0b3IgIT09IFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheUNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBpZiAoVFlQRURfQVJSQVlfVEFHKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLCBUWVBFRF9BUlJBWV9UQUcsIENPTlNUUlVDVE9SX05BTUUpO1xuICAgIH1cblxuICAgIGV4cG9ydGVkW0NPTlNUUlVDVE9SX05BTUVdID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG4gICAgX2V4cG9ydCh7XG4gICAgICBnbG9iYWw6IHRydWUsIGZvcmNlZDogVHlwZWRBcnJheUNvbnN0cnVjdG9yICE9IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3Rvciwgc2hhbTogIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1NcbiAgICB9LCBleHBvcnRlZCk7XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3IpKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuICAgIH1cblxuICAgIGlmICghKEJZVEVTX1BFUl9FTEVNRU5UIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG4gICAgfVxuXG4gICAgc2V0U3BlY2llcyhDT05TVFJVQ1RPUl9OQU1FKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbn0pO1xuXG4vLyBgRmxvYXQzMkFycmF5YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXG50eXBlZEFycmF5Q29uc3RydWN0b3IoJ0Zsb2F0MzInLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuLy8gYEZsb2F0NjRBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXR5cGVkYXJyYXktb2JqZWN0c1xudHlwZWRBcnJheUNvbnN0cnVjdG9yKCdGbG9hdDY0JywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0NjRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cbi8vIGBJbnQ4QXJyYXlgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcbnR5cGVkQXJyYXlDb25zdHJ1Y3RvcignSW50OCcsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG4vLyBgSW50MTZBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXR5cGVkYXJyYXktb2JqZWN0c1xudHlwZWRBcnJheUNvbnN0cnVjdG9yKCdJbnQxNicsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuLy8gYEludDMyQXJyYXlgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcbnR5cGVkQXJyYXlDb25zdHJ1Y3RvcignSW50MzInLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cbi8vIGBVaW50OEFycmF5YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXG50eXBlZEFycmF5Q29uc3RydWN0b3IoJ1VpbnQ4JywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG4vLyBgVWludDhDbGFtcGVkQXJyYXlgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcbnR5cGVkQXJyYXlDb25zdHJ1Y3RvcignVWludDgnLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhDbGFtcGVkQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0sIHRydWUpO1xuXG4vLyBgVWludDE2QXJyYXlgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcbnR5cGVkQXJyYXlDb25zdHJ1Y3RvcignVWludDE2JywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuLy8gYFVpbnQzMkFycmF5YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXG50eXBlZEFycmF5Q29uc3RydWN0b3IoJ1VpbnQzMicsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cbnZhciBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kJDEgPSBhcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2Q7XG5cblxuLy8gYCVUeXBlZEFycmF5JS5mcm9tYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5mcm9tXG5leHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kJDEoJ2Zyb20nLCB0eXBlZEFycmF5RnJvbSwgdHlwZWRBcnJheXNDb25zdHJ1Y3RvcnNSZXF1aXJlc1dyYXBwZXJzKTtcblxudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IkMiA9IGFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbnZhciBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kJDIgPSBhcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2Q7XG5cbi8vIGAlVHlwZWRBcnJheSUub2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLm9mXG5leHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kJDIoJ29mJywgZnVuY3Rpb24gb2YoLyogLi4uaXRlbXMgKi8pIHtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBuZXcgKGFUeXBlZEFycmF5Q29uc3RydWN0b3IkMih0aGlzKSkobGVuZ3RoKTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICByZXR1cm4gcmVzdWx0O1xufSwgdHlwZWRBcnJheXNDb25zdHJ1Y3RvcnNSZXF1aXJlc1dyYXBwZXJzKTtcblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzJDEob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMkMShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyBDb3B5cmlnaHQgTm9kZS5qcyBjb250cmlidXRvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG52YXIga05vZGVNb2R1bGVzUkUgPSAvXiguKilbXFxcXC9dbm9kZV9tb2R1bGVzW1xcXFwvXS87XG52YXIgY3VzdG9tSW5zcGVjdFN5bWJvbCA9IFN5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyk7XG52YXIgaXNCdWZmZXIgPSBTeW1ib2wuZm9yKCd0aXRhbml1bS5idWZmZXIuaXNCdWZmZXInKTtcbnZhciBjb2xvclJlZ0V4cCA9IC9cXHUwMDFiXFxbXFxkXFxkP20vZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG5cbmZ1bmN0aW9uIHJlbW92ZUNvbG9ycyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNvbG9yUmVnRXhwLCAnJyk7XG59XG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgLy8gQW4gZXJyb3IgY291bGQgYmUgYW4gaW5zdGFuY2Ugb2YgRXJyb3Igd2hpbGUgbm90IGJlaW5nIGEgbmF0aXZlIGVycm9yXG4gIC8vIG9yIGNvdWxkIGJlIGZyb20gYSBkaWZmZXJlbnQgcmVhbG0gYW5kIG5vdCBiZSBpbnN0YW5jZSBvZiBFcnJvciBidXQgc3RpbGxcbiAgLy8gYmUgYSBuYXRpdmUgZXJyb3IuXG4gIHJldHVybiBpc05hdGl2ZUVycm9yKGUpIHx8IGUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbnZhciBnZXRTdHJ1Y3R1cmVkU3RhY2s7XG5cbmNsYXNzIFN0YWNrVHJhY2VFcnJvciBleHRlbmRzIEVycm9yIHt9XG5cblN0YWNrVHJhY2VFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IChlcnIsIHRyYWNlKSA9PiB0cmFjZTtcblxuU3RhY2tUcmFjZUVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IEluZmluaXR5O1xuZnVuY3Rpb24gaXNJbnNpZGVOb2RlTW9kdWxlcygpIHtcbiAgaWYgKGdldFN0cnVjdHVyZWRTdGFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZ2V0U3RydWN0dXJlZFN0YWNrID0gKCkgPT4gbmV3IFN0YWNrVHJhY2VFcnJvcigpLnN0YWNrO1xuICB9XG5cbiAgdmFyIHN0YWNrID0gZ2V0U3RydWN0dXJlZFN0YWNrKCk7IC8vIHN0YWNrIGlzIG9ubHkgYW4gYXJyYXkgb24gdjgsIHRyeSB0byBjb252ZXJ0IG1hbnVhbGx5IGlmIHN0cmluZ1xuXG4gIGlmICh0eXBlb2Ygc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHN0YWNrRnJhbWVzID0gW107XG4gICAgdmFyIGxpbmVzID0gc3RhY2suc3BsaXQoL1xcbi8pO1xuXG4gICAgZm9yICh2YXIgbGluZSBvZiBsaW5lcykge1xuICAgICAgdmFyIGxpbmVJbmZvID0gbGluZS5tYXRjaCgvKC4qKUAoLiopOihcXGQrKTooXFxkKykvKTtcblxuICAgICAgaWYgKGxpbmVJbmZvKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGZpbGVuYW1lID0gbGluZUluZm9bMl0ucmVwbGFjZSgnZmlsZTovLycsICcnKTtcbiAgICAgICAgICBzdGFja0ZyYW1lcy5wdXNoKHtcbiAgICAgICAgICAgIGdldEZpbGVOYW1lOiAoKSA9PiBmaWxlbmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YWNrID0gc3RhY2tGcmFtZXM7XG4gIH0gLy8gSXRlcmF0ZSBvdmVyIGFsbCBzdGFjayBmcmFtZXMgYW5kIGxvb2sgZm9yIHRoZSBmaXJzdCBvbmUgbm90IGNvbWluZ1xuICAvLyBmcm9tIGluc2lkZSBOb2RlLmpzIGl0c2VsZjpcblxuXG4gIGlmIChBcnJheS5pc0FycmF5KHN0YWNrKSkge1xuICAgIGZvciAodmFyIGZyYW1lIG9mIHN0YWNrKSB7XG4gICAgICB2YXIgZmlsZW5hbWUgPSBmcmFtZS5nZXRGaWxlTmFtZSgpOyAvLyBJZiBhIGZpbGVuYW1lIGRvZXMgbm90IHN0YXJ0IHdpdGggLyBvciBjb250YWluIFxcLFxuICAgICAgLy8gaXQncyBsaWtlbHkgZnJvbSBOb2RlLmpzIGNvcmUuXG5cbiAgICAgIGlmICghL15cXC98XFxcXC8udGVzdChmaWxlbmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrTm9kZU1vZHVsZXNSRS50ZXN0KGZpbGVuYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBqb2luKG91dHB1dCwgc2VwYXJhdG9yKSB7XG4gIHZhciBzdHIgPSAnJztcblxuICBpZiAob3V0cHV0Lmxlbmd0aCAhPT0gMCkge1xuICAgIHZhciBsYXN0SW5kZXggPSBvdXRwdXQubGVuZ3RoIC0gMTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdEluZGV4OyBpKyspIHtcbiAgICAgIC8vIEl0IGlzIGZhc3RlciBub3QgdG8gdXNlIGEgdGVtcGxhdGUgc3RyaW5nIGhlcmVcbiAgICAgIHN0ciArPSBvdXRwdXRbaV07XG4gICAgICBzdHIgKz0gc2VwYXJhdG9yO1xuICAgIH1cblxuICAgIHN0ciArPSBvdXRwdXRbbGFzdEluZGV4XTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGYuY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xuICB9O1xufVxudmFyIEFMTF9QUk9QRVJUSUVTID0gMDtcbnZhciBPTkxZX0VOVU1FUkFCTEUgPSAyO1xudmFyIHByb3BlcnR5RmlsdGVyID0ge1xuICBBTExfUFJPUEVSVElFUyxcbiAgT05MWV9FTlVNRVJBQkxFXG59O1xuZnVuY3Rpb24gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKG9iaiwgZmlsdGVyKSB7XG4gIHZhciBwcm9wcyA9IFtdO1xuICB2YXIga2V5cyA9IGZpbHRlciA9PT0gT05MWV9FTlVNRVJBQkxFID8gT2JqZWN0LmtleXMob2JqKSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICBpZiAoIWlzQWxsRGlnaXRzKGtleSkpIHtcbiAgICAgIHByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvcHM7XG59XG5cbmZ1bmN0aW9uIGlzQWxsRGlnaXRzKHMpIHtcbiAgaWYgKHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNvZGUgPSBzLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1Nykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBDb3B5cmlnaHQgTm9kZS5qcyBjb250cmlidXRvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG52YXIgVHlwZWRBcnJheVByb3RvdHlwZSQxID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKFVpbnQ4QXJyYXkucHJvdG90eXBlKTtcbnZhciBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcgPSB1bmN1cnJ5VGhpcyhPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFR5cGVkQXJyYXlQcm90b3R5cGUkMSwgU3ltYm9sLnRvU3RyaW5nVGFnKS5nZXQpO1xuXG5mdW5jdGlvbiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgXCIuY29uY2F0KG5hbWUsIFwiXVwiKTtcbn1cblxuZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzQXJndW1lbnRzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ0FyZ3VtZW50cycpO1xufVxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tQcm90b3R5cGUodmFsdWUsICdBcnJheUJ1ZmZlcicpO1xufSAvLyBDYWNoZWQgdG8gbWFrZSBzdXJlIG5vIHVzZXJsYW5kIGNvZGUgY2FuIHRhbXBlciB3aXRoIGl0LlxuXG52YXIgaXNBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXc7XG5mdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnQXN5bmNGdW5jdGlvbicpO1xufVxuZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnQmlnSW50NjRBcnJheSc7XG59XG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ0Jvb2xlYW4nKTtcbn1cbmZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNOdW1iZXJPYmplY3QodmFsdWUpIHx8IGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB8fCBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIC8vIHx8IGlzQmlnSW50T2JqZWN0KHZhbHVlKVxuICB8fCBpc1N5bWJvbE9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0RhdGFWaWV3KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ0RhdGFWaWV3Jyk7XG59XG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnRGF0ZScpO1xufSAvLyBAdG9kbyBpc0V4dGVybmFsXG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnRmxvYXQ2NEFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnR2VuZXJhdG9yRnVuY3Rpb24nKTtcbn1cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ0dlbmVyYXRvck9iamVjdCcpO1xufVxuZnVuY3Rpb24gaXNJbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdJbnQ4QXJyYXknO1xufVxuZnVuY3Rpb24gaXNJbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnSW50MTZBcnJheSc7XG59XG5mdW5jdGlvbiBpc0ludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdJbnQzMkFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzTWFwKHZhbHVlKSB7XG4gIHJldHVybiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ01hcCcpO1xufVxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICByZXR1cm4gcHJvdG90eXBlICYmIHByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTWFwIEl0ZXJhdG9yJztcbn0gLy8gQHRvZG8gaXNNb2R1bGVOYW1lc3BhY2VPYmplY3RcblxuZnVuY3Rpb24gaXNOYXRpdmVFcnJvcih2YWx1ZSkge1xuICAvLyBpZiBub3QgYW4gaW5zdGFuY2Ugb2YgYW4gRXJyb3IsIGRlZmluaXRlbHkgbm90IGEgbmF0aXZlIGVycm9yXG4gIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gWydFcnJvcicsICdFdmFsRXJyb3InLCAnUmFuZ2VFcnJvcicsICdSZWZlcmVuY2VFcnJvcicsICdTeW50YXhFcnJvcicsICdUeXBlRXJyb3InLCAnVVJJRXJyb3InXS5pbmNsdWRlcyh2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ051bWJlcicpO1xufVxuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gIHJldHVybiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1Byb21pc2UnKTtcbn0gLy8gQHRvZG8gaXNQcm94eVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tQcm90b3R5cGUodmFsdWUsICdSZWdFeHAnKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1NldCcpO1xufVxuZnVuY3Rpb24gaXNTZXRJdGVyYXRvcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICByZXR1cm4gcHJvdG90eXBlICYmIHByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnU2V0IEl0ZXJhdG9yJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKCFnbG9iYWwuU2hhcmVkQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gY2hlY2tQcm90b3R5cGUodmFsdWUsICdTaGFyZWRBcnJheUJ1ZmZlcicpO1xufVxuZnVuY3Rpb24gaXNTdHJpbmdPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnU3RyaW5nJyk7XG59XG5mdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tQcm90b3R5cGUodmFsdWUsICdTeW1ib2wnKTtcbn1cbmZ1bmN0aW9uIGlzVHlwZWRBcnJheSQxKHZhbHVlKSB7XG4gIHZhciBpc0J1aWx0SW5UeXBlZEFycmF5ID0gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSAhPT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0J1aWx0SW5UeXBlZEFycmF5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWVbaXNCdWZmZXJdID09PSB0cnVlO1xufVxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnVWludDhBcnJheSc7XG59XG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5mdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnV2Vha01hcCcpO1xufVxuZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1dlYWtTZXQnKTtcbn0gLy8gQHRvZG8gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlXG5cbnZhciB0eXBlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRpc0FueUFycmF5QnVmZmVyOiBpc0FueUFycmF5QnVmZmVyLFxuXHRpc0FyZ3VtZW50c09iamVjdDogaXNBcmd1bWVudHNPYmplY3QsXG5cdGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG5cdGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcblx0aXNBc3luY0Z1bmN0aW9uOiBpc0FzeW5jRnVuY3Rpb24sXG5cdGlzQmlnSW50NjRBcnJheTogaXNCaWdJbnQ2NEFycmF5LFxuXHRpc0JpZ1VpbnQ2NEFycmF5OiBpc0JpZ1VpbnQ2NEFycmF5LFxuXHRpc0Jvb2xlYW5PYmplY3Q6IGlzQm9vbGVhbk9iamVjdCxcblx0aXNCb3hlZFByaW1pdGl2ZTogaXNCb3hlZFByaW1pdGl2ZSxcblx0aXNEYXRhVmlldzogaXNEYXRhVmlldyxcblx0aXNEYXRlOiBpc0RhdGUsXG5cdGlzRmxvYXQzMkFycmF5OiBpc0Zsb2F0MzJBcnJheSxcblx0aXNGbG9hdDY0QXJyYXk6IGlzRmxvYXQ2NEFycmF5LFxuXHRpc0dlbmVyYXRvckZ1bmN0aW9uOiBpc0dlbmVyYXRvckZ1bmN0aW9uLFxuXHRpc0dlbmVyYXRvck9iamVjdDogaXNHZW5lcmF0b3JPYmplY3QsXG5cdGlzSW50OEFycmF5OiBpc0ludDhBcnJheSxcblx0aXNJbnQxNkFycmF5OiBpc0ludDE2QXJyYXksXG5cdGlzSW50MzJBcnJheTogaXNJbnQzMkFycmF5LFxuXHRpc01hcDogaXNNYXAsXG5cdGlzTWFwSXRlcmF0b3I6IGlzTWFwSXRlcmF0b3IsXG5cdGlzTmF0aXZlRXJyb3I6IGlzTmF0aXZlRXJyb3IsXG5cdGlzTnVtYmVyT2JqZWN0OiBpc051bWJlck9iamVjdCxcblx0aXNQcm9taXNlOiBpc1Byb21pc2UsXG5cdGlzUmVnRXhwOiBpc1JlZ0V4cCxcblx0aXNTZXQ6IGlzU2V0LFxuXHRpc1NldEl0ZXJhdG9yOiBpc1NldEl0ZXJhdG9yLFxuXHRpc1NoYXJlZEFycmF5QnVmZmVyOiBpc1NoYXJlZEFycmF5QnVmZmVyLFxuXHRpc1N0cmluZ09iamVjdDogaXNTdHJpbmdPYmplY3QsXG5cdGlzU3ltYm9sT2JqZWN0OiBpc1N5bWJvbE9iamVjdCxcblx0aXNUeXBlZEFycmF5OiBpc1R5cGVkQXJyYXkkMSxcblx0aXNVaW50OEFycmF5OiBpc1VpbnQ4QXJyYXksXG5cdGlzVWludDhDbGFtcGVkQXJyYXk6IGlzVWludDhDbGFtcGVkQXJyYXksXG5cdGlzVWludDE2QXJyYXk6IGlzVWludDE2QXJyYXksXG5cdGlzVWludDMyQXJyYXk6IGlzVWludDMyQXJyYXksXG5cdGlzV2Vha01hcDogaXNXZWFrTWFwLFxuXHRpc1dlYWtTZXQ6IGlzV2Vha1NldFxufSk7XG5cbi8vIENvcHlyaWdodCBOb2RlLmpzIGNvbnRyaWJ1dG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbnZhciBlcnJvcjtcblxuZnVuY3Rpb24gbGF6eUVycm9yKCkge1xuICBpZiAoIWVycm9yKSB7XG4gICAgLy8gQGZpeG1lIHJvbGx1cCBjYW5ub3QgaGFuZGxlIGxhenkgbG9hZGVkIG1vZHVsZXMsIG1heWJlIG1vdmUgdG8gd2VicGFjaz9cbiAgICAvLyBlcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuY29kZXMuRVJSX0lOVEVSTkFMX0FTU0VSVElPTjtcbiAgICBlcnJvciA9IGNvZGVzLkVSUl9JTlRFUk5BTF9BU1NFUlRJT047XG4gIH1cblxuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdmFyIEVSUl9JTlRFUk5BTF9BU1NFUlRJT04gPSBsYXp5RXJyb3IoKTtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVEVSTkFMX0FTU0VSVElPTihtZXNzYWdlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmYWlsKG1lc3NhZ2UpIHtcbiAgdmFyIEVSUl9JTlRFUk5BTF9BU1NFUlRJT04gPSBsYXp5RXJyb3IoKTtcbiAgdGhyb3cgbmV3IEVSUl9JTlRFUk5BTF9BU1NFUlRJT04obWVzc2FnZSk7XG59XG5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gQ29weXJpZ2h0IE5vZGUuanMgY29udHJpYnV0b3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxudmFyIG1lc3NhZ2VzID0gbmV3IE1hcCgpO1xudmFyIGNvZGVzID0ge307IC8vIEB0b2RvIGltcGxlbWVudCB0aGlzIG9uY2UgbmVlZGVkXG5cbmNsYXNzIFN5c3RlbUVycm9yIGV4dGVuZHMgRXJyb3Ige30gLy8gVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmVnaXN0ZXJpbmcgdGhlIGVycm9yIGNvZGVzLlxuXG5cbmZ1bmN0aW9uIEUoc3ltLCB2YWwsIGRlZiwgLi4ub3RoZXJDbGFzc2VzKSB7XG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgU3lzdGVtRXJyb3IgdGhhdCBmb3JtYXRzIHRoZSBlcnJvciBtZXNzYWdlIGRpZmZlcmVudGx5XG4gIC8vIFRoZSBTeXN0ZW1FcnJvcnMgb25seSBoYXZlIFN5c3RlbUVycm9yIGFzIHRoZWlyIGJhc2UgY2xhc3Nlcy5cbiAgbWVzc2FnZXMuc2V0KHN5bSwgdmFsKTtcblxuICBpZiAoZGVmID09PSBTeXN0ZW1FcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBjb21wYXRpYmxlIFN5c3RlbUVycm9yIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gIH0gZWxzZSB7XG4gICAgZGVmID0gbWFrZU5vZGVFcnJvcldpdGhDb2RlKGRlZiwgc3ltKTtcbiAgfVxuXG4gIGlmIChvdGhlckNsYXNzZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgb3RoZXJDbGFzc2VzLmZvckVhY2goY2xhenogPT4ge1xuICAgICAgZGVmW2NsYXp6Lm5hbWVdID0gbWFrZU5vZGVFcnJvcldpdGhDb2RlKGNsYXp6LCBzeW0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29kZXNbc3ltXSA9IGRlZjtcbn1cblxuZnVuY3Rpb24gbWFrZU5vZGVFcnJvcldpdGhDb2RlKEJhc2UsIGtleSkge1xuICByZXR1cm4gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHZhciBtZXNzYWdlID0gZ2V0TWVzc2FnZShrZXksIGFyZ3MsIHRoaXMpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICB2YWx1ZTogbWVzc2FnZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgYWRkQ29kZVRvTmFtZSh0aGlzLCBzdXBlci5uYW1lLCBrZXkpO1xuICAgIH1cblxuICAgIGdldCBjb2RlKCkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICBzZXQgY29kZSh2YWx1ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2RlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5uYW1lLCBcIiBbXCIpLmNvbmNhdChrZXksIFwiXTogXCIpLmNvbmNhdCh0aGlzLm1lc3NhZ2UpO1xuICAgIH1cblxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRNZXNzYWdlKGtleSwgYXJncywgc2VsZikge1xuICB2YXIgbXNnID0gbWVzc2FnZXMuZ2V0KGtleSk7XG4gIC8qXG4gIC8vIEBmaXhtZSByb2xsdXAgY2Fubm90IGhhbmRsZSBsYXp5IGxvYWRlZCBtb2R1bGVzLCBtYXliZSBtb3ZlIHRvIHdlYnBhY2s/XG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkge1xuICBcdGFzc2VydCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvYXNzZXJ0Jyk7XG4gIH1cbiAgKi9cblxuICBpZiAodHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFzc2VydChtc2cubGVuZ3RoIDw9IGFyZ3MubGVuZ3RoLCAvLyBEZWZhdWx0IG9wdGlvbnMgZG8gbm90IGNvdW50LlxuICAgIFwiQ29kZTogXCIuY29uY2F0KGtleSwgXCI7IFRoZSBwcm92aWRlZCBhcmd1bWVudHMgbGVuZ3RoIChcIikuY29uY2F0KGFyZ3MubGVuZ3RoLCBcIikgZG9lcyBub3QgXCIpICsgXCJtYXRjaCB0aGUgcmVxdWlyZWQgb25lcyAoXCIuY29uY2F0KG1zZy5sZW5ndGgsIFwiKS5cIikpO1xuICAgIHJldHVybiBtc2cuYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICB2YXIgZXhwZWN0ZWRMZW5ndGggPSAobXNnLm1hdGNoKC8lW2RmaWpvT3NdL2cpIHx8IFtdKS5sZW5ndGg7XG4gIGFzc2VydChleHBlY3RlZExlbmd0aCA9PT0gYXJncy5sZW5ndGgsIFwiQ29kZTogXCIuY29uY2F0KGtleSwgXCI7IFRoZSBwcm92aWRlZCBhcmd1bWVudHMgbGVuZ3RoIChcIikuY29uY2F0KGFyZ3MubGVuZ3RoLCBcIikgZG9lcyBub3QgXCIpICsgXCJtYXRjaCB0aGUgcmVxdWlyZWQgb25lcyAoXCIuY29uY2F0KGV4cGVjdGVkTGVuZ3RoLCBcIikuXCIpKTtcblxuICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbXNnO1xuICB9XG5cbiAgYXJncy51bnNoaWZ0KG1zZyk7XG4gIHJldHVybiBmb3JtYXQuYXBwbHkobnVsbCwgYXJncyk7IC8vIEBmaXhtZSByb2xsdXAgY2Fubm90IGhhbmRsZSBsYXp5IGxvYWRlZCBtb2R1bGVzLCBtYXliZSBtb3ZlIHRvIHdlYnBhY2s/XG4gIC8vIHJldHVybiBsYXp5SW50ZXJuYWxVdGlsSW5zcGVjdCgpLmZvcm1hdC5hcHBseShudWxsLCBhcmdzKTtcbn1cblxuZnVuY3Rpb24gYWRkQ29kZVRvTmFtZShlcnIsIG5hbWUsIGNvZGUpIHtcbiAgLy8gQWRkIHRoZSBlcnJvciBjb2RlIHRvIHRoZSBuYW1lIHRvIGluY2x1ZGUgaXQgaW4gdGhlIHN0YWNrIHRyYWNlLlxuICBlcnIubmFtZSA9IFwiXCIuY29uY2F0KG5hbWUsIFwiIFtcIikuY29uY2F0KGNvZGUsIFwiXVwiKTsgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgLy8gZnJvbSB0aGUgbmFtZS5cbiAgLy8gQGZpeG1lOiBUaGlzIG9ubHkgd29ya3Mgb24gVjgvQW5kcm9pZCwgaU9TL0pTQyBoYXMgYSBkaWZmZXJlbnQgRXJyb3Igc3RydWN0dXJlLlxuICAvLyBzaG91bGQgd2UgdHJ5IHRvIG1ha2UgZXJyb3JzIGJlaGF2ZSB0aGUgc2FtZSBhY3Jvc3MgcGxhdGZvcm1zP1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cbiAgZXJyLnN0YWNrOyAvLyBSZXNldCB0aGUgbmFtZSB0byB0aGUgYWN0dWFsIG5hbWUuXG5cbiAgaWYgKG5hbWUgPT09ICdTeXN0ZW1FcnJvcicpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBlcnIubmFtZTtcbiAgfVxufVxuXG5FKCdFUlJfSU5URVJOQUxfQVNTRVJUSU9OJywgbWVzc2FnZSA9PiB7XG4gIHZhciBzdWZmaXggPSAnVGhpcyBpcyBjYXVzZWQgYnkgZWl0aGVyIGEgYnVnIGluIFRpdGFuaXVtICcgKyAnb3IgaW5jb3JyZWN0IHVzYWdlIG9mIFRpdGFuaXVtIGludGVybmFscy5cXG4nICsgJ1BsZWFzZSBvcGVuIGFuIGlzc3VlIHdpdGggdGhpcyBzdGFjayB0cmFjZSBhdCAnICsgJ2h0dHBzOi8vamlyYS5hcHBjZWxlcmF0b3Iub3JnXFxuJztcbiAgcmV0dXJuIG1lc3NhZ2UgPT09IHVuZGVmaW5lZCA/IHN1ZmZpeCA6IFwiXCIuY29uY2F0KG1lc3NhZ2UsIFwiXFxuXCIpLmNvbmNhdChzdWZmaXgpO1xufSwgRXJyb3IpO1xuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkgPT4ge1xuICBhc3NlcnQodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCAnXFwnbmFtZVxcJyBtdXN0IGJlIGEgc3RyaW5nJyk7IC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG5cbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgZXhwZWN0ZWQuc3RhcnRzV2l0aCgnbm90ICcpKSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICB9XG5cbiAgdmFyIG1zZztcblxuICBpZiAobmFtZS5lbmRzV2l0aCgnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gXCJUaGUgXCIuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHR5cGUgPSBuYW1lLmluY2x1ZGVzKCcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gLy8gVE9ETyhCcmlkZ2VBUik6IEltcHJvdmUgdGhlIG91dHB1dCBieSBzaG93aW5nIGBudWxsYCBhbmQgc2ltaWxhci5cblxuXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQodHlwZW9mIGFjdHVhbCk7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xudmFyIG1heFN0YWNrX0Vycm9yTmFtZTtcbnZhciBtYXhTdGFja19FcnJvck1lc3NhZ2U7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgZXJyLm5hbWVgIGFuZCBgZXJyLm1lc3NhZ2VgIGFyZSBlcXVhbCB0byBlbmdpbmUtc3BlY2lmaWNcbiAqIHZhbHVlcyBpbmRpY2F0aW5nIG1heCBjYWxsIHN0YWNrIHNpemUgaGFzIGJlZW4gZXhjZWVkZWQuXG4gKiBcIk1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIgaW4gVjguXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvciB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNTdGFja092ZXJmbG93RXJyb3IoZXJyKSB7XG4gIGlmIChtYXhTdGFja19FcnJvck1lc3NhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHRyeSB7XG4gICAgICBmdW5jdGlvbiBvdmVyZmxvd1N0YWNrKCkge1xuICAgICAgICBvdmVyZmxvd1N0YWNrKCk7XG4gICAgICB9XG5cbiAgICAgIG92ZXJmbG93U3RhY2soKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBtYXhTdGFja19FcnJvck1lc3NhZ2UgPSBlLm1lc3NhZ2U7XG4gICAgICBtYXhTdGFja19FcnJvck5hbWUgPSBlLm5hbWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVyci5uYW1lID09PSBtYXhTdGFja19FcnJvck5hbWUgJiYgZXJyLm1lc3NhZ2UgPT09IG1heFN0YWNrX0Vycm9yTWVzc2FnZTtcbn1cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGFzc2VydCh0eXBlb2YgdGhpbmcgPT09ICdzdHJpbmcnLCAnYHRoaW5nYCBoYXMgdG8gYmUgb2YgdHlwZSBzdHJpbmcnKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGFzc2VydChsZW4gPiAwLCAnQXQgbGVhc3Qgb25lIGV4cGVjdGVkIHZhbHVlIG5lZWRzIHRvIGJlIHNwZWNpZmllZCcpO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGkgPT4gU3RyaW5nKGkpKTtcblxuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyksIFwiLCBvciBcIikgKyBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSwgXCIgb3IgXCIpLmNvbmNhdChleHBlY3RlZFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChTdHJpbmcoZXhwZWN0ZWQpKTtcbiAgfVxufVxuXG52YXIge1xuICBBTExfUFJPUEVSVElFUzogQUxMX1BST1BFUlRJRVMkMSxcbiAgT05MWV9FTlVNRVJBQkxFOiBPTkxZX0VOVU1FUkFCTEUkMVxufSA9IHByb3BlcnR5RmlsdGVyOyAvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2J1ZmZlci5odG1sI2J1ZmZlcl9idWZmZXJzX2FuZF9jaGFyYWN0ZXJfZW5jb2RpbmdzXG5cbnZhciBUSV9DT0RFQ19NQVAgPSBuZXcgTWFwKCk7XG5USV9DT0RFQ19NQVAuc2V0KCd1dGYtOCcsIFRpLkNvZGVjLkNIQVJTRVRfVVRGOCk7XG5USV9DT0RFQ19NQVAuc2V0KCd1dGY4JywgVGkuQ29kZWMuQ0hBUlNFVF9VVEY4KTtcblRJX0NPREVDX01BUC5zZXQoJ3V0Zi0xNmxlJywgVGkuQ29kZWMuQ0hBUlNFVF9VVEYxNkxFKTtcblRJX0NPREVDX01BUC5zZXQoJ3V0ZjE2bGUnLCBUaS5Db2RlYy5DSEFSU0VUX1VURjE2TEUpO1xuVElfQ09ERUNfTUFQLnNldCgndWNzMicsIFRpLkNvZGVjLkNIQVJTRVRfVVRGMTZMRSk7XG5USV9DT0RFQ19NQVAuc2V0KCd1Y3MtMicsIFRpLkNvZGVjLkNIQVJTRVRfVVRGMTZMRSk7XG5USV9DT0RFQ19NQVAuc2V0KCdsYXRpbjEnLCBUaS5Db2RlYy5DSEFSU0VUX0lTT19MQVRJTl8xKTtcblRJX0NPREVDX01BUC5zZXQoJ2JpbmFyeScsIFRpLkNvZGVjLkNIQVJTRVRfSVNPX0xBVElOXzEpO1xuVElfQ09ERUNfTUFQLnNldCgnYXNjaWknLCBUaS5Db2RlYy5DSEFSU0VUX0FTQ0lJKTsgLy8gV2UgaGF2ZSBubyBlcXVpdmFsZW50cyBvZiBiYXNlNjQgb3IgaGV4LCBzbyB3ZSBjb252ZXJ0IHRoZW0gaW50ZXJuYWxseSBoZXJlXG5cbnZhciBWQUxJRF9FTkNPRElOR1MgPSBbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2xhdGluMScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZSddOyAvLyBVc2VkIHRvIGNoZWF0IGZvciByZWFkL3dyaXRlcyBvZiBkb3VibGVzXG5cbnZhciBkb3VibGVBcnJheSA9IG5ldyBGbG9hdDY0QXJyYXkoMSk7XG52YXIgdWludDhEb3VibGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGRvdWJsZUFycmF5LmJ1ZmZlcik7IC8vIFVzZWQgdG8gY2hlYXQgdG8gcmVhZC93cml0ZSBmbG9hdHNcblxudmFyIGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xudmFyIHVpbnQ4RmxvYXRBcnJheSA9IG5ldyBVaW50OEFycmF5KGZsb2F0QXJyYXkuYnVmZmVyKTtcbnZhciBJTlNQRUNUX01BWF9CWVRFUyA9IDUwO1xuXG5jbGFzcyBCdWZmZXIkMSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlci5cbiAgICpcbiAgICogUHJpbWFyaWx5IHVzZWQgaW50ZXJuYWxseSBpbiB0aGlzIG1vZHVsZSB0b2dldGhlciB3aXRoIGBuZXdCdWZmZXJgIHRvXG4gICAqIGNyZWF0ZSBhIG5ldyBCdWZmZXIgaW5zdGFuY2Ugd3JhcHBpbmcgYSBUaS5CdWZmZXIuXG4gICAqXG4gICAqIEFsc28gc3VwcG9ydHMgdGhlIGRlcHJlY2F0ZWQgQnVmZmVyKCkgY29uc3RydWN0b3JzIHdoaWNoIGFyZSBzYWZlXG4gICAqIHRvIHVzZSBvdXRzaWRlIG9mIHRoaXMgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ludGVnZXJbXXxCdWZmZXJ8aW50ZWdlcnxzdHJpbmd8VGkuQnVmZmVyfSBhcmdcbiAgICogQHBhcmFtIHtzdHJpbmd8aW50ZWdlcn0gZW5jb2RpbmdPck9mZnNldFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3IoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ29iamVjdCcgfHwgYXJnLmFwaU5hbWUgIT09ICdUaS5CdWZmZXInKSB7XG4gICAgICBzaG93RmxhZ2dlZERlcHJlY2F0aW9uKCk7XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBcXFwic3RyaW5nXFxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgXFxcInN0cmluZ1xcXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KHR5cGVvZiBhcmcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBCdWZmZXIkMS5hbGxvYyhhcmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQnVmZmVyJDEuZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIHRpQnVmZmVyID0gYXJnO1xuICAgIHZhciBzdGFydCA9IGVuY29kaW5nT3JPZmZzZXQ7XG5cbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGVuZ3RoID0gdGlCdWZmZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgYnl0ZU9mZnNldDoge1xuICAgICAgICB2YWx1ZTogc3RhcnRcbiAgICAgIH0sXG4gICAgICBsZW5ndGg6IHtcbiAgICAgICAgdmFsdWU6IGxlbmd0aFxuICAgICAgfSxcbiAgICAgIF90aUJ1ZmZlcjoge1xuICAgICAgICB2YWx1ZTogdGlCdWZmZXJcbiAgICAgIH1cbiAgICB9KTsgLy8gRklYTUU6IFN1cHBvcnQgLmJ1ZmZlciBwcm9wZXJ0eSB0aGF0IGhvbGRzIGFuIEFycmF5QnVmZmVyIVxuICB9XG4gIC8qKlxuICAgKiAwIGlzIHJldHVybmVkIGlmIHRhcmdldCBpcyB0aGUgc2FtZSBhcyBidWZcbiAgICogMSBpcyByZXR1cm5lZCBpZiB0YXJnZXQgc2hvdWxkIGNvbWUgYmVmb3JlIGJ1ZiB3aGVuIHNvcnRlZC5cbiAgICogLTEgaXMgcmV0dXJuZWQgaWYgdGFyZ2V0IHNob3VsZCBjb21lIGFmdGVyIGJ1ZiB3aGVuIHNvcnRlZC5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IHRhcmdldCBCdWZmZXIgdG8gY29tcGFyZSBhZ2FpbnN0XG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW3RhcmdldFN0YXJ0PTBdIGluZGV4IHRvIHN0YXJ0IGluIHRhcmdldFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFt0YXJnZXRFbmQ9dGFyZ2V0Lmxlbmd0aF0gaW5kZXggdG8gZW5kIGluIHRhcmdldFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtzb3VyY2VTdGFydD0wXSBpbmRleCB0byBzdGFydCBpbiB0aGlzIEJ1ZmZlclxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtzb3VyY2VFbmQ9dGhpcy5sZW5ndGhdIGluZGV4IHRvIGVuZCBpbiB0aGlzIEJ1ZmZlclxuICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICovXG5cblxuICBjb21wYXJlKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHRhcmdldEVuZCwgc291cmNlU3RhcnQsIHNvdXJjZUVuZCkge1xuICAgIGlmICghQnVmZmVyJDEuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBcXFwidGFyZ2V0XFxcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdCh0eXBlb2YgYnVmMSkpO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXRTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXRTdGFydCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZVN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvdXJjZVN0YXJ0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0RW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldEVuZCA9IHRhcmdldC5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZUVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzb3VyY2VFbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9IC8vIEVSUl9PVVRfT0ZfUkFOR0UgaXMgdGhyb3duIGlmIHRhcmdldFN0YXJ0IDwgMCwgc291cmNlU3RhcnQgPCAwLCB0YXJnZXRFbmQgPiB0YXJnZXQuYnl0ZUxlbmd0aCwgb3Igc291cmNlRW5kID4gc291cmNlLmJ5dGVMZW5ndGhcblxuXG4gICAgaWYgKHRhcmdldFN0YXJ0IDwgMCB8fCBzb3VyY2VTdGFydCA8IDAgfHwgdGFyZ2V0RW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCBzb3VyY2VFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpOyAvLyBGSVhNRTogc2V0IFwiY29kZVwiIHRvIEVSUl9JTkRFWF9PVVRfT0ZfUkFOR0VcbiAgICB9IC8vIFVzZSBzbGljZXMgdG8gbWFrZSB0aGUgbG9vcCBlYXNpZXJcblxuXG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuc2xpY2Uoc291cmNlU3RhcnQsIHNvdXJjZUVuZCk7XG4gICAgdmFyIHNvdXJjZUxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdmFyIGRlc3QgPSB0YXJnZXQuc2xpY2UodGFyZ2V0U3RhcnQsIHRhcmdldEVuZCk7XG4gICAgdmFyIGRlc3RMZW5ndGggPSBkZXN0Lmxlbmd0aDtcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oc291cmNlTGVuZ3RoLCBkZXN0TGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0YXJnZXRWYWx1ZSA9IGdldEFkanVzdGVkSW5kZXgoZGVzdCwgaSk7XG4gICAgICB2YXIgc291cmNlVmFsdWUgPSBnZXRBZGp1c3RlZEluZGV4KHNvdXJjZSwgaSk7XG5cbiAgICAgIGlmICh0YXJnZXRWYWx1ZSAhPT0gc291cmNlVmFsdWUpIHtcbiAgICAgICAgLy8gTm8gbWF0Y2ghIFJldHVybiAxIG9yIC0xIGJhc2VkIG9uIHdoYXQgaXMgZ3JlYXRlciFcbiAgICAgICAgaWYgKHNvdXJjZVZhbHVlIDwgdGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9IC8vIHNvcnQgYmFzZWQgb24gbGVuZ3RoIVxuXG5cbiAgICBpZiAoc291cmNlTGVuZ3RoIDwgZGVzdExlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2VMZW5ndGggPiBkZXN0TGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGZyb20gdGhpcyB0byB0YXJnZXRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IHRhcmdldCBkZXN0aW5hdGlvbiB3ZSdyZSBjb3B5aW5nIGludG9cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbdGFyZ2V0U3RhcnQ9MF0gc3RhcnQgaW5kZXggdG8gY29weSBpbnRvIGluIGRlc3RpbmF0aW9uIEJ1ZmZlclxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtzb3VyY2VTdGFydD0wXSBzdGFydCBpbmRleCB0byBjb3B5IGZyb20gd2l0aGluIGB0aGlzYFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtzb3VyY2VFbmQ9dGhpcy5sZW5ndGhdIGVuZCBpbmRleCB0byBjb3B5IGZyb20gd2l0aGluIGB0aGlzYFxuICAgKiBAcmV0dXJucyB7aW50ZWdlcn0gbnVtYmVyIG9mIGJ5dGVzIGNvcGllZFxuICAgKi9cblxuXG4gIGNvcHkodGFyZ2V0LCB0YXJnZXRTdGFydCwgc291cmNlU3RhcnQsIHNvdXJjZUVuZCkge1xuICAgIGlmICh0YXJnZXRTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXRTdGFydCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZVN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvdXJjZVN0YXJ0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvdXJjZUVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2VTdGFydCA9PT0gc291cmNlRW5kKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSAvLyBUT0RPOiBjaGVjayBmb3Igb3V0IG9mIGJvdW5kcz9cblxuXG4gICAgdmFyIGxlbmd0aCA9IHNvdXJjZUVuZCAtIHNvdXJjZVN0YXJ0OyAvLyBDYXAgbGVuZ3RoIHRvIHJlbWFpbmluZyBieXRlcyBpbiB0YXJnZXQhXG5cbiAgICB2YXIgcmVtYWluaW5nID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0O1xuXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH0gLy8gVE9ETzogaGFuZGxlIG92ZXJsYXAgd2hlbiB0YXJnZXQgPT09IHRoaXMhXG4gICAgLy8gVE9ETzogRG8gd2UgbmVlZCB0byB0YWtlIHRhcmdldCBvciB0aGlzLmJ5dGVPZmZzZXQgaW50byBhY2NvdW50IGhlcmU/XG5cblxuICAgIHRhcmdldC5fdGlCdWZmZXIuY29weSh0aGlzLl90aUJ1ZmZlciwgdGFyZ2V0U3RhcnQsIHNvdXJjZVN0YXJ0LCBsZW5ndGgpO1xuXG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBpdGVyYXRvciBvZiBbaW5kZXgsIGJ5dGVdIHBhaXJzIGZyb20gdGhlIGNvbnRlbnRzIG9mIGJ1Zi5cbiAgICogQHJldHVybnMge0l0ZXJhdG9yfVxuICAgKi9cblxuXG4gIGVudHJpZXMoKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXM7XG4gICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgdmFyIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIHZhciBlbnRyeUl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobmV4dEluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBbbmV4dEluZGV4LCBnZXRBZGp1c3RlZEluZGV4KGJ1ZmZlciwgbmV4dEluZGV4KV0sXG4gICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgW1N5bWJvbC5pdGVyYXRvcl06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gZW50cnlJdGVyYXRvcjtcbiAgfVxuXG4gIGVxdWFscyhvdGhlckJ1ZmZlcikge1xuICAgIGlmICghQnVmZmVyJDEuaXNCdWZmZXIob3RoZXJCdWZmZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJyk7XG4gICAgfVxuXG4gICAgaWYgKG90aGVyQnVmZmVyID09PSB0aGlzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb21wYXJlKG90aGVyQnVmZmVyKSA9PT0gMDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVJbnQ4QXJyYXl8aW50ZWdlcn0gdmFsdWUgVGhlIHZhbHVlIHdpdGggd2hpY2ggdG8gZmlsbCBgYnVmYC5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byBmaWxsIGBidWZgXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW2VuZF0gV2hlcmUgdG8gc3RvcCBmaWxsaW5nIGJ1ZiAobm90IGluY2x1c2l2ZSkuIGBidWYubGVuZ3RoYCBieSBkZWZhdWx0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBUaGUgZW5jb2RpbmcgZm9yIGB2YWx1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZy5cbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuXG5cbiAgZmlsbCh2YWx1ZSwgb2Zmc2V0LCBlbmQsIGVuY29kaW5nKSB7XG4gICAgdmFyIG9mZnNldFR5cGUgPSB0eXBlb2Ygb2Zmc2V0O1xuXG4gICAgaWYgKG9mZnNldFR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyB2YWx1ZSBzdXBwbGllZFxuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgfSBlbHNlIGlmIChvZmZzZXRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gdmFsdWUsIGVuY29kaW5nIHN1cHBsaWVkXG4gICAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyB2YWx1ZSwgb2Zmc2V0LCBlbmNvZGluZyBzdXBwbGllZFxuICAgICAgZW5jb2RpbmcgPSBlbmQ7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBidWZUb0ZpbGxXaXRoID0gQnVmZmVyJDEuZnJvbSh2YWx1ZSwgZW5jb2RpbmcpO1xuICAgICAgdmFyIGZpbGxCdWZMZW5ndGggPSBidWZUb0ZpbGxXaXRoLmxlbmd0aDtcblxuICAgICAgaWYgKGZpbGxCdWZMZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyB2YWxpZCBmaWxsIGRhdGEnKTtcbiAgICAgIH0gLy8gSWYgdGhlIGJ1ZmZlciBsZW5ndGggPT09IDEsIHdlIGNhbiBqdXN0IGRvIHRoaXMuX3RpQnVmZmVyLmZpbGwodmFsdWUsIG9mZnNldCwgZW5kKTtcblxuXG4gICAgICBpZiAoZmlsbEJ1Zkxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLl90aUJ1ZmZlci5maWxsKGJ1ZlRvRmlsbFdpdGguX3RpQnVmZmVyWzBdLCBvZmZzZXQsIGVuZCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IC8vIG11bHRpcGxlIGJ5dGUgZmlsbCFcblxuXG4gICAgICB2YXIgbGVuZ3RoID0gZW5kIC0gb2Zmc2V0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFRPRE86IERvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgYnl0ZU9mZnNldCBoZXJlIChvbiBgdGhpc2AsIG5vdCBvbiB0aGUgYnVmZmVyIHdlIGp1c3QgY3JlYXRlZCk/XG4gICAgICAgIHZhciBmaWxsQ2hhciA9IGJ1ZlRvRmlsbFdpdGguX3RpQnVmZmVyW2kgJSBmaWxsQnVmTGVuZ3RoXTtcbiAgICAgICAgdGhpcy5fdGlCdWZmZXJbaSArIG9mZnNldF0gPSBmaWxsQ2hhcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyBpZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIgKG9yIGEgYnVmZmVyIHdpdGggYSBzaW5nbGUgYnl0ZSkgd2UgY2FuIHVzZSB0aUJ1ZmZlci5maWxsKCk7XG5cblxuICAgIHRoaXMuX3RpQnVmZmVyLmZpbGwodmFsdWUsIG9mZnNldCwgZW5kKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaW5jbHVkZXModmFsdWUsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWx1ZSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfGludGVnZXJ9IHZhbHVlIFdoYXQgdG8gc2VhcmNoIGZvclxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtieXRlT2Zmc2V0PTBdIFdoZXJlIHRvIGJlZ2luIHNlYXJjaGluZyBpbiBidWYuIElmIG5lZ2F0aXZlLCB0aGVuIG9mZnNldCBpcyBjYWxjdWxhdGVkIGZyb20gdGhlIGVuZCBvZiBidWZcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIElmIHZhbHVlIGlzIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBlbmNvZGluZyB1c2VkIHRvIGRldGVybWluZSB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdHJpbmcgdGhhdCB3aWxsIGJlIHNlYXJjaGVkIGZvciBpbiBidWZcbiAgICogQHJldHVybnMge2ludGVnZXJ9IFRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB2YWx1ZSBpbiBidWYsIG9yIC0xIGlmIGJ1ZiBkb2VzIG5vdCBjb250YWluIHZhbHVlLlxuICAgKi9cblxuXG4gIGluZGV4T2YodmFsdWUsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBlbXB0eSBidWZmZXI/IGNhbid0IGZpbmQgYW55dGhpbmchXG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAvLyBpZiBieXRlT2Zmc2V0IGlzIHVuZGVmaW5lZCwgbWFrZSBpdCAwXG5cblxuICAgIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGJ5dGVPZmZzZXQgPSAwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBpZiBpdCdzIGEgc3RyaW5nLCB0aGF0J3MgYWN0dWFsbHkgZW5jb2RpbmdcbiAgICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldDtcbiAgICAgIGJ5dGVPZmZzZXQgPSAwO1xuICAgIH0gLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhbiBlbmNvZGluZyB5ZXQsIHVzZSB1dGY4XG5cblxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgICB9XG5cbiAgICBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICAgIC8vIGNvbnZlcnQgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgYnl0ZU9mZnNldCA9IHRoaXMubGVuZ3RoICsgYnl0ZU9mZnNldDtcblxuICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgICAgIC8vIHN0aWxsIG5lZ2F0aXZlPyBzdGFydCBhdCAwXG4gICAgICAgIGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xOyAvLyBjYW4ndCBmaW5kIHBhc3QgZW5kIG9mIGJ1ZmZlciFcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgJj0gMHhGRjsgLy8gY2xhbXAgdG8gMjU1XG4gICAgICAvLyBUaGlzIGlzIGEgc2ltcGxlciBjYXNlLCB3ZSBoYXZlIGEgc2luZ2xlIGJ5dGUgd2UgbmVlZCB0byBzZWFyY2ggZm9yXG4gICAgICAvLyBzbyBqdXN0IGxvb3AgdGhyb3VnaCBhbmQgdHJ5IHRvIGZpbmQgaXRcblxuICAgICAgcmV0dXJuIGluZGV4T2YkMSh0aGlzLCB2YWx1ZSwgYnl0ZU9mZnNldCk7XG4gICAgfSAvLyBjb2VyY2UgYSBzdHJpbmcgdG8gYSBCdWZmZXJcblxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gQnVmZmVyJDEuZnJvbSh2YWx1ZSwgZW5jb2RpbmcpO1xuICAgIH0gLy8gdmFsdWUgaXMgbm93IGEgQnVmZmVyLi4uXG5cblxuICAgIHZhciBtYXRjaExlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICAgIGlmIChtYXRjaExlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xOyAvLyBuZXZlciBmaW5kIGVtcHR5IHZhbHVlIVxuICAgIH1cblxuICAgIGlmIChtYXRjaExlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gc2ltcGxlIGNhc2UsIG1hdGNoIG9uZSBieXRlIVxuICAgICAgcmV0dXJuIGluZGV4T2YkMSh0aGlzLCB2YWx1ZVswXSwgYnl0ZU9mZnNldCk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRJbmRleCA9IGJ5dGVPZmZzZXQ7XG4gICAgdmFyIHRoaXNMZW5ndGggPSB0aGlzLmxlbmd0aDtcblxuICAgIGlmIChtYXRjaExlbmd0aCA+IHRoaXNMZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTsgLy8gY2FuJ3QgbWF0Y2ggaWYgdGhlIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoaXMgQnVmZmVyIVxuICAgIH0gLy8gRklYTUU6IENhbiB3ZSByZXdyaXRlIHRoaXMgaW4gYSBsZXNzIGZ1bmt5IHdheT9cbiAgICAvLyBGSVhNRTogQ2FuIHN0b3AgZWFybGllciBiYXNlZCBvbiBtYXRjaExlbmd0aCFcblxuXG4gICAgZmlyc3RNYXRjaDogd2hpbGUgKGN1cnJlbnRJbmRleCA8IHRoaXNMZW5ndGgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbGFiZWxzXG4gICAgICAvLyBtYXRjaCBmaXJzdCBieXRlIVxuICAgICAgdmFyIGZpcnN0Qnl0ZU1hdGNoID0gaW5kZXhPZiQxKHRoaXMsIHZhbHVlWzBdLCBjdXJyZW50SW5kZXgpO1xuXG4gICAgICBpZiAoZmlyc3RCeXRlTWF0Y2ggPT09IC0xKSB7XG4gICAgICAgIC8vIGNvdWxkbid0IGV2ZW4gbWF0Y2ggdGhlIHZlcnkgZmlyc3QgYnl0ZSwgc28gbm8gbWF0Y2ggb3ZlcmFsbCFcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSAvLyBvaywgd2UgZm91bmQgdGhlIGZpcnN0IGJ5dGUsIG5vdyB3ZSBuZWVkIHRvIHNlZSBpZiB0aGUgbmV4dCBjb25zZWN1dGl2ZSBieXRlcyBtYXRjaCFcblxuXG4gICAgICBmb3IgKHZhciB4ID0gMTsgeCA8IG1hdGNoTGVuZ3RoOyB4KyspIHtcbiAgICAgICAgaWYgKGZpcnN0Qnl0ZU1hdGNoICsgeCA+PSB0aGlzTGVuZ3RoKSB7XG4gICAgICAgICAgY3VycmVudEluZGV4ID0gZmlyc3RCeXRlTWF0Y2ggKyAxOyAvLyBtb3ZlIHBhc3Qgb3VyIGZpcnN0IG1hdGNoXG5cbiAgICAgICAgICBjb250aW51ZSBmaXJzdE1hdGNoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxhYmVsc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXNbZmlyc3RCeXRlTWF0Y2ggKyB4XSAhPT0gdmFsdWVbeF0pIHtcbiAgICAgICAgICAvLyBkaWRuJ3QgbWF0Y2ghXG4gICAgICAgICAgY3VycmVudEluZGV4ID0gZmlyc3RCeXRlTWF0Y2ggKyAxOyAvLyBtb3ZlIHBhc3Qgb3VyIGZpcnN0IG1hdGNoXG5cbiAgICAgICAgICBjb250aW51ZSBmaXJzdE1hdGNoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxhYmVsc1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaXJzdEJ5dGVNYXRjaDsgLy8gdGhlIHJlc3QgbWF0Y2hlZCwgaHVycmF5IVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGtleXMoKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgdmFyIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIHZhciBteUl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobmV4dEluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXh0SW5kZXgsXG4gICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgW1N5bWJvbC5pdGVyYXRvcl06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbXlJdGVyYXRvcjtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDhcbiAgICogQHJldHVybnMge2RvdWJsZX0gUmVhZHMgYSA2NC1iaXQgZG91YmxlIGZyb20gYnVmIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHdpdGggc3BlY2lmaWVkIGVuZGlhbiBmb3JtYXRcbiAgICovXG5cblxuICByZWFkRG91YmxlQkUob2Zmc2V0ID0gMCkge1xuICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgOCk7IC8vIE5vZGUgY2hlYXRzIGFuZCB1c2VzIGEgRmxvYXQ2NEFycmF5IGFuZCBVSW50OEFycmF5IGJhY2tlZCBieSB0aGUgc2FtZSBidWZmZXJcbiAgICAvLyBzbyBiYXNpY2FsbHkgaXQgcmVhZHMgaW4gdGhlIGJ5dGVzIHN0dWZmaW5nIHRoZW0gaW50byBVaW50OEFycmF5LCB0aGVuIHJldHVybnMgdGhlIHZhbHVlIGZyb20gdGhlIEZsb2F0NjRBcnJheVxuICAgIC8vIEZJWE1FOiBUaGlzIGFzc3VtZXMgTEUgc3lzdGVtIGJ5dGVPcmRlclxuXG4gICAgdWludDhEb3VibGVBcnJheVs3XSA9IHRoaXNbb2Zmc2V0KytdO1xuICAgIHVpbnQ4RG91YmxlQXJyYXlbNl0gPSB0aGlzW29mZnNldCsrXTtcbiAgICB1aW50OERvdWJsZUFycmF5WzVdID0gdGhpc1tvZmZzZXQrK107XG4gICAgdWludDhEb3VibGVBcnJheVs0XSA9IHRoaXNbb2Zmc2V0KytdO1xuICAgIHVpbnQ4RG91YmxlQXJyYXlbM10gPSB0aGlzW29mZnNldCsrXTtcbiAgICB1aW50OERvdWJsZUFycmF5WzJdID0gdGhpc1tvZmZzZXQrK107XG4gICAgdWludDhEb3VibGVBcnJheVsxXSA9IHRoaXNbb2Zmc2V0KytdO1xuICAgIHVpbnQ4RG91YmxlQXJyYXlbMF0gPSB0aGlzW29mZnNldCsrXTtcbiAgICByZXR1cm4gZG91YmxlQXJyYXlbMF07XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA4XG4gICAqIEByZXR1cm5zIHtkb3VibGV9IFJlYWRzIGEgNjQtYml0IGRvdWJsZSBmcm9tIGJ1ZiBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldCB3aXRoIHNwZWNpZmllZCBlbmRpYW4gZm9ybWF0XG4gICAqL1xuXG5cbiAgcmVhZERvdWJsZUxFKG9mZnNldCA9IDApIHtcbiAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDgpOyAvLyBOb2RlIGNoZWF0cyBhbmQgdXNlcyBhIEZsb2F0NjRBcnJheSBhbmQgVUludDhBcnJheSBiYWNrZWQgYnkgdGhlIHNhbWUgYnVmZmVyXG4gICAgLy8gc28gYmFzaWNhbGx5IGl0IHJlYWRzIGluIHRoZSBieXRlcyBzdHVmZmluZyB0aGVtIGludG8gVWludDhBcnJheSwgdGhlbiByZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSBGbG9hdDY0QXJyYXlcbiAgICAvLyBGSVhNRTogVGhpcyBhc3N1bWVzIExFIHN5c3RlbSBieXRlT3JkZXJcblxuICAgIHVpbnQ4RG91YmxlQXJyYXlbMF0gPSB0aGlzW29mZnNldCsrXTtcbiAgICB1aW50OERvdWJsZUFycmF5WzFdID0gdGhpc1tvZmZzZXQrK107XG4gICAgdWludDhEb3VibGVBcnJheVsyXSA9IHRoaXNbb2Zmc2V0KytdO1xuICAgIHVpbnQ4RG91YmxlQXJyYXlbM10gPSB0aGlzW29mZnNldCsrXTtcbiAgICB1aW50OERvdWJsZUFycmF5WzRdID0gdGhpc1tvZmZzZXQrK107XG4gICAgdWludDhEb3VibGVBcnJheVs1XSA9IHRoaXNbb2Zmc2V0KytdO1xuICAgIHVpbnQ4RG91YmxlQXJyYXlbNl0gPSB0aGlzW29mZnNldCsrXTtcbiAgICB1aW50OERvdWJsZUFycmF5WzddID0gdGhpc1tvZmZzZXQrK107XG4gICAgcmV0dXJuIGRvdWJsZUFycmF5WzBdO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNFxuICAgKiBAcmV0dXJucyB7ZmxvYXR9IFJlYWRzIGEgMzItYml0IGZsb2F0IGZyb20gYnVmIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHdpdGggc3BlY2lmaWVkIGVuZGlhbiBmb3JtYXRcbiAgICovXG5cblxuICByZWFkRmxvYXRCRShvZmZzZXQgPSAwKSB7XG4gICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTsgLy8gTm9kZSBjaGVhdHMgYW5kIHVzZXMgYSBGbG9hdDMyQXJyYXkgYW5kIFVJbnQ4QXJyYXkgYmFja2VkIGJ5IHRoZSBzYW1lIGJ1ZmZlclxuICAgIC8vIHNvIGJhc2ljYWxseSBpdCByZWFkcyBpbiB0aGUgYnl0ZXMgc3R1ZmZpbmcgdGhlbSBpbnRvIFVpbnQ4QXJyYXksIHRoZW4gcmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGUgRmxvYXQzMkFycmF5XG4gICAgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBMRSBzeXN0ZW0gYnl0ZU9yZGVyXG5cbiAgICB1aW50OEZsb2F0QXJyYXlbM10gPSB0aGlzW29mZnNldCsrXTtcbiAgICB1aW50OEZsb2F0QXJyYXlbMl0gPSB0aGlzW29mZnNldCsrXTtcbiAgICB1aW50OEZsb2F0QXJyYXlbMV0gPSB0aGlzW29mZnNldCsrXTtcbiAgICB1aW50OEZsb2F0QXJyYXlbMF0gPSB0aGlzW29mZnNldCsrXTtcbiAgICByZXR1cm4gZmxvYXRBcnJheVswXTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDRcbiAgICogQHJldHVybnMge2Zsb2F0fSBSZWFkcyBhIDMyLWJpdCBmbG9hdCBmcm9tIGJ1ZiBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldCB3aXRoIHNwZWNpZmllZCBlbmRpYW4gZm9ybWF0XG4gICAqL1xuXG5cbiAgcmVhZEZsb2F0TEUob2Zmc2V0ID0gMCkge1xuICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7IC8vIE5vZGUgY2hlYXRzIGFuZCB1c2VzIGEgRmxvYXQzMkFycmF5IGFuZCBVSW50OEFycmF5IGJhY2tlZCBieSB0aGUgc2FtZSBidWZmZXJcbiAgICAvLyBzbyBiYXNpY2FsbHkgaXQgcmVhZHMgaW4gdGhlIGJ5dGVzIHN0dWZmaW5nIHRoZW0gaW50byBVaW50OEFycmF5LCB0aGVuIHJldHVybnMgdGhlIHZhbHVlIGZyb20gdGhlIEZsb2F0MzJBcnJheVxuICAgIC8vIEZJWE1FOiBUaGlzIGFzc3VtZXMgTEUgc3lzdGVtIGJ5dGVPcmRlclxuXG4gICAgdWludDhGbG9hdEFycmF5WzBdID0gdGhpc1tvZmZzZXQrK107XG4gICAgdWludDhGbG9hdEFycmF5WzFdID0gdGhpc1tvZmZzZXQrK107XG4gICAgdWludDhGbG9hdEFycmF5WzJdID0gdGhpc1tvZmZzZXQrK107XG4gICAgdWludDhGbG9hdEFycmF5WzNdID0gdGhpc1tvZmZzZXQrK107XG4gICAgcmV0dXJuIGZsb2F0QXJyYXlbMF07XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAxLlxuICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICovXG5cblxuICByZWFkSW50OChvZmZzZXQgPSAwKSB7XG4gICAgdmFyIHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDEpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAqL1xuXG5cbiAgcmVhZEludDE2QkUob2Zmc2V0KSB7XG4gICAgdmFyIHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICAgIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDIpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAqL1xuXG5cbiAgcmVhZEludDE2TEUob2Zmc2V0ID0gMCkge1xuICAgIHZhciB1bnNpZ25lZFZhbHVlID0gdGhpcy5yZWFkVUludDE2TEUob2Zmc2V0KTtcbiAgICByZXR1cm4gdW5zaWduZWRUb1NpZ25lZCh1bnNpZ25lZFZhbHVlLCAyKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICAgKi9cblxuXG4gIHJlYWRJbnQzMkJFKG9mZnNldCA9IDApIHtcbiAgICB2YXIgdW5zaWduZWRWYWx1ZSA9IHRoaXMucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gICAgcmV0dXJuIHVuc2lnbmVkVG9TaWduZWQodW5zaWduZWRWYWx1ZSwgNCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICovXG5cblxuICByZWFkSW50MzJMRShvZmZzZXQgPSAwKSB7XG4gICAgdmFyIHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICAgIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDQpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkcyBieXRlTGVuZ3RoIG51bWJlciBvZiBieXRlcyBmcm9tIGJ1ZiBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldCBhbmQgaW50ZXJwcmV0cyB0aGUgcmVzdWx0IGFzIGEgdHdvJ3MgY29tcGxlbWVudCBzaWduZWQgdmFsdWUuIFN1cHBvcnRzIHVwIHRvIDQ4IGJpdHMgb2YgYWNjdXJhY3kuXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCB1bWJlciBvZiBieXRlcyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8IGJ5dGVMZW5ndGggPD0gNi5cbiAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAqL1xuXG5cbiAgcmVhZEludEJFKG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIHZhciB1bnNpZ25lZFZhbHVlID0gdGhpcy5yZWFkVUludEJFKG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHVuc2lnbmVkVG9TaWduZWQodW5zaWduZWRWYWx1ZSwgYnl0ZUxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWRzIGJ5dGVMZW5ndGggbnVtYmVyIG9mIGJ5dGVzIGZyb20gYnVmIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0IGFuZCBpbnRlcnByZXRzIHRoZSByZXN1bHQgYXMgYSB0d28ncyBjb21wbGVtZW50IHNpZ25lZCB2YWx1ZS4gU3VwcG9ydHMgdXAgdG8gNDggYml0cyBvZiBhY2N1cmFjeS5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIHVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICovXG5cblxuICByZWFkSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgdmFyIHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gdW5zaWduZWRUb1NpZ25lZCh1bnNpZ25lZFZhbHVlLCBieXRlTGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDEuXG4gICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICAgKi9cblxuXG4gIHJlYWRVSW50OChvZmZzZXQgPSAwKSB7XG4gICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAxKTtcbiAgICByZXR1cm4gdGhpc1tvZmZzZXRdO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAqL1xuXG5cbiAgcmVhZFVJbnQxNkJFKG9mZnNldCA9IDApIHtcbiAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDIpOyAvLyBmaXJzdCBieXRlIHNoaWZ0ZWQgYW5kIE9SJ2Qgd2l0aCBzZWNvbmQgYnl0ZVxuXG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAxXTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICAgKi9cblxuXG4gIHJlYWRVSW50MTZMRShvZmZzZXQgPSAwKSB7XG4gICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAyKTsgLy8gZmlyc3QgYnl0ZSBPUidkIHdpdGggc2Vjb25kIGJ5dGUgc2hpZnRlZFxuXG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgODtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICAgKi9cblxuXG4gIHJlYWRVSW50MzJCRShvZmZzZXQgPSAwKSB7XG4gICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgICByZXR1cm4gdGhpc1tvZmZzZXRdICogMHgxMDAwMDAwICsgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdKTsgLy8gcmF0aGVyIHRoYW4gc2hpZnRpbmcgYnkgPDwgMjQsIG11bHRpcGx5IHRoZSBmaXJzdCBieXRlIGFuZCBhZGQgaXQgaW4gc28gd2UgZG9uJ3QgcmV0YWluIHRoZSBcInNpZ24gYml0XCJcbiAgICAvLyAoYmVjYXVzZSBiaXQtd2lzZSBvcGVyYXRvcnMgYXNzdW1lIGEgMzItYml0IG51bWJlcilcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICAgKi9cblxuXG4gIHJlYWRVSW50MzJMRShvZmZzZXQgPSAwKSB7XG4gICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgICByZXR1cm4gKHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpICsgdGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMDsgLy8gcmF0aGVyIHRoYW4gc2hpZnRpbmcgYnkgPDwgMjQsIG11bHRpcGx5IHRoZSBsYXN0IGJ5dGUgYW5kIGFkZCBpdCBpbiBzbyB3ZSBkb24ndCByZXRhaW4gdGhlIFwic2lnbiBiaXRcIlxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICovXG5cblxuICByZWFkVUludEJFKG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZUxlbmd0aCA+IDYpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgICB9XG5cbiAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIHZhciBtdWx0aXBsaWVyID0gMTsgLy8gd2UgdXNlIGEgbXVsdGlwbGVyIGZvciBlYWNoIGJ5dGVcbiAgICAvLyB3ZSdyZSBkb2luZyB0aGUgc2FtZSBsb29wIGFzICNyZWFkVUludExFLCBqdXN0IGJhY2t3YXJkcyFcblxuICAgIGZvciAodmFyIGkgPSBieXRlTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHJlc3VsdCArPSBnZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCArIGkpICogbXVsdGlwbGllcjtcbiAgICAgIG11bHRpcGxpZXIgKj0gMHgxMDA7IC8vIG1vdmUgbXVsdGlwbGllciB0byBuZXh0IGJ5dGVcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICovXG5cblxuICByZWFkVUludExFKG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZUxlbmd0aCA+IDYpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgICB9XG5cbiAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIHZhciBtdWx0aXBsaWVyID0gMTsgLy8gd2UgdXNlIGEgbXVsdGlwbGVyIGZvciBlYWNoIGJ5dGVcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gZ2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyBpKSAqIG11bHRpcGxpZXI7XG4gICAgICBtdWx0aXBsaWVyICo9IDB4MTAwOyAvLyBtb3ZlIG11bHRpcGxpZXIgdG8gbmV4dCBieXRlXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnQ9MF0gV2hlcmUgdGhlIG5ldyBgQnVmZmVyYCB3aWxsIHN0YXJ0LlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtlbmQ9dGhpcy5sZW5ndGhdIFdoZXJlIHRoZSBuZXcgQnVmZmVyIHdpbGwgZW5kIChub3QgaW5jbHVzaXZlKS4gRGVmYXVsdDogYGJ1Zi5sZW5ndGhgLlxuICAgKiBAcmV0dXJucyB7QnVmZmVyfVxuICAgKi9cblxuXG4gIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgdGhpc0xlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgc3RhcnQgPSB0aGlzTGVuZ3RoICsgc3RhcnQ7XG5cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBzdGlsbCBuZWdhdGl2ZSwgdXNlIDAgKHRoYXQgbWF0Y2hlcyBOb2RlKVxuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSB0aGlzTGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAoZW5kIDwgMCkge1xuICAgICAgZW5kID0gdGhpc0xlbmd0aCArIGVuZDtcbiAgICB9IC8vIFNwZWNpZnlpbmcgZW5kIGdyZWF0ZXIgdGhhbiBidWYubGVuZ3RoIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdCBhcyB0aGF0IG9mIGVuZCBlcXVhbCB0byBidWYubGVuZ3RoLlxuXG5cbiAgICBpZiAoZW5kID4gdGhpc0xlbmd0aCkge1xuICAgICAgZW5kID0gdGhpc0xlbmd0aDtcbiAgICB9IC8vIFdoYXQgaWYgZW5kIGlzIGxlc3MgdGhhbiBzdGFydD9cblxuXG4gICAgdmFyIGxlbmd0aCA9IGVuZCAtIHN0YXJ0O1xuXG4gICAgaWYgKGxlbmd0aCA8PSAwKSB7XG4gICAgICBsZW5ndGggPSAwOyAvLyByZXR1cm4gZW1wdHkgdmlldyBvZiBCdWZmZXIhIHJldGFpbiBieXRlIG9mZnNldCwgc2V0IGxlbmd0aCB0byAwXG4gICAgfSAvLyBXcmFwIHRoZSBzYW1lIFRpLkJ1ZmZlciBvYmplY3QgYnV0IHNwZWNpZnkgdGhlIHN0YXJ0L2VuZCB0byBcImNyb3BcIiB3aXRoXG5cblxuICAgIHJldHVybiBuZXdCdWZmZXIodGhpcy5fdGlCdWZmZXIsIHRoaXMuYnl0ZU9mZnNldCArIHN0YXJ0LCBsZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtzdGFydD0wXSBXaGVyZSB0aGUgbmV3IGBCdWZmZXJgIHdpbGwgc3RhcnQuXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW2VuZD10aGlzLmxlbmd0aF0gV2hlcmUgdGhlIG5ldyBCdWZmZXIgd2lsbCBlbmQgKG5vdCBpbmNsdXNpdmUpLiBEZWZhdWx0OiBgYnVmLmxlbmd0aGAuXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gICAqL1xuXG5cbiAgc3ViYXJyYXkoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcnByZXRzIGJ1ZiBhcyBhbiBhcnJheSBvZiB1bnNpZ25lZCAxNi1iaXQgaW50ZWdlcnMgYW5kIHN3YXBzIHRoZSBieXRlIG9yZGVyIGluLXBsYWNlLlxuICAgKiBUaHJvd3MgRVJSX0lOVkFMSURfQlVGRkVSX1NJWkUgaWYgYnVmLmxlbmd0aCBpcyBub3QgYSBtdWx0aXBsZSBvZiAyLlxuICAgKiBAcmV0dXJucyB7QnVmZmVyfVxuICAgKi9cblxuXG4gIHN3YXAxNigpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cbiAgICBpZiAobGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIGZpcnN0ID0gZ2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpKTtcbiAgICAgIHZhciBzZWNvbmQgPSBnZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyAxKTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgaSwgc2Vjb25kKTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgaSArIDEsIGZpcnN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogSW50ZXJwcmV0cyBidWYgYXMgYW4gYXJyYXkgb2YgdW5zaWduZWQgMzItYml0IGludGVnZXJzIGFuZCBzd2FwcyB0aGUgYnl0ZSBvcmRlciBpbi1wbGFjZS5cbiAgICogVGhyb3dzIEVSUl9JTlZBTElEX0JVRkZFUl9TSVpFIGlmIGJ1Zi5sZW5ndGggaXMgbm90IGEgbXVsdGlwbGUgb2YgNC5cbiAgICogQHJldHVybnMge0J1ZmZlcn1cbiAgICovXG5cblxuICBzd2FwMzIoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gICAgaWYgKGxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIHZhciBmaXJzdCA9IGdldEFkanVzdGVkSW5kZXgodGhpcywgaSk7XG4gICAgICB2YXIgc2Vjb25kID0gZ2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpICsgMSk7XG4gICAgICB2YXIgdGhpcmQgPSBnZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyAyKTtcbiAgICAgIHZhciBmb3VydGggPSBnZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyAzKTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgaSwgZm91cnRoKTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgaSArIDEsIHRoaXJkKTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgaSArIDIsIHNlY29uZCk7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyAzLCBmaXJzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEludGVycHJldHMgYnVmIGFzIGFuIGFycmF5IG9mIHVuc2lnbmVkIDY0LWJpdCBpbnRlZ2VycyBhbmQgc3dhcHMgdGhlIGJ5dGUgb3JkZXIgaW4tcGxhY2UuXG4gICAqIFRocm93cyBFUlJfSU5WQUxJRF9CVUZGRVJfU0laRSBpZiBidWYubGVuZ3RoIGlzIG5vdCBhIG11bHRpcGxlIG9mIDguXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gICAqL1xuXG5cbiAgc3dhcDY0KCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblxuICAgIGlmIChsZW5ndGggJSA4ICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSA4KSB7XG4gICAgICB2YXIgZmlyc3QgPSBnZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkpO1xuICAgICAgdmFyIHNlY29uZCA9IGdldEFkanVzdGVkSW5kZXgodGhpcywgaSArIDEpO1xuICAgICAgdmFyIHRoaXJkID0gZ2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpICsgMik7XG4gICAgICB2YXIgZm91cnRoID0gZ2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpICsgMyk7XG4gICAgICB2YXIgZmlmdGggPSBnZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyA0KTtcbiAgICAgIHZhciBzaXh0aCA9IGdldEFkanVzdGVkSW5kZXgodGhpcywgaSArIDUpO1xuICAgICAgdmFyIHNldmVudGggPSBnZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyA2KTtcbiAgICAgIHZhciBlaWdodGggPSBnZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyA3KTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgaSwgZWlnaHRoKTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgaSArIDEsIHNldmVudGgpO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpICsgMiwgc2l4dGgpO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpICsgMywgZmlmdGgpO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpICsgNCwgZm91cnRoKTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgaSArIDUsIHRoaXJkKTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgaSArIDYsIHNlY29uZCk7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyA3LCBmaXJzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuXG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICAgIC8vIFRha2UgYWR2YW50YWdlIG9mIHNsaWNlIHdvcmtpbmcgb24gXCJBcnJheS1saWtlXCIgb2JqZWN0cyAoanV0cyBsaWtlIGBhcmd1bWVudHNgKVxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc2xpY2UjQXJyYXktbGlrZV9vYmplY3RzXG4gICAgICBkYXRhOiBbXS5zbGljZS5jYWxsKHRoaXMpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIFRoZSBjaGFyYWN0ZXIgZW5jb2RpbmcgdG8gdXNlXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW3N0YXJ0PTBdIFRoZSBieXRlIG9mZnNldCB0byBzdGFydCBkZWNvZGluZyBhdFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtlbmRdIFRoZSBieXRlIG9mZnNldCB0byBzdG9wIGRlY29kaW5nIGF0IChub3QgaW5jbHVzaXZlKS4gYGJ1Zi5sZW5ndGhgIGRlZmF1bHRcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG5cblxuICB0b1N0cmluZyhlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICAgIC8vIGZhc3QgY2FzZSBvZiBubyBhcmdzXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl90aUJ1ZmZlci50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblxuICAgIGlmIChzdGFydCA+PSBsZW5ndGgpIHtcbiAgICAgIHJldHVybiAnJzsgLy8gc3RhcnQgaXMgcGFzdCBlbmQgb2YgYnVmZmVyLCByZXR1cm4gZW1wdHkgc3RyaW5nXG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0IDwgMCB8fCB0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGVuZCA+IGxlbmd0aCB8fCB0eXBlb2YgZW5kICE9PSAnbnVtYmVyJykge1xuICAgICAgLy8gbm8gZW5kIHNwZWNpZmllZCwgb3IgcGFzdCBlbmQgb2YgYnVmZmVyLCB1c2UgbGVuZ3RoIG9mIGJ1ZmZlclxuICAgICAgZW5kID0gbGVuZ3RoO1xuICAgIH0gLy8gZWxzZSBrZWVwIGVuZCBhcyBwYXNzZWQgaW5cblxuXG4gICAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgICAgcmV0dXJuICcnOyAvLyBpZiBlbmQgaXMgYmVmb3JlIHN0YXJ0IHJldHVybiBlbXB0eSBzdHJpbmdcbiAgICB9IC8vIElmIHN0YXJ0ICE9PSAwIGFuZCBlbmQgIT09IGxlbmd0aCwgbWF5YmUgd2Ugc2hvdWxkIGRvIGEgQnVmZmVyLnN1YmFycmF5L3NsaWNlIG92ZXIgdGhlIHJhbmdlIGFuZCBjYWxsIHRvU3RyaW5nKCkgb24gdGhhdD9cblxuXG4gICAgaWYgKHN0YXJ0ICE9PSAwIHx8IGVuZCAhPT0gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKS50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgfSAvLyBiYXNlIGNhc2UsIHN0YXJ0IGlzIDAsIGVuZCBpcyBsZW5ndGhcblxuXG4gICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7IC8vIFRocm93IGlmIGJhZCBlbmNvZGluZyFcblxuICAgICAgaWYgKCFCdWZmZXIkMS5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIuY29uY2F0KGVuY29kaW5nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVuY29kaW5nID09PSAndXRmOCcgfHwgZW5jb2RpbmcgPT09ICd1dGYtOCcpIHtcbiAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIG9yaWdpbmFsIHVuZGVybHlpbmcgYnVmZmVyIGp1c3QgcmV0dXJuIGl0J3MgdG9TdHJpbmcoKSB2YWx1ZVxuICAgICAgaWYgKHRoaXMuYnl0ZU9mZnNldCA9PT0gMCAmJiB0aGlzLmxlbmd0aCA9PT0gdGhpcy5fdGlCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aUJ1ZmZlci50b1N0cmluZygpOyAvLyB3ZSByZXR1cm4gdXRmLTggYnkgZGVmYXVsdCBuYXRpdmVseVxuICAgICAgfSAvLyBpZiB3ZSdyZSBvZmZzZXQgb3IgY3JvcHBpbmcgaW4gbmF5IHdheSwgY2xvbmUgdGhlIHJhbmdlIGFuZCByZXR1cm4gdGhhdCBidWZmZXIncyB0b1N0cmluZygpXG5cblxuICAgICAgcmV0dXJuIHRoaXMuX3RpQnVmZmVyLmNsb25lKHRoaXMuYnl0ZU9mZnNldCwgdGhpcy5sZW5ndGgpLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgICAgdmFyIGJsb2I7IC8vIGlmIHRoaXMgaXMgdGhlIG9yaWdpbmFsIHVuZGVybHlpbmcgYnVmZmVyIGp1c3QgcmV0dXJuIGl0J3MgdG9TdHJpbmcoKSB2YWx1ZVxuXG4gICAgICBpZiAodGhpcy5ieXRlT2Zmc2V0ID09PSAwICYmIHRoaXMubGVuZ3RoID09PSB0aGlzLl90aUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgYmxvYiA9IFRpLlV0aWxzLmJhc2U2NGVuY29kZSh0aGlzLl90aUJ1ZmZlci50b0Jsb2IoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiB3ZSdyZSBvZmZzZXQgb3IgY3JvcHBpbmcgaW4gYW55IHdheSwgY2xvbmUgdGhlIHJhbmdlIGFuZCByZXR1cm4gdGhhdCBidWZmZXIncyB0b1N0cmluZygpXG4gICAgICAgIGJsb2IgPSBUaS5VdGlscy5iYXNlNjRlbmNvZGUodGhpcy5fdGlCdWZmZXIuY2xvbmUodGhpcy5ieXRlT2Zmc2V0LCB0aGlzLmxlbmd0aCkudG9CbG9iKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvYi50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmIChlbmNvZGluZyA9PT0gJ2hleCcpIHtcbiAgICAgIHZhciBoZXhTdHIgPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlYWNoIG9uZSBpcyBhIFwiYnl0ZVwiXG4gICAgICAgIHZhciBoZXggPSAoZ2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpKSAmIDB4ZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaGV4ID0gaGV4Lmxlbmd0aCA9PT0gMSA/ICcwJyArIGhleCA6IGhleDtcbiAgICAgICAgaGV4U3RyICs9IGhleDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhleFN0cjtcbiAgICB9XG5cbiAgICBpZiAoZW5jb2RpbmcgPT09ICdsYXRpbjEnIHx8IGVuY29kaW5nID09PSAnYmluYXJ5Jykge1xuICAgICAgdmFyIGxhdGluMVN0cmluZyA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIC8vIGVhY2ggb25lIGlzIGEgXCJieXRlXCJcbiAgICAgICAgbGF0aW4xU3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZ2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBfaSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGF0aW4xU3RyaW5nO1xuICAgIH1cblxuICAgIGlmIChlbmNvZGluZyA9PT0gJ2FzY2lpJykge1xuICAgICAgdmFyIGFzY2lpID0gJyc7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgLy8gd2Ugc3RvcmUgYnl0ZXMgKDgtYml0KSwgYnV0IGFzY2lpIGlzIDctYml0LiBOb2RlIFwibWFza3NcIiB0aGUgbGFzdCBiaXQgb2ZmLCBzbyBsZXQncyBkbyB0aGUgc2FtZVxuICAgICAgICBhc2NpaSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGdldEFkanVzdGVkSW5kZXgodGhpcywgX2kyKSAmIDB4N0YpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXNjaWk7XG4gICAgfSAvLyBVQ1MyL1VURjE2XG5cblxuICAgIHJldHVybiBidWZmZXJUb1VURjE2U3RyaW5nKHRoaXMuX3RpQnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQsIHRoaXMubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgYSBjb252ZXJzaW9uIG1ldGhvZCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBUaSBBUElzIHRhaHQgcmVxdWlyZSBhIFRpLkJ1ZmZlclxuICAgKiBAcmV0dXJucyB7VGkuQnVmZmVyfSB0aGUgdW5kZXJseWluZyBUaS5CdWZmZXIgYmFja2luZyB0aGlzIEJ1ZmZlciBpbnN0YW5jZVxuICAgKi9cblxuXG4gIHRvVGlCdWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpQnVmZmVyO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGFuIGl0ZXJhdG9yIGZvciBidWYgdmFsdWVzIChieXRlcylcbiAgICogQHJldHVybnMge0l0ZXJhdG9yfVxuICAgKi9cblxuXG4gIHZhbHVlcygpIHtcbiAgICB2YXIgYnVmZmVyID0gdGhpcztcbiAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICB2YXIgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgdmFyIG15SXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuZXh0SW5kZXggPCBlbmQpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdmFsdWU6IGdldEFkanVzdGVkSW5kZXgoYnVmZmVyLCBuZXh0SW5kZXgpLFxuICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG15SXRlcmF0b3I7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGJ1ZmZlciBpcyB1c2VkIGluIGEgZm9yLi5vZiBsb29wLiBEZWxlZ2F0ZXMgdG8gI3ZhbHVlcygpXG4gICAqIEByZXR1cm5zIHtJdGVyYXRvcn1cbiAgICovXG5cblxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGVzIHN0cmluZyB0byBidWYgYXQgb2Zmc2V0IGFjY29yZGluZyB0byB0aGUgY2hhcmFjdGVyIGVuY29kaW5nIGluIGVuY29kaW5nLlxuICAgKiBUaGUgbGVuZ3RoIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLiBJZiBidWYgZGlkIG5vdCBjb250YWluIGVub3VnaCBzcGFjZSB0b1xuICAgKiBmaXQgdGhlIGVudGlyZSBzdHJpbmcsIG9ubHkgcGFydCBvZiBzdHJpbmcgd2lsbCBiZSB3cml0dGVuLiBIb3dldmVyLCBwYXJ0aWFsbHkgZW5jb2RlZFxuICAgKiBjaGFyYWN0ZXJzIHdpbGwgbm90IGJlIHdyaXR0ZW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIHdyaXRlIHRvIGBidWZgLlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlIHN0cmluZ1xuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtsZW5ndGg9YnVmLmxlbmd0aCAtIG9mZnNldF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIG9mIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICovXG5cblxuICB3cml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGVuZ3RoID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UgY2FwIGBsZW5ndGhgIGF0IHRoZSBsZW5ndGggb2Ygb3VyIGJ1ZmZlclxuICAgICAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuXG4gICAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8ICd1dGY4JzsgLy8gc28gd2UgbmVlZCB0byBjb252ZXJ0IGByZW1haW5pbmdgIGJ5dGVzIG9mIG91ciBzdHJpbmcgaW50byBhIGJ5dGUgYXJyYXkvYnVmZmVyXG5cbiAgICB2YXIgc3JjID0gQnVmZmVyJDEuZnJvbShzdHJpbmcsIGVuY29kaW5nKTsgLy8gRklYTUU6IENhbiB3ZSBsZXQgaXQga25vdyB0byBvbmx5IGNvbnZlcnQgYHJlbWFpbmluZ2AgYnl0ZXM/XG4gICAgLy8gdGhlbiBzdGljayB0aGF0IGludG8gb3VyIGJ1ZmZlciBzdGFydGluZyBhdCBgb2Zmc2V0YCFcblxuICAgIHJldHVybiBjb3B5QnVmZmVyKHNyYy5fdGlCdWZmZXIsIHRoaXMuX3RpQnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gIH1cblxuICB3cml0ZURvdWJsZUJFKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA4KTtcbiAgICBkb3VibGVBcnJheVswXSA9IHZhbHVlO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbN10pO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbNl0pO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbNV0pO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbNF0pO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbM10pO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbMl0pO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbMV0pO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbMF0pO1xuICAgIHJldHVybiBvZmZzZXQ7IC8vIGF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYWRkZWQgOCB0byBvZmZzZXRcbiAgfVxuXG4gIHdyaXRlRG91YmxlTEUodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDgpO1xuICAgIGRvdWJsZUFycmF5WzBdID0gdmFsdWU7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVswXSk7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVsxXSk7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVsyXSk7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVszXSk7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs0XSk7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs1XSk7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs2XSk7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs3XSk7XG4gICAgcmV0dXJuIG9mZnNldDsgLy8gYXQgdGhpcyBwb2ludCwgd2Ugc2hvdWxkIGhhdmUgYWxyZWFkeSBhZGRlZCA4IHRvIG9mZnNldFxuICB9XG5cbiAgd3JpdGVGbG9hdEJFKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgICBmbG9hdEFycmF5WzBdID0gdmFsdWU7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzNdKTtcbiAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbMl0pO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVsxXSk7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzBdKTtcbiAgICByZXR1cm4gb2Zmc2V0OyAvLyBhdCB0aGlzIHBvaW50LCB3ZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGFkZGVkIDQgdG8gb2Zmc2V0XG4gIH1cblxuICB3cml0ZUZsb2F0TEUodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDQpO1xuICAgIGZsb2F0QXJyYXlbMF0gPSB2YWx1ZTtcbiAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbMF0pO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVsxXSk7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzJdKTtcbiAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbM10pO1xuICAgIHJldHVybiBvZmZzZXQ7IC8vIGF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYWRkZWQgNCB0byBvZmZzZXRcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMS5cbiAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAqL1xuXG5cbiAgd3JpdGVJbnQ4KHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAxKTtcbiAgICBjaGVja1ZhbHVlKHZhbHVlLCAtMTI4LCAxMjcpO1xuXG4gICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgIC8vIGp1c3Qgd3JpdGUgaXQgbm9ybWFsbHlcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnZlcnQgZnJvbSBzaWduZWQgdG8gMidzIGNvbXBsZW1lbnQgYml0c1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQsIDB4RkYgKyB2YWx1ZSArIDEpOyAvLyBtYXggdmFsdWUsIHBsdXMgdGhlIG5lZ2F0aXZlIG51bWJlciwgYWRkIG9uZVxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgKyAxO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAyLlxuICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICovXG5cblxuICB3cml0ZUludDE2QkUodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDIpO1xuICAgIGNoZWNrVmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0LCB2YWx1ZSA+Pj4gOCk7IC8vIGp1c3Qgc2hpZnQgb3ZlciBhIGJ5dGVcblxuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0ICsgMSwgdmFsdWUgJiAweEZGKTsgLy8gbWFzayB0byBmaXJzdCBieXRlXG5cbiAgICByZXR1cm4gb2Zmc2V0ICsgMjtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAqL1xuXG5cbiAgd3JpdGVJbnQxNkxFKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAyKTtcbiAgICBjaGVja1ZhbHVlKHZhbHVlLCAtMzI3NjgsIDMyNzY3KTtcbiAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCwgdmFsdWUgJiAweEZGKTtcbiAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCArIDEsIHZhbHVlID4+PiA4KTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgMjtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAqL1xuXG5cbiAgd3JpdGVJbnQzMkJFKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgICBjaGVja1ZhbHVlKHZhbHVlLCAtMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0Nyk7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQsIHZhbHVlID4+PiAyNCk7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyAxLCB2YWx1ZSA+Pj4gMTYpO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0ICsgMiwgdmFsdWUgPj4+IDgpO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0ICsgMywgdmFsdWUgJiAweEZGKTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgNDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAqL1xuXG5cbiAgd3JpdGVJbnQzMkxFKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgICBjaGVja1ZhbHVlKHZhbHVlLCAtMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0Nyk7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQsIHZhbHVlICYgMHhGRik7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyAxLCB2YWx1ZSA+Pj4gOCk7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyAyLCB2YWx1ZSA+Pj4gMTYpO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0ICsgMywgdmFsdWUgPj4+IDI0KTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgNDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8IGJ5dGVMZW5ndGggPD0gNi5cbiAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAqL1xuXG5cbiAgd3JpdGVJbnRCRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlTGVuZ3RoID4gNikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICAgIH1cblxuICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgdmFyIG1pbk1heEJhc2UgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuICAgIGNoZWNrVmFsdWUodmFsdWUsIC1taW5NYXhCYXNlLCBtaW5NYXhCYXNlIC0gMSk7XG5cbiAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICB2YWx1ZSA9IG1pbk1heEJhc2UgKiAyICsgdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIG11bHRpcGxpZXIgPSAxO1xuXG4gICAgZm9yICh2YXIgaSA9IGJ5dGVMZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGJ5dGVWYWx1ZSA9IHZhbHVlIC8gbXVsdGlwbGllciAmIDB4RkY7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCArIGksIGJ5dGVWYWx1ZSk7XG4gICAgICBtdWx0aXBsaWVyICo9IDB4MTAwO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICovXG5cblxuICB3cml0ZUludExFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVMZW5ndGggPiA2KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuXG4gICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICB2YXIgbWluTWF4QmFzZSA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSk7XG4gICAgY2hlY2tWYWx1ZSh2YWx1ZSwgLW1pbk1heEJhc2UsIG1pbk1heEJhc2UgLSAxKTtcblxuICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgIHZhbHVlID0gbWluTWF4QmFzZSAqIDIgKyB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgbXVsdGlwbGllciA9IDE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJ5dGVWYWx1ZSA9IHZhbHVlIC8gbXVsdGlwbGllciAmIDB4RkY7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCArIGksIGJ5dGVWYWx1ZSk7XG4gICAgICBtdWx0aXBsaWVyICo9IDBYMTAwO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAxLlxuICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICovXG5cblxuICB3cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAxKTtcbiAgICBjaGVja1ZhbHVlKHZhbHVlLCAwLCAyNTUpO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0LCB2YWx1ZSk7XG4gICAgcmV0dXJuIG9mZnNldCArIDE7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICAgKi9cblxuXG4gIHdyaXRlVUludDE2QkUodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDIpO1xuICAgIGNoZWNrVmFsdWUodmFsdWUsIDAsIDY1NTM1KTtcbiAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCwgdmFsdWUgPj4+IDgpO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0ICsgMSwgdmFsdWUgJiAweGZmKTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgMjtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAqL1xuXG5cbiAgd3JpdGVVSW50MTZMRSh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMik7XG4gICAgY2hlY2tWYWx1ZSh2YWx1ZSwgMCwgNjU1MzUpO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0LCB2YWx1ZSAmIDB4ZmYpO1xuICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0ICsgMSwgdmFsdWUgPj4+IDgpO1xuICAgIHJldHVybiBvZmZzZXQgKyAyO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICovXG5cblxuICB3cml0ZVVJbnQzMkJFKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgICBjaGVja1ZhbHVlKHZhbHVlLCAwLCA0Mjk0OTY3Mjk1KTtcbiAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCwgdmFsdWUgPj4+IDI0KTtcbiAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCArIDEsIHZhbHVlID4+PiAxNik7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyAyLCB2YWx1ZSA+Pj4gOCk7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyAzLCB2YWx1ZSAmIDB4ZmYpO1xuICAgIHJldHVybiBvZmZzZXQgKyA0O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICovXG5cblxuICB3cml0ZVVJbnQzMkxFKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgICBjaGVja1ZhbHVlKHZhbHVlLCAwLCA0Mjk0OTY3Mjk1KTtcbiAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCwgdmFsdWUgJiAweGZmKTtcbiAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCArIDEsIHZhbHVlID4+PiA4KTtcbiAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCArIDIsIHZhbHVlID4+PiAxNik7XG4gICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyAzLCB2YWx1ZSA+Pj4gMjQpO1xuICAgIHJldHVybiBvZmZzZXQgKyA0O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICovXG5cblxuICB3cml0ZVVJbnRCRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlTGVuZ3RoID4gNikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICAgIH1cblxuICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgY2hlY2tWYWx1ZSh2YWx1ZSwgMCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMSk7XG4gICAgdmFyIG11bHRpcGxpZXIgPSAxO1xuXG4gICAgZm9yICh2YXIgaSA9IGJ5dGVMZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGJ5dGVWYWx1ZSA9IHZhbHVlIC8gbXVsdGlwbGllciAmIDB4RkY7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCArIGksIGJ5dGVWYWx1ZSk7XG4gICAgICBtdWx0aXBsaWVyICo9IDBYMTAwO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICovXG5cblxuICB3cml0ZVVJbnRMRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlTGVuZ3RoID4gNikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICAgIH1cblxuICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgY2hlY2tWYWx1ZSh2YWx1ZSwgMCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMSk7XG4gICAgdmFyIG11bHRpcGxpZXIgPSAxO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBieXRlVmFsdWUgPSB2YWx1ZSAvIG11bHRpcGxpZXIgJiAweEZGO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyBpLCBieXRlVmFsdWUpO1xuICAgICAgbXVsdGlwbGllciAqPSAwWDEwMDtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDtcbiAgfSAvLyBUT0RPOiBJbXBsZW1lbnQgcmVtYWluaW5nIGluc3RhbmNlIG1ldGhvZHM6XG4gIC8vIGJ1Zi5sYXN0SW5kZXhPZih2YWx1ZVssIGJ5dGVPZmZzZXRdWywgZW5jb2RpbmddKVxuICAvLyBidWYucmVhZEJpZ0ludDY0QkUoW29mZnNldF0pXG4gIC8vIGJ1Zi5yZWFkQmlnSW50NjRMRShbb2Zmc2V0XSlcbiAgLy8gYnVmLnJlYWRCaWdVSW50NjRCRShbb2Zmc2V0XSlcbiAgLy8gYnVmLnJlYWRCaWdVSW50NjRMRShbb2Zmc2V0XSlcbiAgLy8gYnVmLndyaXRlQmlnSW50NjRCRSh2YWx1ZVssIG9mZnNldF0pXG4gIC8vIGJ1Zi53cml0ZUJpZ0ludDY0TEUodmFsdWVbLCBvZmZzZXRdKVxuICAvLyBidWYud3JpdGVCaWdVSW50NjRCRSh2YWx1ZVssIG9mZnNldF0pXG4gIC8vIGJ1Zi53cml0ZUJpZ1VJbnQ2NExFKHZhbHVlWywgb2Zmc2V0XSlcblxuXG4gIHN0YXRpYyBhbGxvY1Vuc2FmZShsZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3QnVmZmVyKFRpLmNyZWF0ZUJ1ZmZlcih7XG4gICAgICBsZW5ndGhcbiAgICB9KSk7XG4gIH1cblxuICBzdGF0aWMgYWxsb2NVbnNhZmVTbG93KGxlbmd0aCkge1xuICAgIHJldHVybiBCdWZmZXIkMS5hbGxvY1Vuc2FmZShsZW5ndGgpO1xuICB9XG5cbiAgc3RhdGljIGFsbG9jKGxlbmd0aCwgZmlsbCA9IDAsIGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlciQxLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpO1xuICAgIHJldHVybiBidWY7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxUeXBlZEFycmF5fERhdGFWaWV3fEFycmF5QnVmZmVyfFNoYXJlZEFycmF5QnVmZmVyfSBzdHJpbmcgb3JpZ2luYWwgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB3aG9zZSBieXRlIGxlbmd0aCB3ZSBuZWVkIHRvIGdyYWJcbiAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAqL1xuXG5cbiAgc3RhdGljIGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZyA9ICd1dGY4Jykge1xuICAgIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgaWYgKEJ1ZmZlciQxLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGg7IC8vIHJldHVybiBCdWZmZXIncyBsZW5ndGhcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoOyAvLyBUeXBlZEFycmF5LCBBcnJheUJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIsIERhdGFWaWV3XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICBzd2l0Y2ggKGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOEJ5dGVMZW5ndGgoc3RyaW5nKTtcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG5cbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYxNi1sZSc6XG4gICAgICAgIHJldHVybiAyICogbGVuZ3RoO1xuXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuZ3RoIC8gMjtcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gU3VidHJhY3QgdXAgdG8gdHdvIHBhZGRpbmcgY2hhcnMgZnJvbSBlbmQgb2Ygc3RyaW5nIVxuICAgICAgICBpZiAobGVuZ3RoID4gMSAmJiBzdHJpbmcuY2hhckF0KGxlbmd0aCAtIDEpID09PSAnPScpIHtcbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPiAxICYmIHN0cmluZy5jaGFyQXQobGVuZ3RoIC0gMSkgPT09ICc9Jykge1xuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobGVuZ3RoICogMyAvIDQpO1xuICAgICAgLy8gZHJvcCBmcmFjdGlvbmFsIHZhbHVlXG4gICAgfVxuXG4gICAgcmV0dXJuIHV0ZjhCeXRlTGVuZ3RoKHN0cmluZyk7XG4gIH1cblxuICBzdGF0aWMgY29tcGFyZShidWYxLCBidWYyKSB7XG4gICAgaWYgKCFCdWZmZXIkMS5pc0J1ZmZlcihidWYxKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBcXFwiYnVmMVxcXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQodHlwZW9mIGJ1ZjEpKTtcbiAgICB9IC8vIFRPRE86IFdyYXAgVUludDhBcnJheSBhcmdzIGluIGJ1ZmZlcnM/XG5cblxuICAgIHJldHVybiBidWYxLmNvbXBhcmUoYnVmMik7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyW118VUludDhBcnJheVtdfSBsaXN0IGxpc3Qgb2YgQnVmZmVycyB0byBjb25jYXRlbmF0ZVxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFt0b3RhbExlbmd0aF0gVG90YWwgbGVuZ3RoIG9mIHRoZSBCdWZmZXIgaW5zdGFuY2VzIGluIGxpc3Qgd2hlbiBjb25jYXRlbmF0ZWQuXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gICAqL1xuXG5cbiAgc3RhdGljIGNvbmNhdChsaXN0LCB0b3RhbExlbmd0aCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5Jyk7XG4gICAgfVxuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gQnVmZmVyJDEuYWxsb2MoMCk7IC8vIG9uZSBlbXB0eSBCdWZmZXIhXG4gICAgfSAvLyBhbGxvY2F0ZSBvbmUgQnVmZmVyIG9mIGB0b3RhbExlbmd0aGA/IENhcCBhdCB0b3RhbExlbmd0aD9cblxuXG4gICAgaWYgKHRvdGFsTGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRvdGFsTGVuZ3RoID0gMDsgLy8gZ2VuZXJhdGUgdGhlIHRvdGFsIGxlbmd0aCBmcm9tIGVhY2ggYnVmZmVyJ3MgbGVuZ3RoP1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IEJ1ZmZlciQxLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgICB2YXIgcG9zaXRpb24gPSAwO1xuXG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbGlzdC5sZW5ndGg7IF9pMysrKSB7XG4gICAgICB2YXIgYnVmID0gbGlzdFtfaTNdO1xuICAgICAgYnVmLmNvcHkocmVzdWx0LCBwb3NpdGlvbik7XG4gICAgICBwb3NpdGlvbiArPSBidWYubGVuZ3RoO1xuXG4gICAgICBpZiAocG9zaXRpb24gPj0gdG90YWxMZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtpbnRlZ2VyW118QnVmZmVyfHN0cmluZ30gdmFsdWUgdmFsdWUgd2UncmUgd3JhcHBpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIFRoZSBlbmNvZGluZyBvZiBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gICAqL1xuXG5cbiAgc3RhdGljIGZyb20odmFsdWUsIGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gICAgdmFyIHZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgIGlmICh2YWx1ZVR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoIUJ1ZmZlciQxLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIi5jb25jYXQoZW5jb2RpbmcpKTtcbiAgICAgIH1cblxuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIHZhciBibG9iID0gVGkuVXRpbHMuYmFzZTY0ZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgdmFyIGJsb2JTdHJlYW0gPSBUaS5TdHJlYW0uY3JlYXRlU3RyZWFtKHtcbiAgICAgICAgICBzb3VyY2U6IGJsb2IsXG4gICAgICAgICAgbW9kZTogVGkuU3RyZWFtLk1PREVfUkVBRFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IFRpLlN0cmVhbS5yZWFkQWxsKGJsb2JTdHJlYW0pO1xuICAgICAgICBibG9iU3RyZWFtLmNsb3NlKCk7XG4gICAgICAgIHJldHVybiBuZXdCdWZmZXIoYnVmZmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuY29kaW5nID09PSAnaGV4Jykge1xuICAgICAgICByZXR1cm4gQnVmZmVyJDEuZnJvbShzdHJpbmdUb0hleEJ5dGVzKHZhbHVlKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdCdWZmZXIoVGkuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0eXBlOiBnZXRUaUNvZGVjQ2hhcnNldChlbmNvZGluZylcbiAgICAgIH0pKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChCdWZmZXIkMS5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICAgICAgICB2YXIgX2J1ZmZlciA9IEJ1ZmZlciQxLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBfYnVmZmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUuY29weShfYnVmZmVyLCAwLCAwLCBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gX2J1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICB2YXIgX2xlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICAgICAgICBpZiAoX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCdWZmZXIkMS5hbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aUJ1ZmZlciA9IFRpLmNyZWF0ZUJ1ZmZlcih7XG4gICAgICAgICAgbGVuZ3RoOiBfbGVuZ3RoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGlCdWZmZXJbaV0gPSB2YWx1ZVtpXSAmIDB4RkY7IC8vIG1hc2sgdG8gb25lIGJ5dGVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdCdWZmZXIodGlCdWZmZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUuYXBpTmFtZSAmJiB2YWx1ZS5hcGlOYW1lID09PSAnVGkuQnVmZmVyJykge1xuICAgICAgICByZXR1cm4gbmV3QnVmZmVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXFwndmFsdWVcXCcgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZTogXFwnc3RyaW5nXFwnLCBcXCdBcnJheVxcJywgXFwnQnVmZmVyXFwnLCBcXCdUaS5CdWZmZXJcXCcnKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIHBvc3NpYmxlIGVuY29kaW5nIG5hbWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgc3RhdGljIGlzRW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBWQUxJRF9FTkNPRElOR1MuaW5jbHVkZXMoZW5jb2RpbmcudG9Mb3dlckNhc2UoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gb2JqIHBvc3NpYmxlIEJ1ZmZlciBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBzdGF0aWMgaXNCdWZmZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmpbaXNCdWZmZXJdID09PSB0cnVlO1xuICB9IC8vIE92ZXJyaWRlIGhvdyBidWZmZXJzIGFyZSBwcmVzZW50ZWQgYnkgdXRpbC5pbnNwZWN0KCkuXG5cblxuICBbY3VzdG9tSW5zcGVjdFN5bWJvbF0ocmVjdXJzZVRpbWVzLCBjdHgpIHtcbiAgICB2YXIgbWF4ID0gSU5TUEVDVF9NQVhfQllURVM7XG4gICAgdmFyIGFjdHVhbE1heCA9IE1hdGgubWluKG1heCwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG1heDtcbiAgICB2YXIgc3RyID0gdGhpcy5zbGljZSgwLCBhY3R1YWxNYXgpLnRvU3RyaW5nKCdoZXgnKS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKTtcblxuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBzdHIgKz0gXCIgLi4uIFwiLmNvbmNhdChyZW1haW5pbmcsIFwiIG1vcmUgYnl0ZVwiKS5jb25jYXQocmVtYWluaW5nID4gMSA/ICdzJyA6ICcnKTtcbiAgICB9IC8vIEluc3BlY3Qgc3BlY2lhbCBwcm9wZXJ0aWVzIGFzIHdlbGwsIGlmIHBvc3NpYmxlLlxuXG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICB2YXIgZXh0cmFzID0gZmFsc2U7XG4gICAgICB2YXIgZmlsdGVyID0gY3R4LnNob3dIaWRkZW4gPyBBTExfUFJPUEVSVElFUyQxIDogT05MWV9FTlVNRVJBQkxFJDE7XG4gICAgICB2YXIgb2JqID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHRoaXMsIGZpbHRlcikucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICAgICAgICBleHRyYXMgPSB0cnVlO1xuICAgICAgICBvYmpba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG4gICAgICBpZiAoZXh0cmFzKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHN0ciArPSAnLCAnO1xuICAgICAgICB9IC8vICdbT2JqZWN0OiBudWxsIHByb3RvdHlwZV0geycubGVuZ3RoID09PSAyNlxuICAgICAgICAvLyBUaGlzIGlzIGd1YXJkZWQgd2l0aCBhIHRlc3QuXG5cblxuICAgICAgICBzdHIgKz0gaW5zcGVjdChvYmosIF9vYmplY3RTcHJlYWQyKHt9LCBjdHgsIHtcbiAgICAgICAgICBicmVha0xlbmd0aDogSW5maW5pdHksXG4gICAgICAgICAgY29tcGFjdDogdHJ1ZVxuICAgICAgICB9KSkuc2xpY2UoMjcsIC0yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXCI8XCIuY29uY2F0KHRoaXMuY29uc3RydWN0b3IubmFtZSwgXCIgXCIpLmNvbmNhdChzdHIsIFwiPlwiKTtcbiAgfVxuXG59XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5pbnNwZWN0ID0gQnVmZmVyJDEucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdO1xuQnVmZmVyJDEucG9vbFNpemUgPSA4MTkyO1xudmFyIEJ1ZmZlck1vZHVsZSA9IHtcbiAgQnVmZmVyOiBCdWZmZXIkMSxcbiAgLy8gVE9ETzogSW1wbGVtZW50IHRyYW5zY29kZSgpIVxuICB0cmFuc2NvZGU6IChfc291cmNlLCBfZnJvbUVuY29kaW5nLCBfdG9FbmNvZGluZykgPT4ge30sXG4gIElOU1BFQ1RfTUFYX0JZVEVTOiA1MCxcbiAga01heExlbmd0aDogMjE0NzQ4MzY0NyxcbiAga1N0cmluZ01heExlbmd0aDogMTA3Mzc0MTc5OSxcbiAgY29uc3RhbnRzOiB7XG4gICAgTUFYX0xFTkdUSDogMjE0NzQ4MzY0NyxcbiAgICBNQVhfU1RSSU5HX0xFTkdUSDogMTA3Mzc0MTc5OVxuICB9XG59O1xuLyoqXG4gKiBTZWFyY2hlcyBhIEJ1ZmZlciBmb3IgdGhlIGluZGV4IG9mIGEgc2luZ2xlIGJ5dGUuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIGJ1ZmZlciB0byBzZWFyY2hcbiAqIEBwYXJhbSB7aW50ZWdlcn0gc2luZ2xlQnl0ZSBieXRlIHdlJ3JlIGxvb2tpbmcgZm9yXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBzdGFydCBvZmZzZXQgd2Ugc2VhcmNoIGF0XG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5mdW5jdGlvbiBpbmRleE9mJDEoYnVmZmVyLCBzaW5nbGVCeXRlLCBvZmZzZXQpIHtcbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGdldEFkanVzdGVkSW5kZXgoYnVmZmVyLCBpKSA9PT0gc2luZ2xlQnl0ZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGV4cGxpY2l0bHkgYXZvaWRzIGJpdHdpc2Ugb3BlcmF0aW9ucyBiZWNhdXNlIEpTIGFzc3VtZXMgMzItYml0IHNlcXVlbmNlcyBmb3IgdGhvc2UuXG4gKiBJdCdzIHBvc3NpYmxlIHdlIG1heSBiZSBhYmxlIHRvIHVzZSB0aGVtIHdoZW4gYnl0ZUxlbmd0aCA8IDQgaWYgdGhhdCdzIGZhc3Rlci5cbiAqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHVuc2lnbmVkVmFsdWUgdmFsdWUgYmVmb3JlIGNvbnZlcnRpbmcgYmFjayB0byBzaWduZWRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBudW1iZXIgb2YgYnl0ZXNcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSB0aGUgc2lnbmVkIHZhbHVlIHRoYXQgaXMgcmVwcmVzZW50ZWQgYnkgdGhlIHVuc2lnbmVkIHZhbHVlJ3MgYnl0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHVuc2lnbmVkVG9TaWduZWQodW5zaWduZWRWYWx1ZSwgYnl0ZUxlbmd0aCkge1xuICB2YXIgYml0TGVuZ3RoID0gYnl0ZUxlbmd0aCAqIDg7XG4gIHZhciBtYXhQb3NpdGl2ZVZhbHVlID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoIC0gMSk7XG5cbiAgaWYgKHVuc2lnbmVkVmFsdWUgPCBtYXhQb3NpdGl2ZVZhbHVlKSB7XG4gICAgcmV0dXJuIHVuc2lnbmVkVmFsdWU7XG4gIH1cblxuICB2YXIgbWF4VW5zaWduZWRWYWx1ZSA9IE1hdGgucG93KDIsIGJpdExlbmd0aCk7XG4gIHVuc2lnbmVkVmFsdWUgLT0gbWF4VW5zaWduZWRWYWx1ZTtcbiAgcmV0dXJuIHVuc2lnbmVkVmFsdWU7XG59XG4vKipcbiAqIEBwYXJhbSB7VGkuQnVmZmVyfSBzcmMgc291cmNlIEJ1ZmZlciB3ZSdyZSBjb3B5aW5nIGZyb21cbiAqIEBwYXJhbSB7VGkuQnVmZmVyfSBkZXN0IGRlc3RpbmF0aW9uIEJ1ZmZlciB3ZSdyZSBjb3B5aW5nIGludG9cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IHN0YXJ0IG9mZnNldCB3ZSdyZSBjb3B5aW5nIHRvIGluIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCBudW1iZXIgb2YgYnl0ZXMgdG8gY29weVxuICogQHJldHVybnMge2ludGVnZXJ9IGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgY29waWVkXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgZGVzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHNyY0xlbmd0aCA9IHNyYy5sZW5ndGg7XG4gIHZhciBkZXN0TGVuZ3RoID0gZGVzdC5sZW5ndGg7XG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc3RJbmRleCA9IGkgKyBvZmZzZXQ7IC8vIGFyZSB3ZSB0cnlpbmcgdG8gd3JpdGUgcGFzdCBlbmQgb2YgZGVzdGluYXRpb24/IE9yIHJlYWQgcGFzdCBlbmQgb2Ygc291cmNlPyBTdG9wIVxuXG4gICAgaWYgKGRlc3RJbmRleCA+PSBkZXN0TGVuZ3RoIHx8IGkgPj0gc3JjTGVuZ3RoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZXN0W2Rlc3RJbmRleF0gPSBzcmNbaV07XG4gIH1cblxuICByZXR1cm4gaTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB1dGYtOCBzdHJpbmdcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuZnVuY3Rpb24gdXRmOEJ5dGVMZW5ndGgoc3RyaW5nKSB7XG4gIC8vIEp1c3QgY29udmVydCB0byBhIFRpLkJ1ZmZlciBhbmQgbGV0IGl0IHRlbGwgdXMgdGhlIGxlbmd0aFxuICB2YXIgYnVmID0gVGkuY3JlYXRlQnVmZmVyKHtcbiAgICB2YWx1ZTogc3RyaW5nLFxuICAgIHR5cGU6IFRpLkNvZGVjLkNIQVJTRVRfVVRGOFxuICB9KTtcbiAgdmFyIGxlbmd0aCA9IGJ1Zi5sZW5ndGg7XG4gIGJ1Zi5yZWxlYXNlKCk7IC8vIHJlbGVhc2UgdGhlIGJ1ZmZlciBzaW5jZSB3ZSBqdXN0IG5lZWRlZCB0aGUgbGVuZ3RoXG5cbiAgcmV0dXJuIGxlbmd0aDtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIGRlc2lyZWQgZW5jb2RpbmcgbmFtZVxuICogQHJldHVybnMge2ludGVnZXJ9IFRpLkNvZGVjIGNvbnN0YW50IHRoYXQgbWFwcyB0byB0aGUgZW5jb2RpbmdcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRpQ29kZWNDaGFyc2V0KGVuY29kaW5nKSB7XG4gIHJldHVybiBUSV9DT0RFQ19NQVAuZ2V0KGVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gYnVmZmVyVG9VVEYxNlN0cmluZyh0aUJ1ZmZlciwgc3RhcnQsIGxlbmd0aCkge1xuICB2YXIgb3V0ID0gJyc7XG4gIHZhciBpID0gc3RhcnQ7XG5cbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAvLyB1dGYtMTYvdWNzLTIgaXMgMi1ieXRlcyBwZXIgY2hhcmFjdGVyXG4gICAgdmFyIGJ5dGUxID0gdGlCdWZmZXJbaSsrXTtcbiAgICB2YXIgYnl0ZTIgPSB0aUJ1ZmZlcltpKytdO1xuICAgIHZhciBjb2RlX3VuaXQgPSAoYnl0ZTIgPDwgOCkgKyBieXRlMTsgLy8gd2UgbWFzaCB0b2dldGhlciB0aGUgdHdvIGJ5dGVzXG5cbiAgICBvdXQgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZV91bml0KTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIGxvb3Agb3ZlciBpbnB1dCwgZXZlcnkgMiBjaGFyYWN0ZXJzLCBwYXJzZSBhcyBhbiBpbnRcbiAqIGJhc2ljYWxseSBlYWNoIHR3byBjaGFyYWN0ZXJzIGFyZSBhIFwiYnl0ZVwiIG9yIGFuIDgtYml0IHVpbnRcbiAqIHdlIGFwcGVuZCB0aGVtIGFsbCB0b2dldGhlciB0byBmb3JtIGEgc2luZ2xlIGJ1ZmZlciBob2xkaW5nIGFsbCB0aGUgdmFsdWVzXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgc3RyaW5nIHdlJ3JlIGVuY29kaW5nIGluIGhleFxuICogQHJldHVybnMge2ludGVnZXJbXX0gYXJyYXkgb2YgZW5jb2RlZCBieXRlc1xuICovXG5cblxuZnVuY3Rpb24gc3RyaW5nVG9IZXhCeXRlcyh2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoIC8gMjtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbnVtZXJpY1ZhbHVlID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuXG4gICAgaWYgKCFOdW1iZXIuaXNOYU4obnVtZXJpY1ZhbHVlKSkge1xuICAgICAgLy8gZHJvcCBiYWQgaGV4IGNoYXJhY3RlcnNcbiAgICAgIGJ5dGVBcnJheS5wdXNoKG51bWVyaWNWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheTtcbn0gLy8gVXNlIGEgUHJveHkgdG8gaGFjayBhcnJheSBzdHlsZSBpbmRleCBhY2Nlc3NvcnNcblxuXG52YXIgYXJyYXlJbmRleEhhbmRsZXIgPSB7XG4gIGdldCh0YXJnZXQsIHByb3BLZXksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIG51bSA9IE51bWJlcihwcm9wS2V5KTtcblxuICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkanVzdGVkSW5kZXgodGFyZ2V0LCBudW0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gaXNCdWZmZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BLZXksIHJlY2VpdmVyKTtcbiAgfSxcblxuICBzZXQodGFyZ2V0LCBwcm9wS2V5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIHByb3BLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbnVtID0gTnVtYmVyKHByb3BLZXkpO1xuXG4gICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSkge1xuICAgICAgICByZXR1cm4gc2V0QWRqdXN0ZWRJbmRleCh0YXJnZXQsIG51bSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BLZXksIHZhbHVlLCByZWNlaXZlcik7XG4gIH0sXG5cbiAgaGFzKHRhcmdldCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbnVtID0gTnVtYmVyKGtleSk7XG5cbiAgICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pKSB7XG4gICAgICAgIC8vIGVuc3VyZSBpdCdzIGEgcG9zaXRpdmUgXCJzYWZlXCIgaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSBidWZmZXJcbiAgICAgICAgcmV0dXJuIG51bSA+PSAwICYmIG51bSA8IHRhcmdldC5fdGlCdWZmZXIubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrZXkgaW4gdGFyZ2V0O1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIGdldEFkanVzdGVkSW5kZXgoYnVmLCBpbmRleCkge1xuICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IGJ1Zi5fdGlCdWZmZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBidWYuX3RpQnVmZmVyW2luZGV4ICsgYnVmLmJ5dGVPZmZzZXRdO1xufVxuXG5mdW5jdGlvbiBzZXRBZGp1c3RlZEluZGV4KGJ1ZiwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCA+PSAwIHx8IGluZGV4IDwgYnVmLl90aUJ1ZmZlci5sZW5ndGgpIHtcbiAgICBidWYuX3RpQnVmZmVyW2luZGV4ICsgYnVmLmJ5dGVPZmZzZXRdID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIFdyYXBzIGNyZWF0aW9uIG9mIGEgQnVmZmVyIGluc3RhbmNlIGluc2lkZSBhIFByb3h5IHNvIHdlIGNhbiBoYW5kbGUgYXJyYXkgaW5kZXggYWNjZXNzXG4gKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgYXJndW5lbnRzIG90IEJ1ZmZlciBjb25zdHJ1Y3RvclxuICogQHJldHVybnMge0J1ZmZlcn0gd3JhcHBlZCBpbnNpZGUgYSBQcm94eVxuICovXG5cblxuZnVuY3Rpb24gbmV3QnVmZmVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIG5ldyBQcm94eShuZXcgQnVmZmVyJDEoLi4uYXJncyksIGFycmF5SW5kZXhIYW5kbGVyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzZWN1cml0eS9kZXRlY3QtbmV3LWJ1ZmZlclxufVxuLyoqXG4gKiBUaHJvd3MgYSBSYW5nZUVycm9yIGlmIG9mZnNldCBpcyBvdXQgb2YgYm91bmRzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIGJ1ZmZlciB3ZSdyZSBvcGVyYXRpbmcgb25cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IHVzZXIgc3VwcGxpZWQgb2Zmc2V0XG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCBpbiByYW5nZVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0KGJ1ZmZlciwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIHZhciBlbmRPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gYnl0ZUxlbmd0aDtcblxuICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBlbmRPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSB2YWx1ZSBvZiBcXFwib2Zmc2V0XFxcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgPj0gMCBhbmQgPD0gXCIuY29uY2F0KGVuZE9mZnNldCwgXCIuIFJlY2VpdmVkIFwiKS5jb25jYXQob2Zmc2V0KSk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSB1c2VyLXN1cHBsaWVkIHZhbHVlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG1pbiBtaW5pbXVtIHZhbGlkIHZhbHVlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG1heCBtYXhpbXVtIHZhbGlkIHZhbHVlXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfVxuICovXG5cblxuZnVuY3Rpb24gY2hlY2tWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgaWYgKHZhbHVlIDwgbWluIHx8IHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdmFsdWUgb2YgXFxcInZhbHVlXFxcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgPj0gXCIuY29uY2F0KG1pbiwgXCIgYW5kIDw9IFwiKS5jb25jYXQobWF4LCBcIi4gUmVjZWl2ZWQgXCIpLmNvbmNhdCh2YWx1ZSkpO1xuICB9XG59XG5cbnZhciBidWZmZXJXYXJuaW5nQWxyZWFkeUVtaXR0ZWQgPSBmYWxzZTtcbnZhciBub2RlTW9kdWxlc0NoZWNrQ291bnRlciA9IDA7XG52YXIgYnVmZmVyV2FybmluZyA9ICdCdWZmZXIoKSBpcyBkZXByZWNhdGVkIGR1ZSB0byBzZWN1cml0eSBhbmQgdXNhYmlsaXR5ICcgKyAnaXNzdWVzLiBQbGVhc2UgdXNlIHRoZSBCdWZmZXIuYWxsb2MoKSwgJyArICdCdWZmZXIuYWxsb2NVbnNhZmUoKSwgb3IgQnVmZmVyLmZyb20oKSBtZXRob2RzIGluc3RlYWQuJztcblxuZnVuY3Rpb24gc2hvd0ZsYWdnZWREZXByZWNhdGlvbigpIHtcbiAgaWYgKGJ1ZmZlcldhcm5pbmdBbHJlYWR5RW1pdHRlZCB8fCArK25vZGVNb2R1bGVzQ2hlY2tDb3VudGVyID4gMTAwMDAgfHwgaXNJbnNpZGVOb2RlTW9kdWxlcygpKSB7XG4gICAgLy8gV2UgZG9uJ3QgZW1pdCBhIHdhcm5pbmcsIGJlY2F1c2Ugd2UgZWl0aGVyOlxuICAgIC8vIC0gQWxyZWFkeSBkaWQgc28sIG9yXG4gICAgLy8gLSBBbHJlYWR5IGNoZWNrZWQgdG9vIG1hbnkgdGltZXMgd2hldGhlciBhIGNhbGwgaXMgY29taW5nXG4gICAgLy8gICBmcm9tIG5vZGVfbW9kdWxlcyBhbmQgd2FudCB0byBzdG9wIHNsb3dpbmcgZG93biB0aGluZ3MsIG9yXG4gICAgLy8gLSBUaGUgY29kZSBpcyBpbnNpZGUgYG5vZGVfbW9kdWxlc2AuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvY2Vzcy5lbWl0V2FybmluZyhidWZmZXJXYXJuaW5nLCAnRGVwcmVjYXRpb25XYXJuaW5nJywgJ0RFUDAwMDUnKTtcbiAgYnVmZmVyV2FybmluZ0FscmVhZHlFbWl0dGVkID0gdHJ1ZTtcbn1cblxudmFyIHtcbiAgQUxMX1BST1BFUlRJRVM6IEFMTF9QUk9QRVJUSUVTJDIsXG4gIE9OTFlfRU5VTUVSQUJMRTogT05MWV9FTlVNRVJBQkxFJDJcbn0gPSBwcm9wZXJ0eUZpbHRlcjtcbnZhciBCb29sZWFuUHJvdG90eXBlID0gQm9vbGVhbi5wcm90b3R5cGU7XG52YXIgRGF0ZVByb3RvdHlwZSA9IERhdGUucHJvdG90eXBlO1xudmFyIEVycm9yUHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xudmFyIE51bWJlclByb3RvdHlwZSA9IE51bWJlci5wcm90b3R5cGU7XG52YXIgTWFwUHJvdG90eXBlID0gTWFwLnByb3RvdHlwZTtcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xudmFyIFN0cmluZ1Byb3RvdHlwZSA9IFN0cmluZy5wcm90b3R5cGU7XG52YXIgU2V0UHJvdG90eXBlID0gU2V0LnByb3RvdHlwZTtcbnZhciBTeW1ib2xQcm90b3R5cGUgPSBTeW1ib2wucHJvdG90eXBlO1xudmFyIGlzSW9zJDEgPSBbJ2lwYWQnLCAnaXBob25lJ10uaW5jbHVkZXMoVGkuUGxhdGZvcm0ub3NuYW1lKTtcbnZhciB7XG4gIEVSUl9JTlZBTElEX0FSR19UWVBFXG59ID0gY29kZXM7XG52YXIgaGFzT3duUHJvcGVydHkkMSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlJDEgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbnZhciBoZXhTbGljZSA9IHVuY3VycnlUaGlzKEJ1ZmZlck1vZHVsZS5CdWZmZXIucHJvdG90eXBlLmhleFNsaWNlKTtcbnZhciBidWlsdEluT2JqZWN0cyA9IG5ldyBTZXQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZ2xvYmFsKS5maWx0ZXIoZSA9PiAvXihbQS1aXVthLXpdKykrJC8udGVzdChlKSkpO1xudmFyIGluc3BlY3REZWZhdWx0T3B0aW9ucyA9IE9iamVjdC5zZWFsKHtcbiAgc2hvd0hpZGRlbjogZmFsc2UsXG4gIGRlcHRoOiAyLFxuICBjb2xvcnM6IGZhbHNlLFxuICBjdXN0b21JbnNwZWN0OiB0cnVlLFxuICBzaG93UHJveHk6IGZhbHNlLFxuICBtYXhBcnJheUxlbmd0aDogMTAwLFxuICBicmVha0xlbmd0aDogODAsXG4gIGNvbXBhY3Q6IDMsXG4gIHNvcnRlZDogZmFsc2UsXG4gIGdldHRlcnM6IGZhbHNlXG59KTtcbnZhciBrT2JqZWN0VHlwZSA9IDA7XG52YXIga0FycmF5VHlwZSA9IDE7XG52YXIga0FycmF5RXh0cmFzVHlwZSA9IDI7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG5cbnZhciBzdHJFc2NhcGVTZXF1ZW5jZXNSZWdFeHAgPSAvW1xceDAwLVxceDFmXFx4MjdcXHg1Y10vO1xudmFyIHN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyID0gL1tcXHgwMC1cXHgxZlxceDI3XFx4NWNdL2c7XG52YXIgc3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwU2luZ2xlID0gL1tcXHgwMC1cXHgxZlxceDVjXS87XG52YXIgc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXJTaW5nbGUgPSAvW1xceDAwLVxceDFmXFx4NWNdL2c7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cblxudmFyIGtleVN0clJlZ0V4cCA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKiQvO1xudmFyIG51bWJlclJlZ0V4cCA9IC9eKDB8WzEtOV1bMC05XSopJC87XG52YXIgbm9kZU1vZHVsZXNSZWdFeHAgPSAvWy9cXFxcXW5vZGVfbW9kdWxlc1svXFxcXF0oLis/KSg/PVsvXFxcXF0pL2c7XG52YXIga01pbkxpbmVMZW5ndGggPSAxNjsgLy8gQ29uc3RhbnRzIHRvIG1hcCB0aGUgaXRlcmF0b3Igc3RhdGUuXG5cbnZhciBrV2VhayA9IDA7XG52YXIga0l0ZXJhdG9yID0gMTtcbnZhciBrTWFwRW50cmllcyA9IDI7IC8vIEVzY2FwZWQgc3BlY2lhbCBjaGFyYWN0ZXJzLiBVc2UgZW1wdHkgc3RyaW5ncyB0byBmaWxsIHVwIHVudXNlZCBlbnRyaWVzLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBxdW90ZXMgKi9cblxudmFyIG1ldGEgPSBbJ1xcXFx1MDAwMCcsICdcXFxcdTAwMDEnLCAnXFxcXHUwMDAyJywgJ1xcXFx1MDAwMycsICdcXFxcdTAwMDQnLCAnXFxcXHUwMDA1JywgJ1xcXFx1MDAwNicsICdcXFxcdTAwMDcnLCAnXFxcXGInLCAnXFxcXHQnLCAnXFxcXG4nLCAnXFxcXHUwMDBiJywgJ1xcXFxmJywgJ1xcXFxyJywgJ1xcXFx1MDAwZScsICdcXFxcdTAwMGYnLCAnXFxcXHUwMDEwJywgJ1xcXFx1MDAxMScsICdcXFxcdTAwMTInLCAnXFxcXHUwMDEzJywgJ1xcXFx1MDAxNCcsICdcXFxcdTAwMTUnLCAnXFxcXHUwMDE2JywgJ1xcXFx1MDAxNycsICdcXFxcdTAwMTgnLCAnXFxcXHUwMDE5JywgJ1xcXFx1MDAxYScsICdcXFxcdTAwMWInLCAnXFxcXHUwMDFjJywgJ1xcXFx1MDAxZCcsICdcXFxcdTAwMWUnLCAnXFxcXHUwMDFmJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsIFwiXFxcXCdcIiwgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICdcXFxcXFxcXCddO1xuLyogZXNsaW50LWVuYWJsZSBxdW90ZXMgKi9cblxuZnVuY3Rpb24gZ2V0VXNlck9wdGlvbnMoY3R4KSB7XG4gIHZhciBvYmogPSB7XG4gICAgc3R5bGl6ZTogY3R4LnN0eWxpemVcbiAgfTtcblxuICBmb3IgKHZhciBrZXkgb2YgT2JqZWN0LmtleXMoaW5zcGVjdERlZmF1bHRPcHRpb25zKSkge1xuICAgIG9ialtrZXldID0gY3R4W2tleV07XG4gIH1cblxuICBpZiAoY3R4LnVzZXJPcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHt9LCBvYmosIHt9LCBjdHgudXNlck9wdGlvbnMpO1xufVxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYW55IGlucHV0LiBUcmllcyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlIHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYHZhbHVlYFxuICovXG5cblxuZnVuY3Rpb24gaW5zcGVjdCh2YWx1ZSwgb3B0cykge1xuICAvLyBEZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBidWRnZXQ6IHt9LFxuICAgIGluZGVudGF0aW9uTHZsOiAwLFxuICAgIHNlZW46IFtdLFxuICAgIGN1cnJlbnREZXB0aDogMCxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvcixcbiAgICBzaG93SGlkZGVuOiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuc2hvd0hpZGRlbixcbiAgICBkZXB0aDogaW5zcGVjdERlZmF1bHRPcHRpb25zLmRlcHRoLFxuICAgIGNvbG9yczogaW5zcGVjdERlZmF1bHRPcHRpb25zLmNvbG9ycyxcbiAgICBjdXN0b21JbnNwZWN0OiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuY3VzdG9tSW5zcGVjdCxcbiAgICBzaG93UHJveHk6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5zaG93UHJveHksXG4gICAgbWF4QXJyYXlMZW5ndGg6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5tYXhBcnJheUxlbmd0aCxcbiAgICBicmVha0xlbmd0aDogaW5zcGVjdERlZmF1bHRPcHRpb25zLmJyZWFrTGVuZ3RoLFxuICAgIGNvbXBhY3Q6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5jb21wYWN0LFxuICAgIHNvcnRlZDogaW5zcGVjdERlZmF1bHRPcHRpb25zLnNvcnRlZCxcbiAgICBnZXR0ZXJzOiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuZ2V0dGVyc1xuICB9O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIC8vIExlZ2FjeS4uLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgaWYgKGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gICAgICB9XG4gICAgfSAvLyBTZXQgdXNlci1zcGVjaWZpZWQgb3B0aW9uc1xuXG5cbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdib29sZWFuJykge1xuICAgICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICAgIH0gZWxzZSBpZiAob3B0cykge1xuICAgICAgdmFyIG9wdEtleXMgPSBPYmplY3Qua2V5cyhvcHRzKTtcblxuICAgICAgZm9yICh2YXIga2V5IG9mIG9wdEtleXMpIHtcbiAgICAgICAgLy8gVE9ETyhCcmlkZ2VBUik6IEZpbmQgYSBzb2x1dGlvbiB3aGF0IHRvIGRvIGFib3V0IHN0eWxpemUuIEVpdGhlciBtYWtlXG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gcHVibGljIG9yIGFkZCBhIG5ldyBBUEkgd2l0aCBhIHNpbWlsYXIgb3IgYmV0dGVyXG4gICAgICAgIC8vIGZ1bmN0aW9uYWxpdHkuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQxKGluc3BlY3REZWZhdWx0T3B0aW9ucywga2V5KSB8fCBrZXkgPT09ICdzdHlsaXplJykge1xuICAgICAgICAgIGN0eFtrZXldID0gb3B0c1trZXldO1xuICAgICAgICB9IGVsc2UgaWYgKGN0eC51c2VyT3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCB0byBwYXNzIHRocm91Z2ggdGhlIGFjdHVhbCB1c2VyIGlucHV0LlxuICAgICAgICAgIGN0eC51c2VyT3B0aW9ucyA9IG9wdHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoY3R4LmNvbG9ycykge1xuICAgIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgfVxuXG4gIGlmIChjdHgubWF4QXJyYXlMZW5ndGggPT09IG51bGwpIHtcbiAgICBjdHgubWF4QXJyYXlMZW5ndGggPSBJbmZpbml0eTtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCAwKTtcbn1cbmluc3BlY3QuY3VzdG9tID0gY3VzdG9tSW5zcGVjdFN5bWJvbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnNwZWN0LCAnZGVmYXVsdE9wdGlvbnMnLCB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gaW5zcGVjdERlZmF1bHRPcHRpb25zO1xuICB9LFxuXG4gIHNldChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMnLCAnT2JqZWN0Jywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oaW5zcGVjdERlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgfVxuXG59KTsgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5cbmluc3BlY3QuY29sb3JzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gIGJvbGQ6IFsxLCAyMl0sXG4gIGl0YWxpYzogWzMsIDIzXSxcbiAgdW5kZXJsaW5lOiBbNCwgMjRdLFxuICBpbnZlcnNlOiBbNywgMjddLFxuICB3aGl0ZTogWzM3LCAzOV0sXG4gIGdyZXk6IFs5MCwgMzldLFxuICBibGFjazogWzMwLCAzOV0sXG4gIGJsdWU6IFszNCwgMzldLFxuICBjeWFuOiBbMzYsIDM5XSxcbiAgZ3JlZW46IFszMiwgMzldLFxuICBtYWdlbnRhOiBbMzUsIDM5XSxcbiAgcmVkOiBbMzEsIDM5XSxcbiAgeWVsbG93OiBbMzMsIDM5XVxufSk7IC8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuXG5pbnNwZWN0LnN0eWxlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICBzcGVjaWFsOiAnY3lhbicsXG4gIG51bWJlcjogJ3llbGxvdycsXG4gIGJpZ2ludDogJ3llbGxvdycsXG4gIGJvb2xlYW46ICd5ZWxsb3cnLFxuICB1bmRlZmluZWQ6ICdncmV5JyxcbiAgbnVsbDogJ2JvbGQnLFxuICBzdHJpbmc6ICdncmVlbicsXG4gIHN5bWJvbDogJ2dyZWVuJyxcbiAgZGF0ZTogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICByZWdleHA6ICdyZWQnLFxuICBtb2R1bGU6ICd1bmRlcmxpbmUnXG59KTtcblxuZnVuY3Rpb24gYWRkUXVvdGVzKHN0ciwgcXVvdGVzKSB7XG4gIGlmIChxdW90ZXMgPT09IC0xKSB7XG4gICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdChzdHIsIFwiXFxcIlwiKTtcbiAgfVxuXG4gIGlmIChxdW90ZXMgPT09IC0yKSB7XG4gICAgcmV0dXJuIFwiYFwiLmNvbmNhdChzdHIsIFwiYFwiKTtcbiAgfVxuXG4gIHJldHVybiBcIidcIi5jb25jYXQoc3RyLCBcIidcIik7XG59XG5cbnZhciBlc2NhcGVGbiA9IHN0ciA9PiBtZXRhW3N0ci5jaGFyQ29kZUF0KDApXTsgLy8gRXNjYXBlIGNvbnRyb2wgY2hhcmFjdGVycywgc2luZ2xlIHF1b3RlcyBhbmQgdGhlIGJhY2tzbGFzaC5cbi8vIFRoaXMgaXMgc2ltaWxhciB0byBKU09OIHN0cmluZ2lmeSBlc2NhcGluZy5cblxuXG5mdW5jdGlvbiBzdHJFc2NhcGUoc3RyKSB7XG4gIHZhciBlc2NhcGVUZXN0ID0gc3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwO1xuICB2YXIgZXNjYXBlUmVwbGFjZSA9IHN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyO1xuICB2YXIgc2luZ2xlUXVvdGUgPSAzOTsgLy8gQ2hlY2sgZm9yIGRvdWJsZSBxdW90ZXMuIElmIG5vdCBwcmVzZW50LCBkbyBub3QgZXNjYXBlIHNpbmdsZSBxdW90ZXMgYW5kXG4gIC8vIGluc3RlYWQgd3JhcCB0aGUgdGV4dCBpbiBkb3VibGUgcXVvdGVzLiBJZiBkb3VibGUgcXVvdGVzIGV4aXN0LCBjaGVjayBmb3JcbiAgLy8gYmFja3RpY2tzLiBJZiB0aGV5IGRvIG5vdCBleGlzdCwgdXNlIHRob3NlIGFzIGZhbGxiYWNrIGluc3RlYWQgb2YgdGhlXG4gIC8vIGRvdWJsZSBxdW90ZXMuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBxdW90ZXNcblxuICBpZiAoc3RyLmluY2x1ZGVzKFwiJ1wiKSkge1xuICAgIC8vIFRoaXMgaW52YWxpZGF0ZXMgdGhlIGNoYXJDb2RlIGFuZCB0aGVyZWZvcmUgY2FuIG5vdCBiZSBtYXRjaGVkIGZvclxuICAgIC8vIGFueW1vcmUuXG4gICAgaWYgKCFzdHIuaW5jbHVkZXMoJ1wiJykpIHtcbiAgICAgIHNpbmdsZVF1b3RlID0gLTE7XG4gICAgfSBlbHNlIGlmICghc3RyLmluY2x1ZGVzKCdgJykgJiYgIXN0ci5pbmNsdWRlcygnJHsnKSkge1xuICAgICAgc2luZ2xlUXVvdGUgPSAtMjtcbiAgICB9XG5cbiAgICBpZiAoc2luZ2xlUXVvdGUgIT09IDM5KSB7XG4gICAgICBlc2NhcGVUZXN0ID0gc3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwU2luZ2xlO1xuICAgICAgZXNjYXBlUmVwbGFjZSA9IHN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyU2luZ2xlO1xuICAgIH1cbiAgfSAvLyBTb21lIG1hZ2ljIG51bWJlcnMgdGhhdCB3b3JrZWQgb3V0IGZpbmUgd2hpbGUgYmVuY2htYXJraW5nIHdpdGggdjggNi4wXG5cblxuICBpZiAoc3RyLmxlbmd0aCA8IDUwMDAgJiYgIWVzY2FwZVRlc3QudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIGFkZFF1b3RlcyhzdHIsIHNpbmdsZVF1b3RlKTtcbiAgfVxuXG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoZXNjYXBlUmVwbGFjZSwgZXNjYXBlRm4pO1xuICAgIHJldHVybiBhZGRRdW90ZXMoc3RyLCBzaW5nbGVRdW90ZSk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBsYXN0ID0gMDtcbiAgdmFyIGxhc3RJbmRleCA9IHN0ci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgIHZhciBwb2ludCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKHBvaW50ID09PSBzaW5nbGVRdW90ZSB8fCBwb2ludCA9PT0gOTIgfHwgcG9pbnQgPCAzMikge1xuICAgICAgaWYgKGxhc3QgPT09IGkpIHtcbiAgICAgICAgcmVzdWx0ICs9IG1ldGFbcG9pbnRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiXCIuY29uY2F0KHN0ci5zbGljZShsYXN0LCBpKSkuY29uY2F0KG1ldGFbcG9pbnRdKTtcbiAgICAgIH1cblxuICAgICAgbGFzdCA9IGkgKyAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsYXN0ICE9PSBsYXN0SW5kZXgpIHtcbiAgICByZXN1bHQgKz0gc3RyLnNsaWNlKGxhc3QpO1xuICB9XG5cbiAgcmV0dXJuIGFkZFF1b3RlcyhyZXN1bHQsIHNpbmdsZVF1b3RlKTtcbn1cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGNvbG9yID0gaW5zcGVjdC5jb2xvcnNbc3R5bGVdO1xuICAgIHJldHVybiBcIlxceDFCW1wiLmNvbmNhdChjb2xvclswXSwgXCJtXCIpLmNvbmNhdChzdHIsIFwiXFx4MUJbXCIpLmNvbmNhdChjb2xvclsxXSwgXCJtXCIpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyKSB7XG4gIHJldHVybiBzdHI7XG59IC8vIFJldHVybiBhIG5ldyBlbXB0eSBhcnJheSB0byBwdXNoIGluIHRoZSByZXN1bHRzIG9mIHRoZSBkZWZhdWx0IGZvcm1hdHRlci5cblxuXG5mdW5jdGlvbiBnZXRFbXB0eUZvcm1hdEFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIGdldENvbnN0cnVjdG9yTmFtZShvYmosIF9jdHgpIHtcbiAgdmFyIGZpcnN0UHJvdG87IC8vIGNvbnN0IHRtcCA9IG9iajtcblxuICB3aGlsZSAob2JqKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgJ2NvbnN0cnVjdG9yJyk7XG5cbiAgICBpZiAoZGVzY3JpcHRvciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSAnZnVuY3Rpb24nICYmIGRlc2NyaXB0b3IudmFsdWUubmFtZSAhPT0gJycpIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlLm5hbWU7XG4gICAgfVxuXG4gICAgb2JqID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG5cbiAgICBpZiAoZmlyc3RQcm90byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaXJzdFByb3RvID0gb2JqO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmaXJzdFByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLypcbiAgIEB0b2RvIHRoaXMgY2FsbHMgaW50byBuYXRpdmUsIGNhbiB3ZSByZXBsYWNlIHRoaXMgc29tZWhvdz9cbiAgcmV0dXJuIGAke2ludGVybmFsR2V0Q29uc3RydWN0b3JOYW1lKHRtcCl9IDwke2luc3BlY3QoZmlyc3RQcm90bywge1xuICBcdC4uLmN0eCxcbiAgXHRjdXN0b21JbnNwZWN0OiBmYWxzZVxuICB9KX0+YDtcbiAgKi9cblxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgZmFsbGJhY2spIHtcbiAgaWYgKGNvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgaWYgKHRhZyAhPT0gJycpIHtcbiAgICAgIHJldHVybiBcIltcIi5jb25jYXQoZmFsbGJhY2ssIFwiOiBudWxsIHByb3RvdHlwZV0gW1wiKS5jb25jYXQodGFnLCBcIl0gXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBcIltcIi5jb25jYXQoZmFsbGJhY2ssIFwiOiBudWxsIHByb3RvdHlwZV0gXCIpO1xuICB9XG5cbiAgaWYgKHRhZyAhPT0gJycgJiYgY29uc3RydWN0b3IgIT09IHRhZykge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChjb25zdHJ1Y3RvciwgXCIgW1wiKS5jb25jYXQodGFnLCBcIl0gXCIpO1xuICB9XG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KGNvbnN0cnVjdG9yLCBcIiBcIik7XG59IC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cblxuXG5mdW5jdGlvbiBnZXRLZXlzKHZhbHVlLCBzaG93SGlkZGVuKSB7XG4gIHZhciBrZXlzO1xuICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpO1xuXG4gIGlmIChzaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcblxuICAgIGlmIChzeW1ib2xzLmxlbmd0aCAhPT0gMCkge1xuICAgICAga2V5cy5wdXNoKC4uLnN5bWJvbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIG1pZ2h0IHRocm93IGlmIGB2YWx1ZWAgaXMgYSBNb2R1bGUgTmFtZXNwYWNlIE9iamVjdCBmcm9tIGFuXG4gICAgLy8gdW5ldmFsdWF0ZWQgbW9kdWxlLCBidXQgd2UgZG9uJ3Qgd2FudCB0byBwZXJmb3JtIHRoZSBhY3R1YWwgdHlwZVxuICAgIC8vIGNoZWNrIGJlY2F1c2UgaXQncyBleHBlbnNpdmUuXG4gICAgLy8gVE9ETyhkZXZzbmVrKTogdHJhY2sgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvZWNtYTI2Mi9pc3N1ZXMvMTIwOVxuICAgIC8vIGFuZCBtb2RpZnkgdGhpcyBsb2dpYyBhcyBuZWVkZWQuXG4gICAgdHJ5IHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBAZml4bWUgaG93IHRvIGR1IGlzTW9kdWxlTmFtZXNwYWNlT2JqZWN0P1xuXG4gICAgICAvKlxuICAgICAgYXNzZXJ0KGlzTmF0aXZlRXJyb3IoZXJyKSAmJiBlcnIubmFtZSA9PT0gJ1JlZmVyZW5jZUVycm9yJyAmJlxuICAgICAgXHRcdFx0IGlzTW9kdWxlTmFtZXNwYWNlT2JqZWN0KHZhbHVlKSk7XG4gICAgICAqL1xuICAgICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoc3ltYm9scy5sZW5ndGggIT09IDApIHtcbiAgICAgIGtleXMucHVzaCguLi5zeW1ib2xzLmZpbHRlcihrZXkgPT4gcHJvcGVydHlJc0VudW1lcmFibGUkMSh2YWx1ZSwga2V5KSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBnZXRDdHhTdHlsZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZykge1xuICB2YXIgZmFsbGJhY2sgPSAnJztcblxuICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICBmYWxsYmFjayA9ICdPYmplY3QnO1xuICB9XG5cbiAgcmV0dXJuIGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCBmYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGZpbmRUeXBlZENvbnN0cnVjdG9yKHZhbHVlKSB7XG4gIGZvciAodmFyIFtjaGVjaywgY2xhenpdIG9mIFtbaXNVaW50OEFycmF5LCBVaW50OEFycmF5XSwgW2lzVWludDhDbGFtcGVkQXJyYXksIFVpbnQ4Q2xhbXBlZEFycmF5XSwgW2lzVWludDE2QXJyYXksIFVpbnQxNkFycmF5XSwgW2lzVWludDMyQXJyYXksIFVpbnQzMkFycmF5XSwgW2lzSW50OEFycmF5LCBJbnQ4QXJyYXldLCBbaXNJbnQxNkFycmF5LCBJbnQxNkFycmF5XSwgW2lzSW50MzJBcnJheSwgSW50MzJBcnJheV0sIFtpc0Zsb2F0MzJBcnJheSwgRmxvYXQzMkFycmF5XSwgW2lzRmxvYXQ2NEFycmF5LCBGbG9hdDY0QXJyYXldXSkge1xuICAgIGlmIChjaGVjayh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbGF6ejtcbiAgICB9XG4gIH1cbn1cblxudmFyIGxhenlOdWxsUHJvdG90eXBlQ2FjaGU7IC8vIENyZWF0ZXMgYSBzdWJjbGFzcyBhbmQgbmFtZVxuLy8gdGhlIGNvbnN0cnVjdG9yIGFzIGAke2NsYXp6fSA6IG51bGwgcHJvdG90eXBlYFxuXG5mdW5jdGlvbiBjbGF6eldpdGhOdWxsUHJvdG90eXBlKGNsYXp6LCBuYW1lKSB7XG4gIGlmIChsYXp5TnVsbFByb3RvdHlwZUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICBsYXp5TnVsbFByb3RvdHlwZUNhY2hlID0gbmV3IE1hcCgpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjYWNoZWRDbGFzcyA9IGxhenlOdWxsUHJvdG90eXBlQ2FjaGUuZ2V0KGNsYXp6KTtcblxuICAgIGlmIChjYWNoZWRDbGFzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ2xhc3M7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgTnVsbFByb3RvdHlwZSBleHRlbmRzIGNsYXp6IHtcbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTnVsbFByb3RvdHlwZS5wcm90b3R5cGUuY29uc3RydWN0b3IsICduYW1lJywge1xuICAgIHZhbHVlOiBcIltcIi5jb25jYXQobmFtZSwgXCI6IG51bGwgcHJvdG90eXBlXVwiKVxuICB9KTtcbiAgbGF6eU51bGxQcm90b3R5cGVDYWNoZS5zZXQoY2xhenosIE51bGxQcm90b3R5cGUpO1xuICByZXR1cm4gTnVsbFByb3RvdHlwZTtcbn1cblxuZnVuY3Rpb24gbm9Qcm90b3R5cGVJdGVyYXRvcihjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgdmFyIG5ld1ZhbDtcblxuICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgdmFyIGNsYXp6ID0gY2xhenpXaXRoTnVsbFByb3RvdHlwZShTZXQsICdTZXQnKTtcbiAgICBuZXdWYWwgPSBuZXcgY2xhenooU2V0UHJvdG90eXBlLnZhbHVlcyh2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhciBfY2xhenogPSBjbGF6eldpdGhOdWxsUHJvdG90eXBlKE1hcCwgJ01hcCcpO1xuXG4gICAgbmV3VmFsID0gbmV3IF9jbGF6eihNYXBQcm90b3R5cGUuZW50cmllcyh2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIF9jbGF6ejIgPSBjbGF6eldpdGhOdWxsUHJvdG90eXBlKEFycmF5LCAnQXJyYXknKTtcblxuICAgIG5ld1ZhbCA9IG5ldyBfY2xhenoyKHZhbHVlLmxlbmd0aCk7XG4gIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5JDEodmFsdWUpKSB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IGZpbmRUeXBlZENvbnN0cnVjdG9yKHZhbHVlKTtcblxuICAgIHZhciBfY2xhenozID0gY2xhenpXaXRoTnVsbFByb3RvdHlwZShfY29uc3RydWN0b3IsIF9jb25zdHJ1Y3Rvci5uYW1lKTtcblxuICAgIG5ld1ZhbCA9IG5ldyBfY2xhenozKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChuZXdWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5ld1ZhbCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModmFsdWUpKTtcbiAgICByZXR1cm4gZm9ybWF0UmF3KGN0eCwgbmV3VmFsLCByZWN1cnNlVGltZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdHlwZWRBcnJheSkge1xuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllcy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZvcm1hdFByaW1pdGl2ZShjdHguc3R5bGl6ZSwgdmFsdWUsIGN0eCk7XG4gIH1cblxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xuICB9IC8vIE1lbW9yaXplIHRoZSBjb250ZXh0IGZvciBjdXN0b20gaW5zcGVjdGlvbiBvbiBwcm94aWVzLlxuXG5cbiAgdmFyIGNvbnRleHQgPSB2YWx1ZTtcbiAgLypcbiAgQGZpeG1lIGNoZWNrIGZvciBwcm94aWVzXG4gIC8vIEFsd2F5cyBjaGVjayBmb3IgcHJveGllcyB0byBwcmV2ZW50IHNpZGUgZWZmZWN0cyBhbmQgdG8gcHJldmVudCB0cmlnZ2VyaW5nXG4gIC8vIGFueSBwcm94eSBoYW5kbGVycy5cbiAgY29uc3QgcHJveHkgPSBnZXRQcm94eURldGFpbHModmFsdWUpO1xuICBpZiAocHJveHkgIT09IHVuZGVmaW5lZCkge1xuICBcdGlmIChjdHguc2hvd1Byb3h5KSB7XG4gIFx0XHRyZXR1cm4gZm9ybWF0UHJveHkoY3R4LCBwcm94eSwgcmVjdXJzZVRpbWVzKTtcbiAgXHR9XG4gIFx0dmFsdWUgPSBwcm94eVswXTtcbiAgfVxuICAqL1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdC5cblxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QpIHtcbiAgICB2YXIgbWF5YmVDdXN0b20gPSB2YWx1ZVtjdXN0b21JbnNwZWN0U3ltYm9sXTtcblxuICAgIGlmICh0eXBlb2YgbWF5YmVDdXN0b20gPT09ICdmdW5jdGlvbicgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0cyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWwuXG4gICAgJiYgbWF5YmVDdXN0b20gIT09IGluc3BlY3QgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgJiYgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgICAgLy8gVGhpcyBtYWtlcyBzdXJlIHRoZSByZWN1cnNlVGltZXMgYXJlIHJlcG9ydGVkIGFzIGJlZm9yZSB3aGlsZSB1c2luZ1xuICAgICAgLy8gYSBjb3VudGVyIGludGVybmFsbHkuXG4gICAgICB2YXIgZGVwdGggPSBjdHguZGVwdGggPT09IG51bGwgPyBudWxsIDogY3R4LmRlcHRoIC0gcmVjdXJzZVRpbWVzO1xuICAgICAgdmFyIHJldCA9IG1heWJlQ3VzdG9tLmNhbGwoY29udGV4dCwgZGVwdGgsIGdldFVzZXJPcHRpb25zKGN0eCkpOyAvLyBJZiB0aGUgY3VzdG9tIGluc3BlY3Rpb24gbWV0aG9kIHJldHVybmVkIGB0aGlzYCwgZG9uJ3QgZ28gaW50b1xuICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uLlxuXG4gICAgICBpZiAocmV0ICE9PSBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQucmVwbGFjZSgvXFxuL2csIFwiXFxuXCIuY29uY2F0KCcgJy5yZXBlYXQoY3R4LmluZGVudGF0aW9uTHZsKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBVc2luZyBhbiBhcnJheSBoZXJlIGlzIGFjdHVhbGx5IGJldHRlciBmb3IgdGhlIGF2ZXJhZ2UgY2FzZSB0aGFuIHVzaW5nXG4gIC8vIGEgU2V0LiBgc2VlbmAgd2lsbCBvbmx5IGNoZWNrIGZvciB0aGUgZGVwdGggYW5kIHdpbGwgbmV2ZXIgZ3JvdyB0b28gbGFyZ2UuXG5cblxuICBpZiAoY3R4LnNlZW4uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgdmFyIGluZGV4ID0gMTtcblxuICAgIGlmIChjdHguY2lyY3VsYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LmNpcmN1bGFyID0gbmV3IE1hcChbW3ZhbHVlLCBpbmRleF1dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXggPSBjdHguY2lyY3VsYXIuZ2V0KHZhbHVlKTtcblxuICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSBjdHguY2lyY3VsYXIuc2l6ZSArIDE7XG4gICAgICAgIGN0eC5jaXJjdWxhci5zZXQodmFsdWUsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY3R4LnN0eWxpemUoXCJbQ2lyY3VsYXIgKlwiLmNvbmNhdChpbmRleCwgXCJdXCIpLCAnc3BlY2lhbCcpO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdFJhdyhjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHR5cGVkQXJyYXkpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRSYXcoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB0eXBlZEFycmF5KSB7XG4gIHZhciBrZXlzO1xuICB2YXIgY29uc3RydWN0b3IgPSBnZXRDb25zdHJ1Y3Rvck5hbWUodmFsdWUpO1xuICB2YXIgdGFnID0gdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXTsgLy8gT25seSBsaXN0IHRoZSB0YWcgaW4gY2FzZSBpdCdzIG5vbi1lbnVtZXJhYmxlIC8gbm90IGFuIG93biBwcm9wZXJ0eS5cbiAgLy8gT3RoZXJ3aXNlIHdlJ2QgcHJpbnQgdGhpcyB0d2ljZS5cblxuICBpZiAodHlwZW9mIHRhZyAhPT0gJ3N0cmluZycgfHwgdGFnICE9PSAnJyAmJiAoY3R4LnNob3dIaWRkZW4gPyBoYXNPd25Qcm9wZXJ0eSQxIDogcHJvcGVydHlJc0VudW1lcmFibGUkMSkodmFsdWUsIFN5bWJvbC50b1N0cmluZ1RhZykpIHtcbiAgICB0YWcgPSAnJztcbiAgfVxuXG4gIHZhciBiYXNlID0gJyc7XG4gIHZhciBmb3JtYXR0ZXIgPSBnZXRFbXB0eUZvcm1hdEFycmF5O1xuICB2YXIgYnJhY2VzO1xuICB2YXIgbm9JdGVyYXRvciA9IHRydWU7XG4gIHZhciBpID0gMDtcbiAgdmFyIGZpbHRlciA9IGN0eC5zaG93SGlkZGVuID8gQUxMX1BST1BFUlRJRVMkMiA6IE9OTFlfRU5VTUVSQUJMRSQyO1xuICB2YXIgZXh0cmFzVHlwZSA9IGtPYmplY3RUeXBlOyAvLyBJdGVyYXRvcnMgYW5kIHRoZSByZXN0IGFyZSBzcGxpdCB0byByZWR1Y2UgY2hlY2tzLlxuXG4gIGlmICh2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgbm9JdGVyYXRvciA9IGZhbHNlO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBrZXlzID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbHVlLCBmaWx0ZXIpOyAvLyBPbmx5IHNldCB0aGUgY29uc3RydWN0b3IgZm9yIG5vbiBvcmRpbmFyeSAoXCJBcnJheSBbLi4uXVwiKSBhcnJheXMuXG5cbiAgICAgIHZhciBwcmVmaXggPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ0FycmF5Jyk7XG4gICAgICBicmFjZXMgPSBbXCJcIi5jb25jYXQocHJlZml4ID09PSAnQXJyYXkgJyA/ICcnIDogcHJlZml4LCBcIltcIiksICddJ107XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDAgJiYga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGJyYWNlc1swXSwgXCJdXCIpO1xuICAgICAgfVxuXG4gICAgICBleHRyYXNUeXBlID0ga0FycmF5RXh0cmFzVHlwZTtcbiAgICAgIGZvcm1hdHRlciA9IGZvcm1hdEFycmF5O1xuICAgIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgICBrZXlzID0gZ2V0S2V5cyh2YWx1ZSwgY3R4LnNob3dIaWRkZW4pO1xuXG4gICAgICB2YXIgX3ByZWZpeCA9IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnU2V0Jyk7XG5cbiAgICAgIGlmICh2YWx1ZS5zaXplID09PSAwICYmIGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChfcHJlZml4LCBcInt9XCIpO1xuICAgICAgfVxuXG4gICAgICBicmFjZXMgPSBbXCJcIi5jb25jYXQoX3ByZWZpeCwgXCJ7XCIpLCAnfSddO1xuICAgICAgZm9ybWF0dGVyID0gZm9ybWF0U2V0O1xuICAgIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgICBrZXlzID0gZ2V0S2V5cyh2YWx1ZSwgY3R4LnNob3dIaWRkZW4pO1xuXG4gICAgICB2YXIgX3ByZWZpeDIgPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ01hcCcpO1xuXG4gICAgICBpZiAodmFsdWUuc2l6ZSA9PT0gMCAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoX3ByZWZpeDIsIFwie31cIik7XG4gICAgICB9XG5cbiAgICAgIGJyYWNlcyA9IFtcIlwiLmNvbmNhdChfcHJlZml4MiwgXCJ7XCIpLCAnfSddO1xuICAgICAgZm9ybWF0dGVyID0gZm9ybWF0TWFwO1xuICAgIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5JDEodmFsdWUpKSB7XG4gICAgICBrZXlzID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbHVlLCBmaWx0ZXIpO1xuXG4gICAgICB2YXIgX3ByZWZpeDMgPSBjb25zdHJ1Y3RvciAhPT0gbnVsbCA/IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnKSA6IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCBmaW5kVHlwZWRDb25zdHJ1Y3Rvcih2YWx1ZSkubmFtZSk7XG5cbiAgICAgIGJyYWNlcyA9IFtcIlwiLmNvbmNhdChfcHJlZml4MywgXCJbXCIpLCAnXSddO1xuXG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwICYmIGtleXMubGVuZ3RoID09PSAwICYmICFjdHguc2hvd0hpZGRlbikge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoYnJhY2VzWzBdLCBcIl1cIik7XG4gICAgICB9XG5cbiAgICAgIGZvcm1hdHRlciA9IGZvcm1hdFR5cGVkQXJyYXk7XG4gICAgICBleHRyYXNUeXBlID0ga0FycmF5RXh0cmFzVHlwZTtcbiAgICB9IGVsc2UgaWYgKGlzTWFwSXRlcmF0b3IodmFsdWUpKSB7XG4gICAgICBrZXlzID0gZ2V0S2V5cyh2YWx1ZSwgY3R4LnNob3dIaWRkZW4pO1xuICAgICAgYnJhY2VzID0gZ2V0SXRlcmF0b3JCcmFjZXMoJ01hcCcsIHRhZyk7XG4gICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRJdGVyYXRvcjtcbiAgICB9IGVsc2UgaWYgKGlzU2V0SXRlcmF0b3IodmFsdWUpKSB7XG4gICAgICBrZXlzID0gZ2V0S2V5cyh2YWx1ZSwgY3R4LnNob3dIaWRkZW4pO1xuICAgICAgYnJhY2VzID0gZ2V0SXRlcmF0b3JCcmFjZXMoJ1NldCcsIHRhZyk7XG4gICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRJdGVyYXRvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9JdGVyYXRvciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vSXRlcmF0b3IpIHtcbiAgICBrZXlzID0gZ2V0S2V5cyh2YWx1ZSwgY3R4LnNob3dIaWRkZW4pO1xuICAgIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgICBpZiAoY29uc3RydWN0b3IgPT09ICdPYmplY3QnKSB7XG4gICAgICBpZiAoaXNBcmd1bWVudHNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGJyYWNlc1swXSA9ICdbQXJndW1lbnRzXSB7JztcbiAgICAgIH0gZWxzZSBpZiAodGFnICE9PSAnJykge1xuICAgICAgICBicmFjZXNbMF0gPSBcIlwiLmNvbmNhdChnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ09iamVjdCcpLCBcIntcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoYnJhY2VzWzBdLCBcIn1cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJhc2UgPSBnZXRGdW5jdGlvbkJhc2UodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpO1xuXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKGJhc2UsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc2VjdXJpdHkvZGV0ZWN0LW5vbi1saXRlcmFsLXJlZ2V4cFxuICAgICAgdmFyIHJlZ0V4cCA9IGNvbnN0cnVjdG9yICE9PSBudWxsID8gdmFsdWUgOiBuZXcgUmVnRXhwKHZhbHVlKTtcbiAgICAgIGJhc2UgPSBSZWdFeHBQcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZWdFeHApO1xuXG4gICAgICB2YXIgX3ByZWZpeDQgPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ1JlZ0V4cCcpO1xuXG4gICAgICBpZiAoX3ByZWZpeDQgIT09ICdSZWdFeHAgJykge1xuICAgICAgICBiYXNlID0gXCJcIi5jb25jYXQoX3ByZWZpeDQpLmNvbmNhdChiYXNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwIHx8IHJlY3Vyc2VUaW1lcyA+IGN0eC5kZXB0aCAmJiBjdHguZGVwdGggIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKGJhc2UsICdyZWdleHAnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICAgICAgYmFzZSA9IE51bWJlci5pc05hTihEYXRlUHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWx1ZSkpID8gRGF0ZVByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA6IERhdGVQcm90b3R5cGUudG9JU09TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cbiAgICAgIHZhciBfcHJlZml4NSA9IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnRGF0ZScpO1xuXG4gICAgICBpZiAoX3ByZWZpeDUgIT09ICdEYXRlICcpIHtcbiAgICAgICAgYmFzZSA9IFwiXCIuY29uY2F0KF9wcmVmaXg1KS5jb25jYXQoYmFzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoYmFzZSwgJ2RhdGUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICBiYXNlID0gZm9ybWF0RXJyb3IodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcsIGN0eCk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNJb3MkMSkge1xuICAgICAgICB2YXIgbmF0aXZlRXJyb3JQcm9wcyA9IFsnbGluZScsICdjb2x1bW4nLCAnc291cmNlVVJMJ107XG5cbiAgICAgICAgaWYgKGtleXMuZXZlcnkoa2V5ID0+IG5hdGl2ZUVycm9yUHJvcHMuaW5jbHVkZXMoa2V5KSkpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIC8vIEZhc3QgcGF0aCBmb3IgQXJyYXlCdWZmZXIgYW5kIFNoYXJlZEFycmF5QnVmZmVyLlxuICAgICAgLy8gQ2FuJ3QgZG8gdGhlIHNhbWUgZm9yIERhdGFWaWV3IGJlY2F1c2UgaXQgaGFzIGEgbm9uLXByaW1pdGl2ZVxuICAgICAgLy8gLmJ1ZmZlciBwcm9wZXJ0eSB0aGF0IHdlIG5lZWQgdG8gcmVjdXJzZSBmb3IuXG4gICAgICB2YXIgYXJyYXlUeXBlID0gaXNBcnJheUJ1ZmZlcih2YWx1ZSkgPyAnQXJyYXlCdWZmZXInIDogJ1NoYXJlZEFycmF5QnVmZmVyJztcblxuICAgICAgdmFyIF9wcmVmaXg2ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsIGFycmF5VHlwZSk7XG5cbiAgICAgIGlmICh0eXBlZEFycmF5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9ybWF0dGVyID0gZm9ybWF0QXJyYXlCdWZmZXI7XG4gICAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChfcHJlZml4NiwgXCJ7IGJ5dGVMZW5ndGg6IFwiKS5jb25jYXQoZm9ybWF0TnVtYmVyKGN0eC5zdHlsaXplLCB2YWx1ZS5ieXRlTGVuZ3RoKSwgXCIgfVwiKTtcbiAgICAgIH1cblxuICAgICAgYnJhY2VzWzBdID0gXCJcIi5jb25jYXQoX3ByZWZpeDYsIFwie1wiKTtcbiAgICAgIGtleXMudW5zaGlmdCgnYnl0ZUxlbmd0aCcpO1xuICAgIH0gZWxzZSBpZiAoaXNEYXRhVmlldyh2YWx1ZSkpIHtcbiAgICAgIGJyYWNlc1swXSA9IFwiXCIuY29uY2F0KGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnRGF0YVZpZXcnKSwgXCJ7XCIpOyAvLyAuYnVmZmVyIGdvZXMgbGFzdCwgaXQncyBub3QgYSBwcmltaXRpdmUgbGlrZSB0aGUgb3RoZXJzLlxuXG4gICAgICBrZXlzLnVuc2hpZnQoJ2J5dGVMZW5ndGgnLCAnYnl0ZU9mZnNldCcsICdidWZmZXInKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgIGJyYWNlc1swXSA9IFwiXCIuY29uY2F0KGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnUHJvbWlzZScpLCBcIntcIik7XG4gICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRQcm9taXNlO1xuICAgIH0gZWxzZSBpZiAoaXNXZWFrU2V0KHZhbHVlKSkge1xuICAgICAgYnJhY2VzWzBdID0gXCJcIi5jb25jYXQoZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdXZWFrU2V0JyksIFwie1wiKTtcbiAgICAgIGZvcm1hdHRlciA9IGN0eC5zaG93SGlkZGVuID8gZm9ybWF0V2Vha1NldCA6IGZvcm1hdFdlYWtDb2xsZWN0aW9uO1xuICAgIH0gZWxzZSBpZiAoaXNXZWFrTWFwKHZhbHVlKSkge1xuICAgICAgYnJhY2VzWzBdID0gXCJcIi5jb25jYXQoZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdXZWFrTWFwJyksIFwie1wiKTtcbiAgICAgIGZvcm1hdHRlciA9IGN0eC5zaG93SGlkZGVuID8gZm9ybWF0V2Vha01hcCA6IGZvcm1hdFdlYWtDb2xsZWN0aW9uO1xuICAgICAgLypcbiAgICAgICAqIEBmaXhtZSBob3cgdG8gZG8gaXNNb2R1bGVOYW1lc3BhY2VPYmplY3Q/XG4gICAgICB9IGVsc2UgaWYgKGlzTW9kdWxlTmFtZXNwYWNlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgXHRicmFjZXNbMF0gPSBgWyR7dGFnfV0ge2A7XG4gICAgICBcdGZvcm1hdHRlciA9IGZvcm1hdE5hbWVzcGFjZU9iamVjdDtcbiAgICAgICovXG4gICAgfSBlbHNlIGlmIChpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgICAgYmFzZSA9IGdldEJveGVkQmFzZSh2YWx1ZSwgY3R4LCBrZXlzLCBjb25zdHJ1Y3RvciwgdGFnKTtcblxuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgaW5wdXQgcHJvdG90eXBlIGdvdCBtYW5pcHVsYXRlZC4gU3BlY2lhbCBoYW5kbGUgdGhlc2UuIFdlIGhhdmUgdG9cbiAgICAgIC8vIHJlYnVpbGQgdGhlIGluZm9ybWF0aW9uIHNvIHdlIGFyZSBhYmxlIHRvIGRpc3BsYXkgZXZlcnl0aGluZy5cbiAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgc3BlY2lhbEl0ZXJhdG9yID0gbm9Qcm90b3R5cGVJdGVyYXRvcihjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpO1xuXG4gICAgICAgIGlmIChzcGVjaWFsSXRlcmF0b3IpIHtcbiAgICAgICAgICByZXR1cm4gc3BlY2lhbEl0ZXJhdG9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc01hcEl0ZXJhdG9yKHZhbHVlKSkge1xuICAgICAgICBicmFjZXMgPSBnZXRJdGVyYXRvckJyYWNlcygnTWFwJywgdGFnKTtcbiAgICAgICAgZm9ybWF0dGVyID0gZm9ybWF0SXRlcmF0b3I7XG4gICAgICB9IGVsc2UgaWYgKGlzU2V0SXRlcmF0b3IodmFsdWUpKSB7XG4gICAgICAgIGJyYWNlcyA9IGdldEl0ZXJhdG9yQnJhY2VzKCdTZXQnLCB0YWcpO1xuICAgICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRJdGVyYXRvcjsgLy8gSGFuZGxlIG90aGVyIHJlZ3VsYXIgb2JqZWN0cyBhZ2Fpbi5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChnZXRDdHhTdHlsZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZyksIFwie31cIik7XG4gICAgICAgIH1cblxuICAgICAgICBicmFjZXNbMF0gPSBcIlwiLmNvbmNhdChnZXRDdHhTdHlsZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZyksIFwie1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzID4gY3R4LmRlcHRoICYmIGN0eC5kZXB0aCAhPT0gbnVsbCkge1xuICAgIHZhciBjb25zdHJ1Y3Rvck5hbWUgPSBnZXRDdHhTdHlsZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZykuc2xpY2UoMCwgLTEpO1xuXG4gICAgaWYgKGNvbnN0cnVjdG9yICE9PSBudWxsKSB7XG4gICAgICBjb25zdHJ1Y3Rvck5hbWUgPSBcIltcIi5jb25jYXQoY29uc3RydWN0b3JOYW1lLCBcIl1cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKGNvbnN0cnVjdG9yTmFtZSwgJ3NwZWNpYWwnKTtcbiAgfVxuXG4gIHJlY3Vyc2VUaW1lcyArPSAxO1xuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcbiAgY3R4LmN1cnJlbnREZXB0aCA9IHJlY3Vyc2VUaW1lcztcbiAgdmFyIG91dHB1dDtcbiAgdmFyIGluZGVudGF0aW9uTHZsID0gY3R4LmluZGVudGF0aW9uTHZsO1xuXG4gIHRyeSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0dGVyKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywga2V5cywgYnJhY2VzKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIGtleXNbaV0sIGV4dHJhc1R5cGUpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHZhciBfY29uc3RydWN0b3JOYW1lID0gZ2V0Q3R4U3R5bGUodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpLnNsaWNlKDAsIC0xKTtcblxuICAgIHJldHVybiBoYW5kbGVNYXhDYWxsU3RhY2tTaXplKGN0eCwgZXJyLCBfY29uc3RydWN0b3JOYW1lLCBpbmRlbnRhdGlvbkx2bCk7XG4gIH1cblxuICBpZiAoY3R4LmNpcmN1bGFyICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgaW5kZXggPSBjdHguY2lyY3VsYXIuZ2V0KHZhbHVlKTtcblxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVmZXJlbmNlID0gY3R4LnN0eWxpemUoXCI8cmVmICpcIi5jb25jYXQoaW5kZXgsIFwiPlwiKSwgJ3NwZWNpYWwnKTsgLy8gQWRkIHJlZmVyZW5jZSBhbHdheXMgdG8gdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoZSBvdXRwdXQuXG5cbiAgICAgIGlmIChjdHguY29tcGFjdCAhPT0gdHJ1ZSkge1xuICAgICAgICBiYXNlID0gYmFzZSA9PT0gJycgPyByZWZlcmVuY2UgOiBcIlwiLmNvbmNhdChyZWZlcmVuY2UsIFwiIFwiKS5jb25jYXQoYmFzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmFjZXNbMF0gPSBcIlwiLmNvbmNhdChyZWZlcmVuY2UsIFwiIFwiKS5jb25jYXQoYnJhY2VzWzBdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICBpZiAoY3R4LnNvcnRlZCkge1xuICAgIHZhciBjb21wYXJhdG9yID0gY3R4LnNvcnRlZCA9PT0gdHJ1ZSA/IHVuZGVmaW5lZCA6IGN0eC5zb3J0ZWQ7XG5cbiAgICBpZiAoZXh0cmFzVHlwZSA9PT0ga09iamVjdFR5cGUpIHtcbiAgICAgIG91dHB1dCA9IG91dHB1dC5zb3J0KGNvbXBhcmF0b3IpO1xuICAgIH0gZWxzZSBpZiAoa2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgc29ydGVkID0gb3V0cHV0LnNsaWNlKG91dHB1dC5sZW5ndGggLSBrZXlzLmxlbmd0aCkuc29ydChjb21wYXJhdG9yKTtcbiAgICAgIG91dHB1dC5zcGxpY2Uob3V0cHV0Lmxlbmd0aCAtIGtleXMubGVuZ3RoLCBrZXlzLmxlbmd0aCwgLi4uc29ydGVkKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzID0gcmVkdWNlVG9TaW5nbGVTdHJpbmcoY3R4LCBvdXRwdXQsIGJhc2UsIGJyYWNlcywgZXh0cmFzVHlwZSwgcmVjdXJzZVRpbWVzLCB2YWx1ZSk7XG4gIHZhciBidWRnZXQgPSBjdHguYnVkZ2V0W2N0eC5pbmRlbnRhdGlvbkx2bF0gfHwgMDtcbiAgdmFyIG5ld0xlbmd0aCA9IGJ1ZGdldCArIHJlcy5sZW5ndGg7XG4gIGN0eC5idWRnZXRbY3R4LmluZGVudGF0aW9uTHZsXSA9IG5ld0xlbmd0aDsgLy8gSWYgYW55IGluZGVudGF0aW9uTHZsIGV4Y2VlZHMgdGhpcyBsaW1pdCwgbGltaXQgZnVydGhlciBpbnNwZWN0aW5nIHRvIHRoZVxuICAvLyBtaW5pbXVtLiBPdGhlcndpc2UgdGhlIHJlY3Vyc2l2ZSBhbGdvcml0aG0gbWlnaHQgY29udGludWUgaW5zcGVjdGluZyB0aGVcbiAgLy8gb2JqZWN0IGV2ZW4gdGhvdWdoIHRoZSBtYXhpbXVtIHN0cmluZyBzaXplICh+MiAqKiAyOCBvbiAzMiBiaXQgc3lzdGVtcyBhbmRcbiAgLy8gfjIgKiogMzAgb24gNjQgYml0IHN5c3RlbXMpIGV4Y2VlZGVkLiBUaGUgYWN0dWFsIG91dHB1dCBpcyBub3QgbGltaXRlZCBhdFxuICAvLyBleGFjdGx5IDIgKiogMjcgYnV0IGEgYml0IGhpZ2hlci4gVGhpcyBkZXBlbmRzIG9uIHRoZSBvYmplY3Qgc2hhcGUuXG4gIC8vIFRoaXMgbGltaXQgYWxzbyBtYWtlcyBzdXJlIHRoYXQgaHVnZSBvYmplY3RzIGRvbid0IGJsb2NrIHRoZSBldmVudCBsb29wXG4gIC8vIHNpZ25pZmljYW50bHkuXG5cbiAgaWYgKG5ld0xlbmd0aCA+IE1hdGgucG93KDIsIDI3KSkge1xuICAgIGN0eC5kZXB0aCA9IC0xO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JCcmFjZXModHlwZSwgdGFnKSB7XG4gIGlmICh0YWcgIT09IFwiXCIuY29uY2F0KHR5cGUsIFwiIEl0ZXJhdG9yXCIpKSB7XG4gICAgaWYgKHRhZyAhPT0gJycpIHtcbiAgICAgIHRhZyArPSAnXSBbJztcbiAgICB9XG5cbiAgICB0YWcgKz0gXCJcIi5jb25jYXQodHlwZSwgXCIgSXRlcmF0b3JcIik7XG4gIH1cblxuICByZXR1cm4gW1wiW1wiLmNvbmNhdCh0YWcsIFwiXSB7XCIpLCAnfSddO1xufVxuXG5mdW5jdGlvbiBnZXRCb3hlZEJhc2UodmFsdWUsIGN0eCwga2V5cywgY29uc3RydWN0b3IsIHRhZykge1xuICB2YXIgZm47XG4gIHZhciB0eXBlO1xuXG4gIGlmIChpc051bWJlck9iamVjdCh2YWx1ZSkpIHtcbiAgICBmbiA9IE51bWJlclByb3RvdHlwZTtcbiAgICB0eXBlID0gJ051bWJlcic7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmdPYmplY3QodmFsdWUpKSB7XG4gICAgZm4gPSBTdHJpbmdQcm90b3R5cGU7XG4gICAgdHlwZSA9ICdTdHJpbmcnOyAvLyBGb3IgYm94ZWQgU3RyaW5ncywgd2UgaGF2ZSB0byByZW1vdmUgdGhlIDAtbiBpbmRleGVkIGVudHJpZXMsXG4gICAgLy8gc2luY2UgdGhleSBqdXN0IG5vaXN5IHVwIHRoZSBvdXRwdXQgYW5kIGFyZSByZWR1bmRhbnRcbiAgICAvLyBNYWtlIGJveGVkIHByaW1pdGl2ZSBTdHJpbmdzIGxvb2sgbGlrZSBzdWNoXG5cbiAgICBrZXlzLnNwbGljZSgwLCB2YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkpIHtcbiAgICBmbiA9IEJvb2xlYW5Qcm90b3R5cGU7XG4gICAgdHlwZSA9ICdCb29sZWFuJztcbiAgfSBlbHNlIHtcbiAgICBmbiA9IFN5bWJvbFByb3RvdHlwZTtcbiAgICB0eXBlID0gJ1N5bWJvbCc7XG4gIH1cblxuICB2YXIgYmFzZSA9IFwiW1wiLmNvbmNhdCh0eXBlKTtcblxuICBpZiAodHlwZSAhPT0gY29uc3RydWN0b3IpIHtcbiAgICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgIGJhc2UgKz0gJyAobnVsbCBwcm90b3R5cGUpJztcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZSArPSBcIiAoXCIuY29uY2F0KGNvbnN0cnVjdG9yLCBcIilcIik7XG4gICAgfVxuICB9XG5cbiAgYmFzZSArPSBcIjogXCIuY29uY2F0KGZvcm1hdFByaW1pdGl2ZShzdHlsaXplTm9Db2xvciwgZm4udmFsdWVPZih2YWx1ZSksIGN0eCksIFwiXVwiKTtcblxuICBpZiAodGFnICE9PSAnJyAmJiB0YWcgIT09IGNvbnN0cnVjdG9yKSB7XG4gICAgYmFzZSArPSBcIiBbXCIuY29uY2F0KHRhZywgXCJdXCIpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoICE9PSAwIHx8IGN0eC5zdHlsaXplID09PSBzdHlsaXplTm9Db2xvcikge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgcmV0dXJuIGN0eC5zdHlsaXplKGJhc2UsIHR5cGUudG9Mb3dlckNhc2UoKSk7XG59XG5cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uQmFzZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZykge1xuICB2YXIgdHlwZSA9ICdGdW5jdGlvbic7XG5cbiAgaWYgKGlzR2VuZXJhdG9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdHlwZSA9IFwiR2VuZXJhdG9yXCIuY29uY2F0KHR5cGUpO1xuICB9XG5cbiAgaWYgKGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB0eXBlID0gXCJBc3luY1wiLmNvbmNhdCh0eXBlKTtcbiAgfVxuXG4gIHZhciBiYXNlID0gXCJbXCIuY29uY2F0KHR5cGUpO1xuXG4gIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgIGJhc2UgKz0gJyAobnVsbCBwcm90b3R5cGUpJztcbiAgfVxuXG4gIGlmICh2YWx1ZS5uYW1lID09PSAnJykge1xuICAgIGJhc2UgKz0gJyAoYW5vbnltb3VzKSc7XG4gIH0gZWxzZSB7XG4gICAgYmFzZSArPSBcIjogXCIuY29uY2F0KHZhbHVlLm5hbWUpO1xuICB9XG5cbiAgYmFzZSArPSAnXSc7XG5cbiAgaWYgKGNvbnN0cnVjdG9yICE9PSB0eXBlICYmIGNvbnN0cnVjdG9yICE9PSBudWxsKSB7XG4gICAgYmFzZSArPSBcIiBcIi5jb25jYXQoY29uc3RydWN0b3IpO1xuICB9XG5cbiAgaWYgKHRhZyAhPT0gJycgJiYgY29uc3RydWN0b3IgIT09IHRhZykge1xuICAgIGJhc2UgKz0gXCIgW1wiLmNvbmNhdCh0YWcsIFwiXVwiKTtcbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcihlcnIsIGNvbnN0cnVjdG9yLCB0YWcsIGN0eCkge1xuICB2YXIgc3RhY2sgPSBlcnIuc3RhY2sgfHwgRXJyb3JQcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpOyAvLyB0cnkgdG8gbm9ybWFsaXplIEphdmFTY3JpcHRDb3JlIHN0YWNrIHRvIG1hdGNoIHY4XG5cbiAgaWYgKGlzSW9zJDEpIHtcbiAgICB2YXIgbGluZXMgPSBzdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgc3RhY2sgPSBcIlwiLmNvbmNhdChlcnIubmFtZSwgXCI6IFwiKS5jb25jYXQoZXJyLm1lc3NhZ2UpO1xuXG4gICAgaWYgKGxpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YWNrICs9IGxpbmVzLm1hcChzdGFja0xpbmUgPT4ge1xuICAgICAgICB2YXIgYXRTeW1ib2xJbmRleCA9IHN0YWNrTGluZS5pbmRleE9mKCdAJyk7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzdGFja0xpbmUuc2xpY2UoYXRTeW1ib2xJbmRleCArIDEpO1xuICAgICAgICB2YXIgc291cmNlUGF0dGVybiA9IC8oLiopOihcXGQrKTooXFxkKykvO1xuICAgICAgICB2YXIgc3ltYm9sTmFtZSA9ICd1bmtub3duJztcblxuICAgICAgICBpZiAoYXRTeW1ib2xJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBzeW1ib2xOYW1lID0gc3RhY2tMaW5lLnNsaWNlKDAsIGF0U3ltYm9sSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNvdXJjZU1hdGNoID0gc291cmNlLm1hdGNoKHNvdXJjZVBhdHRlcm4pO1xuXG4gICAgICAgIGlmIChzb3VyY2VNYXRjaCkge1xuICAgICAgICAgIHZhciBmaWxlUGF0aCA9IHNvdXJjZU1hdGNoWzFdO1xuICAgICAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlTWF0Y2hbMl07XG4gICAgICAgICAgdmFyIGNvbHVtbiA9IHNvdXJjZU1hdGNoWzNdO1xuXG4gICAgICAgICAgaWYgKGZpbGVQYXRoLnN0YXJ0c1dpdGgoJ2ZpbGU6JykpIHtcbiAgICAgICAgICAgIGZpbGVQYXRoID0gZmlsZVBhdGgucmVwbGFjZShcImZpbGU6Ly9cIi5jb25jYXQoVGkuRmlsZXN5c3RlbS5yZXNvdXJjZXNEaXJlY3RvcnkpLCAnJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFwiXFxuICAgIGF0IFwiLmNvbmNhdChzeW1ib2xOYW1lLCBcIiAoXCIpLmNvbmNhdChmaWxlUGF0aCwgXCI6XCIpLmNvbmNhdChsaW5lTnVtYmVyLCBcIjpcIikuY29uY2F0KGNvbHVtbiwgXCIpXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBcIlxcbiAgICBhdCBcIi5jb25jYXQoc3ltYm9sTmFtZSwgXCIgKFwiKS5jb25jYXQoc291cmNlLCBcIilcIik7XG4gICAgICAgIH1cbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cbiAgfSAvLyBBIHN0YWNrIHRyYWNlIG1heSBjb250YWluIGFyYml0cmFyeSBkYXRhLiBPbmx5IG1hbmlwdWxhdGUgdGhlIG91dHB1dFxuICAvLyBmb3IgXCJyZWd1bGFyIGVycm9yc1wiIChlcnJvcnMgdGhhdCBcImxvb2sgbm9ybWFsXCIpIGZvciBub3cuXG5cblxuICB2YXIgbmFtZSA9IGVyci5uYW1lIHx8ICdFcnJvcic7XG4gIHZhciBsZW4gPSBuYW1lLmxlbmd0aDtcblxuICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwgfHwgbmFtZS5lbmRzV2l0aCgnRXJyb3InKSAmJiBzdGFjay5zdGFydHNXaXRoKG5hbWUpICYmIChzdGFjay5sZW5ndGggPT09IGxlbiB8fCBzdGFja1tsZW5dID09PSAnOicgfHwgc3RhY2tbbGVuXSA9PT0gJ1xcbicpKSB7XG4gICAgdmFyIGZhbGxiYWNrID0gJ0Vycm9yJztcblxuICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgdmFyIHN0YXJ0ID0gc3RhY2subWF0Y2goL14oW0EtWl1bYS16XyBBLVowLTlbXFxdKCktXSspKD86OnxcXG4gezR9YXQpLykgfHwgc3RhY2subWF0Y2goL14oW2Etel9BLVowLTktXSpFcnJvcikkLyk7XG4gICAgICBmYWxsYmFjayA9IHN0YXJ0ICYmIHN0YXJ0WzFdIHx8ICcnO1xuICAgICAgbGVuID0gZmFsbGJhY2subGVuZ3RoO1xuICAgICAgZmFsbGJhY2sgPSBmYWxsYmFjayB8fCAnRXJyb3InO1xuICAgIH1cblxuICAgIHZhciBwcmVmaXggPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgZmFsbGJhY2spLnNsaWNlKDAsIC0xKTtcblxuICAgIGlmIChuYW1lICE9PSBwcmVmaXgpIHtcbiAgICAgIGlmIChwcmVmaXguaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgIHN0YWNrID0gXCJcIi5jb25jYXQocHJlZml4LCBcIjogXCIpLmNvbmNhdChzdGFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhY2sgPSBcIlwiLmNvbmNhdChwcmVmaXgpLmNvbmNhdChzdGFjay5zbGljZShsZW4pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhY2sgPSBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFtcIikuY29uY2F0KG5hbWUsIFwiXVwiKS5jb25jYXQoc3RhY2suc2xpY2UobGVuKSk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIElnbm9yZSB0aGUgZXJyb3IgbWVzc2FnZSBpZiBpdCdzIGNvbnRhaW5lZCBpbiB0aGUgc3RhY2suXG5cblxuICB2YXIgcG9zID0gZXJyLm1lc3NhZ2UgJiYgc3RhY2suaW5kZXhPZihlcnIubWVzc2FnZSkgfHwgLTE7XG5cbiAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICBwb3MgKz0gZXJyLm1lc3NhZ2UubGVuZ3RoO1xuICB9IC8vIFdyYXAgdGhlIGVycm9yIGluIGJyYWNrZXRzIGluIGNhc2UgaXQgaGFzIG5vIHN0YWNrIHRyYWNlLlxuXG5cbiAgdmFyIHN0YWNrU3RhcnQgPSBzdGFjay5pbmRleE9mKCdcXG4gICAgYXQnLCBwb3MpO1xuXG4gIGlmIChzdGFja1N0YXJ0ID09PSAtMSkge1xuICAgIHN0YWNrID0gXCJbXCIuY29uY2F0KHN0YWNrLCBcIl1cIik7XG4gIH0gZWxzZSBpZiAoY3R4LmNvbG9ycykge1xuICAgIC8vIEhpZ2hsaWdodCB1c2VybGFuZCBjb2RlIGFuZCBub2RlIG1vZHVsZXMuXG4gICAgdmFyIG5ld1N0YWNrID0gc3RhY2suc2xpY2UoMCwgc3RhY2tTdGFydCk7XG5cbiAgICB2YXIgX2xpbmVzID0gc3RhY2suc2xpY2Uoc3RhY2tTdGFydCArIDEpLnNwbGl0KCdcXG4nKTtcblxuICAgIGZvciAodmFyIGxpbmUgb2YgX2xpbmVzKSB7XG4gICAgICAvLyBUaGlzIGFkZHMgdW5kZXJzY29yZXMgdG8gYWxsIG5vZGVfbW9kdWxlcyB0byBxdWlja2x5IGlkZW50aWZ5IHRoZW0uXG4gICAgICB2YXIgbm9kZU1vZHVsZSA9IHZvaWQgMDtcbiAgICAgIG5ld1N0YWNrICs9ICdcXG4nO1xuICAgICAgdmFyIF9wb3MgPSAwO1xuXG4gICAgICB3aGlsZSAobm9kZU1vZHVsZSA9IG5vZGVNb2R1bGVzUmVnRXhwLmV4ZWMobGluZSkpIHtcbiAgICAgICAgLy8gJy9ub2RlX21vZHVsZXMvJy5sZW5ndGggPT09IDE0XG4gICAgICAgIG5ld1N0YWNrICs9IGxpbmUuc2xpY2UoX3Bvcywgbm9kZU1vZHVsZS5pbmRleCArIDE0KTtcbiAgICAgICAgbmV3U3RhY2sgKz0gY3R4LnN0eWxpemUobm9kZU1vZHVsZVsxXSwgJ21vZHVsZScpO1xuICAgICAgICBfcG9zID0gbm9kZU1vZHVsZS5pbmRleCArIG5vZGVNb2R1bGVbMF0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBuZXdTdGFjayArPSBfcG9zID09PSAwID8gbGluZSA6IGxpbmUuc2xpY2UoX3Bvcyk7XG4gICAgfVxuXG4gICAgc3RhY2sgPSBuZXdTdGFjaztcbiAgfSAvLyBUaGUgbWVzc2FnZSBhbmQgdGhlIHN0YWNrIGhhdmUgdG8gYmUgaW5kZW50ZWQgYXMgd2VsbCFcblxuXG4gIGlmIChjdHguaW5kZW50YXRpb25MdmwgIT09IDApIHtcbiAgICB2YXIgaW5kZW50YXRpb24gPSAnICcucmVwZWF0KGN0eC5pbmRlbnRhdGlvbkx2bCk7XG4gICAgc3RhY2sgPSBzdGFjay5yZXBsYWNlKC9cXG4vZywgXCJcXG5cIi5jb25jYXQoaW5kZW50YXRpb24pKTtcbiAgfVxuXG4gIHJldHVybiBzdGFjaztcbn1cblxuZnVuY3Rpb24gZm9ybWF0UHJvbWlzZShjdHgsIF92YWx1ZSwgX3JlY3Vyc2VUaW1lcykge1xuICAvLyBOb2RlIGNhbGxzIGludG8gbmF0aXZlIHRvIGdldCBwcm9taXNlIGRldGFpbHMgd2hpY2ggd2UgY2FuJ3QgZG9cbiAgcmV0dXJuIFtjdHguc3R5bGl6ZSgnPHVua25vd24+JywgJ3NwZWNpYWwnKV07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywga2V5LCB0eXBlKSB7XG4gIHZhciBuYW1lLCBzdHI7XG4gIHZhciBleHRyYSA9ICcgJztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHtcbiAgICB2YWx1ZTogdmFsdWVba2V5XSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH07XG5cbiAgaWYgKGRlc2MudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBkaWZmID0gdHlwZSAhPT0ga09iamVjdFR5cGUgfHwgY3R4LmNvbXBhY3QgIT09IHRydWUgPyAyIDogMztcbiAgICBjdHguaW5kZW50YXRpb25MdmwgKz0gZGlmZjtcbiAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyk7XG5cbiAgICBpZiAoZGlmZiA9PT0gMykge1xuICAgICAgdmFyIGxlbiA9IGN0eC5jb2xvcnMgPyByZW1vdmVDb2xvcnMoc3RyKS5sZW5ndGggOiBzdHIubGVuZ3RoO1xuXG4gICAgICBpZiAoY3R4LmJyZWFrTGVuZ3RoIDwgbGVuKSB7XG4gICAgICAgIGV4dHJhID0gXCJcXG5cIi5jb25jYXQoJyAnLnJlcGVhdChjdHguaW5kZW50YXRpb25MdmwpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguaW5kZW50YXRpb25MdmwgLT0gZGlmZjtcbiAgfSBlbHNlIGlmIChkZXNjLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGxhYmVsID0gZGVzYy5zZXQgIT09IHVuZGVmaW5lZCA/ICdHZXR0ZXIvU2V0dGVyJyA6ICdHZXR0ZXInO1xuICAgIHZhciBzID0gY3R4LnN0eWxpemU7XG4gICAgdmFyIHNwID0gJ3NwZWNpYWwnO1xuXG4gICAgaWYgKGN0eC5nZXR0ZXJzICYmIChjdHguZ2V0dGVycyA9PT0gdHJ1ZSB8fCBjdHguZ2V0dGVycyA9PT0gJ2dldCcgJiYgZGVzYy5zZXQgPT09IHVuZGVmaW5lZCB8fCBjdHguZ2V0dGVycyA9PT0gJ3NldCcgJiYgZGVzYy5zZXQgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB0bXAgPSB2YWx1ZVtrZXldO1xuICAgICAgICBjdHguaW5kZW50YXRpb25MdmwgKz0gMjtcblxuICAgICAgICBpZiAodG1wID09PSBudWxsKSB7XG4gICAgICAgICAgc3RyID0gXCJcIi5jb25jYXQocyhcIltcIi5jb25jYXQobGFiZWwsIFwiOlwiKSwgc3ApLCBcIiBcIikuY29uY2F0KHMoJ251bGwnLCAnbnVsbCcpKS5jb25jYXQocygnXScsIHNwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRtcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBzdHIgPSBcIlwiLmNvbmNhdChzKFwiW1wiLmNvbmNhdChsYWJlbCwgXCJdXCIpLCBzcCksIFwiIFwiKS5jb25jYXQoZm9ybWF0VmFsdWUoY3R4LCB0bXAsIHJlY3Vyc2VUaW1lcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUocywgdG1wLCBjdHgpO1xuICAgICAgICAgIHN0ciA9IFwiXCIuY29uY2F0KHMoXCJbXCIuY29uY2F0KGxhYmVsLCBcIjpcIiksIHNwKSwgXCIgXCIpLmNvbmNhdChwcmltaXRpdmUpLmNvbmNhdChzKCddJywgc3ApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCI8SW5zcGVjdGlvbiB0aHJldyAoXCIuY29uY2F0KGVyci5tZXNzYWdlLCBcIik+XCIpO1xuICAgICAgICBzdHIgPSBcIlwiLmNvbmNhdChzKFwiW1wiLmNvbmNhdChsYWJlbCwgXCI6XCIpLCBzcCksIFwiIFwiKS5jb25jYXQobWVzc2FnZSkuY29uY2F0KHMoJ10nLCBzcCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZShcIltcIi5jb25jYXQobGFiZWwsIFwiXVwiKSwgc3ApO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkZXNjLnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgfSBlbHNlIHtcbiAgICBzdHIgPSBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09IGtBcnJheVR5cGUpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnKSB7XG4gICAgdmFyIF90bXAgPSBrZXkudG9TdHJpbmcoKS5yZXBsYWNlKHN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyLCBlc2NhcGVGbik7XG5cbiAgICBuYW1lID0gXCJbXCIuY29uY2F0KGN0eC5zdHlsaXplKF90bXAsICdzeW1ib2wnKSwgXCJdXCIpO1xuICB9IGVsc2UgaWYgKGRlc2MuZW51bWVyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICBuYW1lID0gXCJbXCIuY29uY2F0KGtleS5yZXBsYWNlKHN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyLCBlc2NhcGVGbiksIFwiXVwiKTtcbiAgfSBlbHNlIGlmIChrZXlTdHJSZWdFeHAudGVzdChrZXkpKSB7XG4gICAgbmFtZSA9IGN0eC5zdHlsaXplKGtleSwgJ25hbWUnKTtcbiAgfSBlbHNlIHtcbiAgICBuYW1lID0gY3R4LnN0eWxpemUoc3RyRXNjYXBlKGtleSksICdzdHJpbmcnKTtcbiAgfVxuXG4gIHJldHVybiBcIlwiLmNvbmNhdChuYW1lLCBcIjpcIikuY29uY2F0KGV4dHJhKS5jb25jYXQoc3RyKTtcbn1cblxuZnVuY3Rpb24gZ3JvdXBBcnJheUVsZW1lbnRzKGN0eCwgb3V0cHV0LCB2YWx1ZSkge1xuICB2YXIgdG90YWxMZW5ndGggPSAwO1xuICB2YXIgbWF4TGVuZ3RoID0gMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgb3V0cHV0TGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuICBpZiAoY3R4Lm1heEFycmF5TGVuZ3RoIDwgb3V0cHV0Lmxlbmd0aCkge1xuICAgIC8vIFRoaXMgbWFrZXMgc3VyZSB0aGUgXCIuLi4gbiBtb3JlIGl0ZW1zXCIgcGFydCBpcyBub3QgdGFrZW4gaW50byBhY2NvdW50LlxuICAgIG91dHB1dExlbmd0aC0tO1xuICB9XG5cbiAgdmFyIHNlcGFyYXRvclNwYWNlID0gMjsgLy8gQWRkIDEgZm9yIHRoZSBzcGFjZSBhbmQgMSBmb3IgdGhlIHNlcGFyYXRvci5cblxuICB2YXIgZGF0YUxlbiA9IG5ldyBBcnJheShvdXRwdXRMZW5ndGgpOyAvLyBDYWxjdWxhdGUgdGhlIHRvdGFsIGxlbmd0aCBvZiBhbGwgb3V0cHV0IGVudHJpZXMgYW5kIHRoZSBpbmRpdmlkdWFsIG1heFxuICAvLyBlbnRyaWVzIGxlbmd0aCBvZiBhbGwgb3V0cHV0IGVudHJpZXMuIFdlIGhhdmUgdG8gcmVtb3ZlIGNvbG9ycyBmaXJzdCxcbiAgLy8gb3RoZXJ3aXNlIHRoZSBsZW5ndGggd291bGQgbm90IGJlIGNhbGN1bGF0ZWQgcHJvcGVybHkuXG5cbiAgZm9yICg7IGkgPCBvdXRwdXRMZW5ndGg7IGkrKykge1xuICAgIHZhciBsZW4gPSBjdHguY29sb3JzID8gcmVtb3ZlQ29sb3JzKG91dHB1dFtpXSkubGVuZ3RoIDogb3V0cHV0W2ldLmxlbmd0aDtcbiAgICBkYXRhTGVuW2ldID0gbGVuO1xuICAgIHRvdGFsTGVuZ3RoICs9IGxlbiArIHNlcGFyYXRvclNwYWNlO1xuXG4gICAgaWYgKG1heExlbmd0aCA8IGxlbikge1xuICAgICAgbWF4TGVuZ3RoID0gbGVuO1xuICAgIH1cbiAgfSAvLyBBZGQgdHdvIHRvIGBtYXhMZW5ndGhgIGFzIHdlIGFkZCBhIHNpbmdsZSB3aGl0ZXNwYWNlIGNoYXJhY3RlciBwbHVzIGEgY29tbWFcbiAgLy8gaW4tYmV0d2VlbiB0d28gZW50cmllcy5cblxuXG4gIHZhciBhY3R1YWxNYXggPSBtYXhMZW5ndGggKyBzZXBhcmF0b3JTcGFjZTsgLy8gQ2hlY2sgaWYgYXQgbGVhc3QgdGhyZWUgZW50cmllcyBmaXQgbmV4dCB0byBlYWNoIG90aGVyIGFuZCBwcmV2ZW50IGdyb3VwaW5nXG4gIC8vIG9mIGFycmF5cyB0aGF0IGNvbnRhaW5zIGVudHJpZXMgb2YgdmVyeSBkaWZmZXJlbnQgbGVuZ3RoIChpLmUuLCBpZiBhIHNpbmdsZVxuICAvLyBlbnRyeSBpcyBsb25nZXIgdGhhbiAxLzUgb2YgYWxsIG90aGVyIGVudHJpZXMgY29tYmluZWQpLiBPdGhlcndpc2UgdGhlXG4gIC8vIHNwYWNlIGluLWJldHdlZW4gc21hbGwgZW50cmllcyB3b3VsZCBiZSBlbm9ybW91cy5cblxuICBpZiAoYWN0dWFsTWF4ICogMyArIGN0eC5pbmRlbnRhdGlvbkx2bCA8IGN0eC5icmVha0xlbmd0aCAmJiAodG90YWxMZW5ndGggLyBhY3R1YWxNYXggPiA1IHx8IG1heExlbmd0aCA8PSA2KSkge1xuICAgIHZhciBhcHByb3hDaGFySGVpZ2h0cyA9IDIuNTtcbiAgICB2YXIgYXZlcmFnZUJpYXMgPSBNYXRoLnNxcnQoYWN0dWFsTWF4IC0gdG90YWxMZW5ndGggLyBvdXRwdXQubGVuZ3RoKTtcbiAgICB2YXIgYmlhc2VkTWF4ID0gTWF0aC5tYXgoYWN0dWFsTWF4IC0gMyAtIGF2ZXJhZ2VCaWFzLCAxKTsgLy8gRHluYW1pY2FsbHkgY2hlY2sgaG93IG1hbnkgY29sdW1ucyBzZWVtIHBvc3NpYmxlLlxuXG4gICAgdmFyIGNvbHVtbnMgPSBNYXRoLm1pbiggLy8gSWRlYWxseSBhIHNxdWFyZSBzaG91bGQgYmUgZHJhd24uIFdlIGV4cGVjdCBhIGNoYXJhY3RlciB0byBiZSBhYm91dCAyLjVcbiAgICAvLyB0aW1lcyBhcyBoaWdoIGFzIHdpZGUuIFRoaXMgaXMgdGhlIGFyZWEgZm9ybXVsYSB0byBjYWxjdWxhdGUgYSBzcXVhcmVcbiAgICAvLyB3aGljaCBjb250YWlucyBuIHJlY3RhbmdsZXMgb2Ygc2l6ZSBgYWN0dWFsTWF4ICogYXBwcm94Q2hhckhlaWdodHNgLlxuICAgIC8vIERpdmlkZSB0aGF0IGJ5IGBhY3R1YWxNYXhgIHRvIHJlY2VpdmUgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGNvbHVtbnMuXG4gICAgLy8gVGhlIGFkZGVkIGJpYXMgaW5jcmVhc2VzIHRoZSBjb2x1bW5zIGZvciBzaG9ydCBlbnRyaWVzLlxuICAgIE1hdGgucm91bmQoTWF0aC5zcXJ0KGFwcHJveENoYXJIZWlnaHRzICogYmlhc2VkTWF4ICogb3V0cHV0TGVuZ3RoKSAvIGJpYXNlZE1heCksIC8vIERvIG5vdCBleGNlZWQgdGhlIGJyZWFrTGVuZ3RoLlxuICAgIE1hdGguZmxvb3IoKGN0eC5icmVha0xlbmd0aCAtIGN0eC5pbmRlbnRhdGlvbkx2bCkgLyBhY3R1YWxNYXgpLCAvLyBMaW1pdCBhcnJheSBncm91cGluZyBmb3Igc21hbGwgYGNvbXBhY3RgIG1vZGVzIGFzIHRoZSB1c2VyIHJlcXVlc3RlZFxuICAgIC8vIG1pbmltYWwgZ3JvdXBpbmcuXG4gICAgY3R4LmNvbXBhY3QgKiA0LCAvLyBMaW1pdCB0aGUgY29sdW1ucyB0byBhIG1heGltdW0gb2YgZmlmdGVlbi5cbiAgICAxNSk7IC8vIFJldHVybiB3aXRoIHRoZSBvcmlnaW5hbCBvdXRwdXQgaWYgbm8gZ3JvdXBpbmcgc2hvdWxkIGhhcHBlbi5cblxuICAgIGlmIChjb2x1bW5zIDw9IDEpIHtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgdmFyIHRtcCA9IFtdO1xuICAgIHZhciBtYXhMaW5lTGVuZ3RoID0gW107XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY29sdW1uczsgX2krKykge1xuICAgICAgdmFyIGxpbmVNYXhMZW5ndGggPSAwO1xuXG4gICAgICBmb3IgKHZhciBqID0gX2k7IGogPCBvdXRwdXQubGVuZ3RoOyBqICs9IGNvbHVtbnMpIHtcbiAgICAgICAgaWYgKGRhdGFMZW5bal0gPiBsaW5lTWF4TGVuZ3RoKSB7XG4gICAgICAgICAgbGluZU1heExlbmd0aCA9IGRhdGFMZW5bal07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGluZU1heExlbmd0aCArPSBzZXBhcmF0b3JTcGFjZTtcbiAgICAgIG1heExpbmVMZW5ndGhbX2ldID0gbGluZU1heExlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgb3JkZXIgPSAncGFkU3RhcnQnO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG91dHB1dC5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVbX2kyXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvcmRlciA9ICdwYWRFbmQnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBFYWNoIGl0ZXJhdGlvbiBjcmVhdGVzIGEgc2luZ2xlIGxpbmUgb2YgZ3JvdXBlZCBlbnRyaWVzLlxuXG5cbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBvdXRwdXRMZW5ndGg7IF9pMyArPSBjb2x1bW5zKSB7XG4gICAgICAvLyBUaGUgbGFzdCBsaW5lcyBtYXkgY29udGFpbiBsZXNzIGVudHJpZXMgdGhhbiBjb2x1bW5zLlxuICAgICAgdmFyIG1heCA9IE1hdGgubWluKF9pMyArIGNvbHVtbnMsIG91dHB1dExlbmd0aCk7XG4gICAgICB2YXIgc3RyID0gJyc7XG4gICAgICB2YXIgX2ogPSBfaTM7XG5cbiAgICAgIGZvciAoOyBfaiA8IG1heCAtIDE7IF9qKyspIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGV4dHJhIGNvbG9yIHBhZGRpbmcgaW4gY2FzZSBpdCdzIGFjdGl2ZS4gVGhpcyBoYXMgdG8gYmVcbiAgICAgICAgLy8gZG9uZSBsaW5lIGJ5IGxpbmUgYXMgc29tZSBsaW5lcyBtaWdodCBjb250YWluIG1vcmUgY29sb3JzIHRoYW5cbiAgICAgICAgLy8gb3RoZXJzLlxuICAgICAgICB2YXIgcGFkZGluZyA9IG1heExpbmVMZW5ndGhbX2ogLSBfaTNdICsgb3V0cHV0W19qXS5sZW5ndGggLSBkYXRhTGVuW19qXTtcbiAgICAgICAgc3RyICs9IFwiXCIuY29uY2F0KG91dHB1dFtfal0sIFwiLCBcIilbb3JkZXJdKHBhZGRpbmcsICcgJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcmRlciA9PT0gJ3BhZFN0YXJ0Jykge1xuICAgICAgICB2YXIgX3BhZGRpbmcgPSBtYXhMaW5lTGVuZ3RoW19qIC0gX2kzXSArIG91dHB1dFtfal0ubGVuZ3RoIC0gZGF0YUxlbltfal0gLSBzZXBhcmF0b3JTcGFjZTtcblxuICAgICAgICBzdHIgKz0gb3V0cHV0W19qXS5wYWRTdGFydChfcGFkZGluZywgJyAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciArPSBvdXRwdXRbX2pdO1xuICAgICAgfVxuXG4gICAgICB0bXAucHVzaChzdHIpO1xuICAgIH1cblxuICAgIGlmIChjdHgubWF4QXJyYXlMZW5ndGggPCBvdXRwdXQubGVuZ3RoKSB7XG4gICAgICB0bXAucHVzaChvdXRwdXRbb3V0cHV0TGVuZ3RoXSk7XG4gICAgfVxuXG4gICAgb3V0cHV0ID0gdG1wO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTWF4Q2FsbFN0YWNrU2l6ZShjdHgsIGVyciwgY29uc3RydWN0b3JOYW1lLCBpbmRlbnRhdGlvbkx2bCkge1xuICBpZiAoaXNTdGFja092ZXJmbG93RXJyb3IoZXJyKSkge1xuICAgIGN0eC5zZWVuLnBvcCgpO1xuICAgIGN0eC5pbmRlbnRhdGlvbkx2bCA9IGluZGVudGF0aW9uTHZsO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShcIltcIi5jb25jYXQoY29uc3RydWN0b3JOYW1lLCBcIjogSW5zcGVjdGlvbiBpbnRlcnJ1cHRlZCAncHJlbWF0dXJlbHkuIE1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkLl1cIiksICdzcGVjaWFsJyk7XG4gIH1cblxuICB0aHJvdyBlcnI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihmbiwgdmFsdWUpIHtcbiAgLy8gRm9ybWF0IC0wIGFzICctMCcuIENoZWNraW5nIGB2YWx1ZSA9PT0gLTBgIHdvbid0IGRpc3Rpbmd1aXNoIDAgZnJvbSAtMC5cbiAgcmV0dXJuIGZuKE9iamVjdC5pcyh2YWx1ZSwgLTApID8gJy0wJyA6IFwiXCIuY29uY2F0KHZhbHVlKSwgJ251bWJlcicpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRCaWdJbnQoZm4sIHZhbHVlKSB7XG4gIHJldHVybiBmbihcIlwiLmNvbmNhdCh2YWx1ZSwgXCJuXCIpLCAnYmlnaW50Jyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShmbiwgdmFsdWUsIGN0eCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChjdHguY29tcGFjdCAhPT0gdHJ1ZSAmJiB2YWx1ZS5sZW5ndGggPiBrTWluTGluZUxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggPiBjdHguYnJlYWtMZW5ndGggLSBjdHguaW5kZW50YXRpb25MdmwgLSA0KSB7XG4gICAgICByZXR1cm4gdmFsdWUuc3BsaXQoL1xcbi8pLm1hcChsaW5lID0+IGZuKHN0ckVzY2FwZShsaW5lKSwgJ3N0cmluZycpKS5qb2luKFwiICtcXG5cIi5jb25jYXQoJyAnLnJlcGVhdChjdHguaW5kZW50YXRpb25MdmwgKyAyKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBmbihzdHJFc2NhcGUodmFsdWUpLCAnc3RyaW5nJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIoZm4sIHZhbHVlKTtcbiAgfVxuICAvKlxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICBcdHJldHVybiBmb3JtYXRCaWdJbnQoZm4sIHZhbHVlKTtcbiAgfVxuICAqL1xuXG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIGZuKFwiXCIuY29uY2F0KHZhbHVlKSwgJ2Jvb2xlYW4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZuKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIH0gLy8gZXM2IHN5bWJvbCBwcmltaXRpdmVcblxuXG4gIHJldHVybiBmbihTeW1ib2xQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdzeW1ib2wnKTtcbn0gLy8gVGhlIGFycmF5IGlzIHNwYXJzZSBhbmQvb3IgaGFzIGV4dHJhIGtleXNcblxuXG5mdW5jdGlvbiBmb3JtYXRTcGVjaWFsQXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBtYXhMZW5ndGgsIG91dHB1dCwgaSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIGluZGV4ID0gaTtcblxuICBmb3IgKDsgaSA8IGtleXMubGVuZ3RoICYmIG91dHB1dC5sZW5ndGggPCBtYXhMZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIHZhciB0bXAgPSAra2V5OyAvLyBBcnJheXMgY2FuIG9ubHkgaGF2ZSB1cCB0byAyXjMyIC0gMSBlbnRyaWVzXG5cbiAgICBpZiAodG1wID4gTWF0aC5wb3coMiwgMzIpIC0gMikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKFwiXCIuY29uY2F0KGluZGV4KSAhPT0ga2V5KSB7XG4gICAgICBpZiAoIW51bWJlclJlZ0V4cC50ZXN0KGtleSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbXB0eUl0ZW1zID0gdG1wIC0gaW5kZXg7XG4gICAgICB2YXIgZW5kaW5nID0gZW1wdHlJdGVtcyA+IDEgPyAncycgOiAnJztcbiAgICAgIHZhciBtZXNzYWdlID0gXCI8XCIuY29uY2F0KGVtcHR5SXRlbXMsIFwiIGVtcHR5IGl0ZW1cIikuY29uY2F0KGVuZGluZywgXCI+XCIpO1xuICAgICAgb3V0cHV0LnB1c2goY3R4LnN0eWxpemUobWVzc2FnZSwgJ3VuZGVmaW5lZCcpKTtcbiAgICAgIGluZGV4ID0gdG1wO1xuXG4gICAgICBpZiAob3V0cHV0Lmxlbmd0aCA9PT0gbWF4TGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywga2V5LCBrQXJyYXlUeXBlKSk7XG4gICAgaW5kZXgrKztcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB2YWx1ZS5sZW5ndGggLSBpbmRleDtcblxuICBpZiAob3V0cHV0Lmxlbmd0aCAhPT0gbWF4TGVuZ3RoKSB7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIHZhciBfZW5kaW5nID0gcmVtYWluaW5nID4gMSA/ICdzJyA6ICcnO1xuXG4gICAgICB2YXIgX21lc3NhZ2UgPSBcIjxcIi5jb25jYXQocmVtYWluaW5nLCBcIiBlbXB0eSBpdGVtXCIpLmNvbmNhdChfZW5kaW5nLCBcIj5cIik7XG5cbiAgICAgIG91dHB1dC5wdXNoKGN0eC5zdHlsaXplKF9tZXNzYWdlLCAndW5kZWZpbmVkJykpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgb3V0cHV0LnB1c2goXCIuLi4gXCIuY29uY2F0KHJlbWFpbmluZywgXCIgbW9yZSBpdGVtXCIpLmNvbmNhdChyZW1haW5pbmcgPiAxID8gJ3MnIDogJycpKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5QnVmZmVyKGN0eCwgdmFsdWUpIHtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgLypcbiAgLy8gQGZpeG1lIHJvbGx1cCBjYW5ub3QgaGFuZGxlIGxhenkgbG9hZGVkIG1vZHVsZXMsIG1heWJlIG1vdmUgdG8gd2VicGFjaz9cbiAgaWYgKGhleFNsaWNlID09PSB1bmRlZmluZWQpIHtcbiAgXHRoZXhTbGljZSA9IHVuY3VycnlUaGlzKHJlcXVpcmUoJy4uLy4uL2J1ZmZlcicpLmRlZmF1bHQuQnVmZmVyLnByb3RvdHlwZS5oZXhTbGljZSk7XG4gIH1cbiAgKi9cblxuICB2YXIgc3RyID0gaGV4U2xpY2UoYnVmZmVyLCAwLCBNYXRoLm1pbihjdHgubWF4QXJyYXlMZW5ndGgsIGJ1ZmZlci5sZW5ndGgpKS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKTtcbiAgdmFyIHJlbWFpbmluZyA9IGJ1ZmZlci5sZW5ndGggLSBjdHgubWF4QXJyYXlMZW5ndGg7XG5cbiAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBzdHIgKz0gXCIgLi4uIFwiLmNvbmNhdChyZW1haW5pbmcsIFwiIG1vcmUgYnl0ZVwiKS5jb25jYXQocmVtYWluaW5nID4gMSA/ICdzJyA6ICcnKTtcbiAgfVxuXG4gIHJldHVybiBbXCJcIi5jb25jYXQoY3R4LnN0eWxpemUoJ1tVaW50OENvbnRlbnRzXScsICdzcGVjaWFsJyksIFwiOiA8XCIpLmNvbmNhdChzdHIsIFwiPlwiKV07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICB2YXIgdmFsTGVuID0gdmFsdWUubGVuZ3RoO1xuICB2YXIgbGVuID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgY3R4Lm1heEFycmF5TGVuZ3RoKSwgdmFsTGVuKTtcbiAgdmFyIHJlbWFpbmluZyA9IHZhbExlbiAtIGxlbjtcbiAgdmFyIG91dHB1dCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyBTcGVjaWFsIGhhbmRsZSBzcGFyc2UgYXJyYXlzLlxuICAgIGlmICghaGFzT3duUHJvcGVydHkkMSh2YWx1ZSwgaSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRTcGVjaWFsQXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBsZW4sIG91dHB1dCwgaSk7XG4gICAgfVxuXG4gICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBpLCBrQXJyYXlUeXBlKSk7XG4gIH1cblxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIG91dHB1dC5wdXNoKFwiLi4uIFwiLmNvbmNhdChyZW1haW5pbmcsIFwiIG1vcmUgaXRlbVwiKS5jb25jYXQocmVtYWluaW5nID4gMSA/ICdzJyA6ICcnKSk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUeXBlZEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICB2YXIgbWF4TGVuZ3RoID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgY3R4Lm1heEFycmF5TGVuZ3RoKSwgdmFsdWUubGVuZ3RoKTtcbiAgdmFyIHJlbWFpbmluZyA9IHZhbHVlLmxlbmd0aCAtIG1heExlbmd0aDtcbiAgdmFyIG91dHB1dCA9IG5ldyBBcnJheShtYXhMZW5ndGgpO1xuICB2YXIgZWxlbWVudEZvcm1hdHRlciA9IHZhbHVlLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHZhbHVlWzBdID09PSAnbnVtYmVyJyA/IGZvcm1hdE51bWJlciA6IGZvcm1hdEJpZ0ludDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1heExlbmd0aDsgKytpKSB7XG4gICAgb3V0cHV0W2ldID0gZWxlbWVudEZvcm1hdHRlcihjdHguc3R5bGl6ZSwgdmFsdWVbaV0pO1xuICB9XG5cbiAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBvdXRwdXRbbWF4TGVuZ3RoXSA9IFwiLi4uIFwiLmNvbmNhdChyZW1haW5pbmcsIFwiIG1vcmUgaXRlbVwiKS5jb25jYXQocmVtYWluaW5nID4gMSA/ICdzJyA6ICcnKTtcbiAgfVxuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIC8vIC5idWZmZXIgZ29lcyBsYXN0LCBpdCdzIG5vdCBhIHByaW1pdGl2ZSBsaWtlIHRoZSBvdGhlcnMuXG4gICAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG5cbiAgICBmb3IgKHZhciBrZXkgb2YgWydCWVRFU19QRVJfRUxFTUVOVCcsICdsZW5ndGgnLCAnYnl0ZUxlbmd0aCcsICdieXRlT2Zmc2V0JywgJ2J1ZmZlciddKSB7XG4gICAgICB2YXIgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZVtrZXldLCByZWN1cnNlVGltZXMsIHRydWUpO1xuICAgICAgb3V0cHV0LnB1c2goXCJbXCIuY29uY2F0KGtleSwgXCJdOiBcIikuY29uY2F0KHN0cikpO1xuICAgIH1cblxuICAgIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0U2V0KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGN0eC5pbmRlbnRhdGlvbkx2bCArPSAyO1xuXG4gIGZvciAodmFyIHYgb2YgdmFsdWUpIHtcbiAgICBvdXRwdXQucHVzaChmb3JtYXRWYWx1ZShjdHgsIHYsIHJlY3Vyc2VUaW1lcykpO1xuICB9XG5cbiAgY3R4LmluZGVudGF0aW9uTHZsIC09IDI7IC8vIFdpdGggYHNob3dIaWRkZW5gLCBgbGVuZ3RoYCB3aWxsIGRpc3BsYXkgYXMgYSBoaWRkZW4gcHJvcGVydHkgZm9yXG4gIC8vIGFycmF5cy4gRm9yIGNvbnNpc3RlbmN5J3Mgc2FrZSwgZG8gdGhlIHNhbWUgZm9yIGBzaXplYCwgZXZlbiB0aG91Z2ggdGhpc1xuICAvLyBwcm9wZXJ0eSBpc24ndCBzZWxlY3RlZCBieSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygpLlxuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIG91dHB1dC5wdXNoKFwiW3NpemVdOiBcIi5jb25jYXQoY3R4LnN0eWxpemUoXCJcIi5jb25jYXQodmFsdWUuc2l6ZSksICdudW1iZXInKSkpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TWFwKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGN0eC5pbmRlbnRhdGlvbkx2bCArPSAyO1xuXG4gIGZvciAodmFyIFtrLCB2XSBvZiB2YWx1ZSkge1xuICAgIG91dHB1dC5wdXNoKFwiXCIuY29uY2F0KGZvcm1hdFZhbHVlKGN0eCwgaywgcmVjdXJzZVRpbWVzKSwgXCIgPT4gXCIpLmNvbmNhdChmb3JtYXRWYWx1ZShjdHgsIHYsIHJlY3Vyc2VUaW1lcykpKTtcbiAgfVxuXG4gIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyOyAvLyBTZWUgY29tbWVudCBpbiBmb3JtYXRTZXRcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBvdXRwdXQucHVzaChcIltzaXplXTogXCIuY29uY2F0KGN0eC5zdHlsaXplKFwiXCIuY29uY2F0KHZhbHVlLnNpemUpLCAnbnVtYmVyJykpKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFNldEl0ZXJJbm5lcihjdHgsIHJlY3Vyc2VUaW1lcywgZW50cmllcywgc3RhdGUpIHtcbiAgdmFyIG1heEFycmF5TGVuZ3RoID0gTWF0aC5tYXgoY3R4Lm1heEFycmF5TGVuZ3RoLCAwKTtcbiAgdmFyIG1heExlbmd0aCA9IE1hdGgubWluKG1heEFycmF5TGVuZ3RoLCBlbnRyaWVzLmxlbmd0aCk7XG4gIHZhciBvdXRwdXQgPSBuZXcgQXJyYXkobWF4TGVuZ3RoKTtcbiAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhMZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFtpXSA9IGZvcm1hdFZhbHVlKGN0eCwgZW50cmllc1tpXSwgcmVjdXJzZVRpbWVzKTtcbiAgfVxuXG4gIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyO1xuXG4gIGlmIChzdGF0ZSA9PT0ga1dlYWsgJiYgIWN0eC5zb3J0ZWQpIHtcbiAgICAvLyBTb3J0IGFsbCBlbnRyaWVzIHRvIGhhdmUgYSBoYWxmd2F5IHJlbGlhYmxlIG91dHB1dCAoaWYgbW9yZSBlbnRyaWVzIHRoYW5cbiAgICAvLyByZXRyaWV2ZWQgb25lcyBleGlzdCwgd2UgY2FuIG5vdCByZWxpYWJseSByZXR1cm4gdGhlIHNhbWUgb3V0cHV0KSBpZiB0aGVcbiAgICAvLyBvdXRwdXQgaXMgbm90IHNvcnRlZCBhbnl3YXkuXG4gICAgb3V0cHV0ID0gb3V0cHV0LnNvcnQoKTtcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSBlbnRyaWVzLmxlbmd0aCAtIG1heExlbmd0aDtcblxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIG91dHB1dC5wdXNoKFwiLi4uIFwiLmNvbmNhdChyZW1haW5pbmcsIFwiIG1vcmUgaXRlbVwiKS5jb25jYXQocmVtYWluaW5nID4gMSA/ICdzJyA6ICcnKSk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNYXBJdGVySW5uZXIoY3R4LCByZWN1cnNlVGltZXMsIGVudHJpZXMsIHN0YXRlKSB7XG4gIHZhciBtYXhBcnJheUxlbmd0aCA9IE1hdGgubWF4KGN0eC5tYXhBcnJheUxlbmd0aCwgMCk7IC8vIEVudHJpZXMgZXhpc3QgYXMgW2tleTEsIHZhbDEsIGtleTIsIHZhbDIsIC4uLl1cblxuICB2YXIgbGVuID0gZW50cmllcy5sZW5ndGggLyAyO1xuICB2YXIgcmVtYWluaW5nID0gbGVuIC0gbWF4QXJyYXlMZW5ndGg7XG4gIHZhciBtYXhMZW5ndGggPSBNYXRoLm1pbihtYXhBcnJheUxlbmd0aCwgbGVuKTtcbiAgdmFyIG91dHB1dCA9IG5ldyBBcnJheShtYXhMZW5ndGgpO1xuICB2YXIgaSA9IDA7XG4gIGN0eC5pbmRlbnRhdGlvbkx2bCArPSAyO1xuXG4gIGlmIChzdGF0ZSA9PT0ga1dlYWspIHtcbiAgICBmb3IgKDsgaSA8IG1heExlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcG9zID0gaSAqIDI7XG4gICAgICBvdXRwdXRbaV0gPSBcIlwiLmNvbmNhdChmb3JtYXRWYWx1ZShjdHgsIGVudHJpZXNbcG9zXSwgcmVjdXJzZVRpbWVzKSkgKyBcIiA9PiBcIi5jb25jYXQoZm9ybWF0VmFsdWUoY3R4LCBlbnRyaWVzW3BvcyArIDFdLCByZWN1cnNlVGltZXMpKTtcbiAgICB9IC8vIFNvcnQgYWxsIGVudHJpZXMgdG8gaGF2ZSBhIGhhbGZ3YXkgcmVsaWFibGUgb3V0cHV0IChpZiBtb3JlIGVudHJpZXMgdGhhblxuICAgIC8vIHJldHJpZXZlZCBvbmVzIGV4aXN0LCB3ZSBjYW4gbm90IHJlbGlhYmx5IHJldHVybiB0aGUgc2FtZSBvdXRwdXQpIGlmIHRoZVxuICAgIC8vIG91dHB1dCBpcyBub3Qgc29ydGVkIGFueXdheS5cblxuXG4gICAgaWYgKCFjdHguc29ydGVkKSB7XG4gICAgICBvdXRwdXQgPSBvdXRwdXQuc29ydCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKDsgaSA8IG1heExlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX3BvczIgPSBpICogMjtcblxuICAgICAgdmFyIHJlcyA9IFtmb3JtYXRWYWx1ZShjdHgsIGVudHJpZXNbX3BvczJdLCByZWN1cnNlVGltZXMpLCBmb3JtYXRWYWx1ZShjdHgsIGVudHJpZXNbX3BvczIgKyAxXSwgcmVjdXJzZVRpbWVzKV07XG4gICAgICBvdXRwdXRbaV0gPSByZWR1Y2VUb1NpbmdsZVN0cmluZyhjdHgsIHJlcywgJycsIFsnWycsICddJ10sIGtBcnJheUV4dHJhc1R5cGUsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LmluZGVudGF0aW9uTHZsIC09IDI7XG5cbiAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBvdXRwdXQucHVzaChcIi4uLiBcIi5jb25jYXQocmVtYWluaW5nLCBcIiBtb3JlIGl0ZW1cIikuY29uY2F0KHJlbWFpbmluZyA+IDEgPyAncycgOiAnJykpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vha0NvbGxlY3Rpb24oY3R4KSB7XG4gIHJldHVybiBbY3R4LnN0eWxpemUoJzxpdGVtcyB1bmtub3duPicsICdzcGVjaWFsJyldO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWFrU2V0KGN0eCwgX3ZhbHVlLCBfcmVjdXJzZVRpbWVzKSB7XG4gIC8vIE5vZGUgY2FsbHMgaW50byBuYXRpdmUgdG8gZ2V0IGEgcHJldmlldyBvZiBhY3R1YWwgdmFsdWVzIHdoaWNoIHdlIGNhbid0IGRvXG4gIHJldHVybiBmb3JtYXRXZWFrQ29sbGVjdGlvbihjdHgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWFrTWFwKGN0eCwgX3ZhbHVlLCBfcmVjdXJzZVRpbWVzKSB7XG4gIC8vIE5vZGUgY2FsbHMgaW50byBuYXRpdmUgdG8gZ2V0IGEgcHJldmlldyBvZiBhY3R1YWwgdmFsdWVzIHdoaWNoIHdlIGNhbid0IGRvXG4gIHJldHVybiBmb3JtYXRXZWFrQ29sbGVjdGlvbihjdHgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRJdGVyYXRvcihjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIF9rZXlzLCBicmFjZXMpIHtcbiAgdmFyIGVudHJpZXMgPSBbXTtcbiAgdmFyIGlzS2V5VmFsdWUgPSBmYWxzZTtcbiAgdmFyIHJlc3VsdCA9IHZhbHVlLm5leHQoKTtcblxuICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgdmFyIGN1cnJlbnRFbnRyeSA9IHJlc3VsdC52YWx1ZTtcbiAgICBlbnRyaWVzLnB1c2goY3VycmVudEVudHJ5KTtcblxuICAgIGlmIChjdXJyZW50RW50cnlbMF0gIT09IGN1cnJlbnRFbnRyeVsxXSkge1xuICAgICAgaXNLZXlWYWx1ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gdmFsdWUubmV4dCgpO1xuICB9XG5cbiAgaWYgKGlzS2V5VmFsdWUpIHtcbiAgICAvLyBNYXJrIGVudHJ5IGl0ZXJhdG9ycyBhcyBzdWNoLlxuICAgIGJyYWNlc1swXSA9IGJyYWNlc1swXS5yZXBsYWNlKC8gSXRlcmF0b3JdIHskLywgJyBFbnRyaWVzXSB7Jyk7XG4gICAgcmV0dXJuIGZvcm1hdE1hcEl0ZXJJbm5lcihjdHgsIHJlY3Vyc2VUaW1lcywgZW50cmllcywga01hcEVudHJpZXMpO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdFNldEl0ZXJJbm5lcihjdHgsIHJlY3Vyc2VUaW1lcywgZW50cmllcywga0l0ZXJhdG9yKTtcbn1cblxuZnVuY3Rpb24gaXNCZWxvd0JyZWFrTGVuZ3RoKGN0eCwgb3V0cHV0LCBzdGFydCwgYmFzZSkge1xuICAvLyBFYWNoIGVudHJ5IGlzIHNlcGFyYXRlZCBieSBhdCBsZWFzdCBhIGNvbW1hLiBUaHVzLCB3ZSBzdGFydCB3aXRoIGEgdG90YWxcbiAgLy8gbGVuZ3RoIG9mIGF0IGxlYXN0IGBvdXRwdXQubGVuZ3RoYC4gSW4gYWRkaXRpb24sIHNvbWUgY2FzZXMgaGF2ZSBhXG4gIC8vIHdoaXRlc3BhY2UgaW4tYmV0d2VlbiBlYWNoIG90aGVyIHRoYXQgaXMgYWRkZWQgdG8gdGhlIHRvdGFsIGFzIHdlbGwuXG4gIHZhciB0b3RhbExlbmd0aCA9IG91dHB1dC5sZW5ndGggKyBzdGFydDtcblxuICBpZiAodG90YWxMZW5ndGggKyBvdXRwdXQubGVuZ3RoID4gY3R4LmJyZWFrTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY3R4LmNvbG9ycykge1xuICAgICAgdG90YWxMZW5ndGggKz0gcmVtb3ZlQ29sb3JzKG91dHB1dFtpXSkubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBvdXRwdXRbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICh0b3RhbExlbmd0aCA+IGN0eC5icmVha0xlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSAvLyBEbyBub3QgbGluZSB1cCBwcm9wZXJ0aWVzIG9uIHRoZSBzYW1lIGxpbmUgaWYgYGJhc2VgIGNvbnRhaW5zIGxpbmUgYnJlYWtzLlxuXG5cbiAgcmV0dXJuIGJhc2UgPT09ICcnIHx8ICFiYXNlLmluY2x1ZGVzKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcoY3R4LCBvdXRwdXQsIGJhc2UsIGJyYWNlcywgZXh0cmFzVHlwZSwgcmVjdXJzZVRpbWVzLCB2YWx1ZSkge1xuICBpZiAoY3R4LmNvbXBhY3QgIT09IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIGN0eC5jb21wYWN0ID09PSAnbnVtYmVyJyAmJiBjdHguY29tcGFjdCA+PSAxKSB7XG4gICAgICAvLyBNZW1vcml6ZSB0aGUgb3JpZ2luYWwgb3V0cHV0IGxlbmd0aC4gSW4gY2FzZSB0aGUgdGhlIG91dHB1dCBpcyBncm91cGVkLFxuICAgICAgLy8gcHJldmVudCBsaW5pbmcgdXAgdGhlIGVudHJpZXMgb24gYSBzaW5nbGUgbGluZS5cbiAgICAgIHZhciBlbnRyaWVzID0gb3V0cHV0Lmxlbmd0aDsgLy8gR3JvdXAgYXJyYXkgZWxlbWVudHMgdG9nZXRoZXIgaWYgdGhlIGFycmF5IGNvbnRhaW5zIGF0IGxlYXN0IHNpeFxuICAgICAgLy8gc2VwYXJhdGUgZW50cmllcy5cblxuICAgICAgaWYgKGV4dHJhc1R5cGUgPT09IGtBcnJheUV4dHJhc1R5cGUgJiYgZW50cmllcyA+IDYpIHtcbiAgICAgICAgb3V0cHV0ID0gZ3JvdXBBcnJheUVsZW1lbnRzKGN0eCwgb3V0cHV0LCB2YWx1ZSk7XG4gICAgICB9IC8vIGBjdHguY3VycmVudERlcHRoYCBpcyBzZXQgdG8gdGhlIG1vc3QgaW5uZXIgZGVwdGggb2YgdGhlIGN1cnJlbnRseVxuICAgICAgLy8gaW5zcGVjdGVkIG9iamVjdCBwYXJ0IHdoaWxlIGByZWN1cnNlVGltZXNgIGlzIHRoZSBhY3R1YWwgY3VycmVudCBkZXB0aFxuICAgICAgLy8gdGhhdCBpcyBpbnNwZWN0ZWQuXG4gICAgICAvL1xuICAgICAgLy8gRXhhbXBsZTpcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdCBhID0geyBmaXJzdDogWyAxLCAyLCAzIF0sIHNlY29uZDogeyBpbm5lcjogWyAxLCAyLCAzIF0gfSB9XG4gICAgICAvL1xuICAgICAgLy8gVGhlIGRlZXBlc3QgZGVwdGggb2YgYGFgIGlzIDIgKGEuc2Vjb25kLmlubmVyKSBhbmQgYGEuZmlyc3RgIGhhcyBhIG1heFxuICAgICAgLy8gZGVwdGggb2YgMS5cbiAgICAgIC8vXG4gICAgICAvLyBDb25zb2xpZGF0ZSBhbGwgZW50cmllcyBvZiB0aGUgbG9jYWwgbW9zdCBpbm5lciBkZXB0aCB1cCB0b1xuICAgICAgLy8gYGN0eC5jb21wYWN0YCwgYXMgbG9uZyBhcyB0aGUgcHJvcGVydGllcyBhcmUgc21hbGxlciB0aGFuXG4gICAgICAvLyBgY3R4LmJyZWFrTGVuZ3RoYC5cblxuXG4gICAgICBpZiAoY3R4LmN1cnJlbnREZXB0aCAtIHJlY3Vyc2VUaW1lcyA8IGN0eC5jb21wYWN0ICYmIGVudHJpZXMgPT09IG91dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgLy8gTGluZSB1cCBhbGwgZW50cmllcyBvbiBhIHNpbmdsZSBsaW5lIGluIGNhc2UgdGhlIGVudHJpZXMgZG8gbm90XG4gICAgICAgIC8vIGV4Y2VlZCBgYnJlYWtMZW5ndGhgLiBBZGQgMTAgYXMgY29uc3RhbnQgdG8gc3RhcnQgbmV4dCB0byBhbGwgb3RoZXJcbiAgICAgICAgLy8gZmFjdG9ycyB0aGF0IG1heSByZWR1Y2UgYGJyZWFrTGVuZ3RoYC5cbiAgICAgICAgdmFyIHN0YXJ0ID0gb3V0cHV0Lmxlbmd0aCArIGN0eC5pbmRlbnRhdGlvbkx2bCArIGJyYWNlc1swXS5sZW5ndGggKyBiYXNlLmxlbmd0aCArIDEwO1xuXG4gICAgICAgIGlmIChpc0JlbG93QnJlYWtMZW5ndGgoY3R4LCBvdXRwdXQsIHN0YXJ0LCBiYXNlKSkge1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChiYXNlID8gXCJcIi5jb25jYXQoYmFzZSwgXCIgXCIpIDogJycpLmNvbmNhdChicmFjZXNbMF0sIFwiIFwiKS5jb25jYXQoam9pbihvdXRwdXQsICcsICcpLCBcIiBcIikuY29uY2F0KGJyYWNlc1sxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIExpbmUgdXAgZWFjaCBlbnRyeSBvbiBhbiBpbmRpdmlkdWFsIGxpbmUuXG5cblxuICAgIHZhciBfaW5kZW50YXRpb24gPSBcIlxcblwiLmNvbmNhdCgnICcucmVwZWF0KGN0eC5pbmRlbnRhdGlvbkx2bCkpO1xuXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGJhc2UgPyBcIlwiLmNvbmNhdChiYXNlLCBcIiBcIikgOiAnJykuY29uY2F0KGJyYWNlc1swXSkuY29uY2F0KF9pbmRlbnRhdGlvbiwgXCIgIFwiKSArIFwiXCIuY29uY2F0KGpvaW4ob3V0cHV0LCBcIixcIi5jb25jYXQoX2luZGVudGF0aW9uLCBcIiAgXCIpKSkuY29uY2F0KF9pbmRlbnRhdGlvbikuY29uY2F0KGJyYWNlc1sxXSk7XG4gIH0gLy8gTGluZSB1cCBhbGwgZW50cmllcyBvbiBhIHNpbmdsZSBsaW5lIGluIGNhc2UgdGhlIGVudHJpZXMgZG8gbm90IGV4Y2VlZFxuICAvLyBgYnJlYWtMZW5ndGhgLlxuXG5cbiAgaWYgKGlzQmVsb3dCcmVha0xlbmd0aChjdHgsIG91dHB1dCwgMCwgYmFzZSkpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoYnJhY2VzWzBdKS5jb25jYXQoYmFzZSA/IFwiIFwiLmNvbmNhdChiYXNlKSA6ICcnLCBcIiBcIikuY29uY2F0KGpvaW4ob3V0cHV0LCAnLCAnKSwgXCIgXCIpICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgdmFyIGluZGVudGF0aW9uID0gJyAnLnJlcGVhdChjdHguaW5kZW50YXRpb25MdmwpOyAvLyBJZiB0aGUgb3BlbmluZyBcImJyYWNlXCIgaXMgdG9vIGxhcmdlLCBsaWtlIGluIHRoZSBjYXNlIG9mIFwiU2V0IHtcIixcbiAgLy8gd2UgbmVlZCB0byBmb3JjZSB0aGUgZmlyc3QgaXRlbSB0byBiZSBvbiB0aGUgbmV4dCBsaW5lIG9yIHRoZVxuICAvLyBpdGVtcyB3aWxsIG5vdCBsaW5lIHVwIGNvcnJlY3RseS5cblxuICB2YXIgbG4gPSBiYXNlID09PSAnJyAmJiBicmFjZXNbMF0ubGVuZ3RoID09PSAxID8gJyAnIDogXCJcIi5jb25jYXQoYmFzZSA/IFwiIFwiLmNvbmNhdChiYXNlKSA6ICcnLCBcIlxcblwiKS5jb25jYXQoaW5kZW50YXRpb24sIFwiICBcIik7IC8vIExpbmUgdXAgZWFjaCBlbnRyeSBvbiBhbiBpbmRpdmlkdWFsIGxpbmUuXG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KGJyYWNlc1swXSkuY29uY2F0KGxuKS5jb25jYXQoam9pbihvdXRwdXQsIFwiLFxcblwiLmNvbmNhdChpbmRlbnRhdGlvbiwgXCIgIFwiKSksIFwiIFwiKS5jb25jYXQoYnJhY2VzWzFdKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0KC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGZvcm1hdFdpdGhPcHRpb25zKHVuZGVmaW5lZCwgLi4uYXJncyk7XG59XG5cbnZhciBmaXJzdEVycm9yTGluZSA9IGVycm9yID0+IGVycm9yLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpWzBdO1xuXG52YXIgQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRTtcblxuZnVuY3Rpb24gdHJ5U3RyaW5naWZ5KGFyZykge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmcpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBQb3B1bGF0ZSB0aGUgY2lyY3VsYXIgZXJyb3IgbWVzc2FnZSBsYXppbHlcbiAgICBpZiAoIUNJUkNVTEFSX0VSUk9SX01FU1NBR0UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBhID0ge307XG4gICAgICAgIGEuYSA9IGE7XG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBDSVJDVUxBUl9FUlJPUl9NRVNTQUdFID0gZmlyc3RFcnJvckxpbmUoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVyci5uYW1lID09PSAnVHlwZUVycm9yJyAmJiBmaXJzdEVycm9yTGluZShlcnIpID09PSBDSVJDVUxBUl9FUlJPUl9NRVNTQUdFKSB7XG4gICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgIH1cblxuICAgIHRocm93IGVycjtcbiAgfVxufVxuLyogZXNsaW50LWRpc2FibGUgbWF4LWRlcHRoICovXG5cblxuZnVuY3Rpb24gZm9ybWF0V2l0aE9wdGlvbnMoaW5zcGVjdE9wdGlvbnMsIC4uLmFyZ3MpIHtcbiAgdmFyIGZpcnN0ID0gYXJnc1swXTtcbiAgdmFyIGEgPSAwO1xuICB2YXIgc3RyID0gJyc7XG4gIHZhciBqb2luID0gJyc7XG5cbiAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBmaXJzdDtcbiAgICB9XG5cbiAgICB2YXIgdGVtcFN0cjtcbiAgICB2YXIgbGFzdFBvcyA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgaWYgKGZpcnN0LmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICAgIC8vICclJ1xuICAgICAgICB2YXIgbmV4dENoYXIgPSBmaXJzdC5jaGFyQ29kZUF0KCsraSk7XG5cbiAgICAgICAgaWYgKGEgKyAxICE9PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIHN3aXRjaCAobmV4dENoYXIpIHtcbiAgICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgICAvLyAncydcbiAgICAgICAgICAgICAgdmFyIHRlbXBBcmcgPSBhcmdzWysrYV07XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wQXJnID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBmb3JtYXROdW1iZXIoc3R5bGl6ZU5vQ29sb3IsIHRlbXBBcmcpO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGVtcEFyZyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBcdHRlbXBTdHIgPSBgJHt0ZW1wQXJnfW5gO1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0ciA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcEFyZyAhPT0gJ29iamVjdCcgfHwgdGVtcEFyZyA9PT0gbnVsbCB8fCB0eXBlb2YgdGVtcEFyZy50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyAmJiAoaGFzT3duUHJvcGVydHkkMSh0ZW1wQXJnLCAndG9TdHJpbmcnKSAvLyBBIGRpcmVjdCBvd24gcHJvcGVydHkgb24gdGhlIGNvbnN0cnVjdG9yIHByb3RvdHlwZSBpblxuICAgICAgICAgICAgICAgIC8vIGNhc2UgdGhlIGNvbnN0cnVjdG9yIGlzIG5vdCBhbiBidWlsdC1pbiBvYmplY3QuXG4gICAgICAgICAgICAgICAgfHwgKGNvbnN0ciA9IHRlbXBBcmcuY29uc3RydWN0b3IpICYmICFidWlsdEluT2JqZWN0cy5oYXMoY29uc3RyLm5hbWUpICYmIGNvbnN0ci5wcm90b3R5cGUgJiYgaGFzT3duUHJvcGVydHkkMShjb25zdHIucHJvdG90eXBlLCAndG9TdHJpbmcnKSkpIHtcbiAgICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBTdHJpbmcodGVtcEFyZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBpbnNwZWN0KHRlbXBBcmcsIF9vYmplY3RTcHJlYWQyKHt9LCBpbnNwZWN0T3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBjb21wYWN0OiAzLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkZXB0aDogMFxuICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEwNjpcbiAgICAgICAgICAgICAgLy8gJ2onXG4gICAgICAgICAgICAgIHRlbXBTdHIgPSB0cnlTdHJpbmdpZnkoYXJnc1srK2FdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTAwOlxuICAgICAgICAgICAgICAvLyAnZCdcbiAgICAgICAgICAgICAgdmFyIHRlbXBOdW0gPSBhcmdzWysrYV07XG4gICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcE51bSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgXHR0ZW1wU3RyID0gYCR7dGVtcE51bX1uYDtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wTnVtID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSAnTmFOJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wU3RyID0gZm9ybWF0TnVtYmVyKHN0eWxpemVOb0NvbG9yLCBOdW1iZXIodGVtcE51bSkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNzk6XG4gICAgICAgICAgICAgIC8vICdPJ1xuICAgICAgICAgICAgICB0ZW1wU3RyID0gaW5zcGVjdChhcmdzWysrYV0sIGluc3BlY3RPcHRpb25zKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTExOlxuICAgICAgICAgICAgICAvLyAnbydcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBpbnNwZWN0KGFyZ3NbKythXSwgX29iamVjdFNwcmVhZDIoe30sIGluc3BlY3RPcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICBzaG93SGlkZGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgc2hvd1Byb3h5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZGVwdGg6IDRcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAxMDU6XG4gICAgICAgICAgICAgIC8vICdpJ1xuICAgICAgICAgICAgICB2YXIgdGVtcEludGVnZXIgPSBhcmdzWysrYV07XG4gICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcEludGVnZXIgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgIFx0dGVtcFN0ciA9IGAke3RlbXBJbnRlZ2VyfW5gO1xuICAgICAgICAgICAgICB9IGVsc2UgKi9cblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBJbnRlZ2VyID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSAnTmFOJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wU3RyID0gZm9ybWF0TnVtYmVyKHN0eWxpemVOb0NvbG9yLCBwYXJzZUludCh0ZW1wSW50ZWdlcikpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTAyOlxuICAgICAgICAgICAgICAvLyAnZidcbiAgICAgICAgICAgICAgdmFyIHRlbXBGbG9hdCA9IGFyZ3NbKythXTtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBGbG9hdCA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICB0ZW1wU3RyID0gJ05hTic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVtcFN0ciA9IGZvcm1hdE51bWJlcihzdHlsaXplTm9Db2xvciwgcGFyc2VGbG9hdCh0ZW1wRmxvYXQpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgICAgICAvLyAnJSdcbiAgICAgICAgICAgICAgc3RyICs9IGZpcnN0LnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICAgICAgICBsYXN0UG9zID0gaSArIDE7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBBbnkgb3RoZXIgY2hhcmFjdGVyIGlzIG5vdCBhIGNvcnJlY3QgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxhc3RQb3MgIT09IGkgLSAxKSB7XG4gICAgICAgICAgICBzdHIgKz0gZmlyc3Quc2xpY2UobGFzdFBvcywgaSAtIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0ciArPSB0ZW1wU3RyO1xuICAgICAgICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA9PT0gMzcpIHtcbiAgICAgICAgICBzdHIgKz0gZmlyc3Quc2xpY2UobGFzdFBvcywgaSk7XG4gICAgICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxhc3RQb3MgIT09IDApIHtcbiAgICAgIGErKztcbiAgICAgIGpvaW4gPSAnICc7XG5cbiAgICAgIGlmIChsYXN0UG9zIDwgZmlyc3QubGVuZ3RoKSB7XG4gICAgICAgIHN0ciArPSBmaXJzdC5zbGljZShsYXN0UG9zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3aGlsZSAoYSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJnc1thXTtcbiAgICBzdHIgKz0gam9pbjtcbiAgICBzdHIgKz0gdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyA/IGluc3BlY3QodmFsdWUsIGluc3BlY3RPcHRpb25zKSA6IHZhbHVlO1xuICAgIGpvaW4gPSAnICc7XG4gICAgYSsrO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoICovXG5cbnZhciBuYXRpdmVEZWJ1ZyA9IGNvbnNvbGUuZGVidWc7XG52YXIgbmF0aXZlRXJyb3IgPSBjb25zb2xlLmVycm9yO1xudmFyIG5hdGl2ZUluZm8gPSBjb25zb2xlLmluZm87XG52YXIgbmF0aXZlTG9nID0gY29uc29sZS5sb2c7XG52YXIgbmF0aXZlV2FybiA9IGNvbnNvbGUud2FybjtcbnZhciBrQ29sb3JJbnNwZWN0T3B0aW9ucyA9IHtcbiAgY29sb3JzOiB0cnVlXG59O1xudmFyIGtOb0NvbG9ySW5zcGVjdE9wdGlvbnMgPSB7fTtcblxuY29uc29sZS5kZWJ1ZyA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIG5hdGl2ZURlYnVnLmNhbGwoY29uc29sZSwgZm9ybWF0V2l0aE9wdGlvbnMoa0NvbG9ySW5zcGVjdE9wdGlvbnMsIC4uLmFyZ3MpKTtcbn07XG5cbmNvbnNvbGUuZXJyb3IgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICBuYXRpdmVFcnJvci5jYWxsKGNvbnNvbGUsIGZvcm1hdFdpdGhPcHRpb25zKGtOb0NvbG9ySW5zcGVjdE9wdGlvbnMsIC4uLmFyZ3MpKTtcbn07XG5cbmNvbnNvbGUuaW5mbyA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIG5hdGl2ZUluZm8uY2FsbChjb25zb2xlLCBmb3JtYXRXaXRoT3B0aW9ucyhrQ29sb3JJbnNwZWN0T3B0aW9ucywgLi4uYXJncykpO1xufTtcblxuY29uc29sZS5sb2cgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICBuYXRpdmVMb2cuY2FsbChjb25zb2xlLCBmb3JtYXRXaXRoT3B0aW9ucyhrQ29sb3JJbnNwZWN0T3B0aW9ucywgLi4uYXJncykpO1xufTtcblxuY29uc29sZS53YXJuID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgbmF0aXZlV2Fybi5jYWxsKGNvbnNvbGUsIGZvcm1hdFdpdGhPcHRpb25zKGtOb0NvbG9ySW5zcGVjdE9wdGlvbnMsIC4uLmFyZ3MpKTtcbn07XG5cbi8qKlxuICogQXBwY2VsZXJhdG9yIFRpdGFuaXVtIE1vYmlsZVxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG4vLyBBZGQgYSB0b0pTT04oKSBtZXRob2QgdG8gYWxsIEVycm9yIG9iamVjdHMgbmVlZGVkIHRvIG91dHB1dCBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuLy8gVGhlIEpTT04uc3RyaW5naWZ5KCkgd2lsbCBhdXRvbWF0aWNhbGx5IGNhbGwgdGhpcyBtZXRob2QgaWYgaXQgZXhpc3RzIHRvIHByb3ZpZGUgY3VzdG9tIG91dHB1dC5cbi8vIE5vdGVzOlxuLy8gLSBJbiBWOCwgYWxsIEVycm9yIHByb3BlcnRpZXMgYXJlIG5vdCBlbnVtZXJhYmxlLiBXZSBuZWVkIHRoaXMgb3IgZWxzZSBzdHJpbmdpZnkoKSB3aWxsIHJldHVybiBcInt9XCIuXG4vLyAtIEluIEphdmFTY3JpcHRDb3JlLCBvbmx5IHRoZSBcInN0YWNrXCIgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGUuIFdlIHdhbnQgdG8gcmV2ZWFsIHRoaXMuXG5pZiAodHlwZW9mIEVycm9yLnByb3RvdHlwZS50b0pTT04gIT09ICdmdW5jdGlvbicpIHtcbiAgRXJyb3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHByb3BlcnRpZXNbbmFtZV0gPSB0aGlzW25hbWVdO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICB9O1xufVxuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxOSBieSBBeHdheSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xue1xuICB2YXIgYnVmZmVyID0gVGkuY3JlYXRlQnVmZmVyKHtcbiAgICB2YWx1ZTogJydcbiAgfSk7XG4gIHZhciBibG9iID0gYnVmZmVyLnRvQmxvYigpO1xuXG4gIGJsb2IuY29uc3RydWN0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudGV4dDtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/ICdbb2JqZWN0IFRpQmxvYl0nIDogdmFsdWU7XG4gIH07XG5cbiAgaWYgKHBhcnNlSW50KFRpLlBsYXRmb3JtLnZlcnNpb24uc3BsaXQoJy4nKVswXSkgPCAxMSkge1xuICAgIC8vIFRoaXMgaXMgaGFjayB0byBmaXggVElNT0ItMjc3MDcuIFJlbW92ZSBpdCBhZnRlciBtaW5pbXVtIHRhcmdldCBzZXQgaU9TIDExK1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge30sIEluZmluaXR5KTtcbiAgfVxufVxuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxOSBieSBBeHdheSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xudmFyIGNvbG9yc2V0O1xudmFyIG9zVmVyc2lvbjsgLy8gQXMgQW5kcm9pZCBwYXNzZXMgYSBuZXcgaW5zdGFuY2Ugb2YgVGkuVUkgdG8gZXZlcnkgSlMgZmlsZSB3ZSBjYW4ndCBqdXN0XG4vLyBUaS5VSSB3aXRoaW4gdGhpcyBmaWxlLCB3ZSBtdXN0IGNhbGwga3JvbGwuYmluZGluZyB0byBnZXQgdGhlIFRpdGFuaXVtXG4vLyBuYW1lc3BhY2UgdGhhdCBpcyBwYXNzZWQgaW4gd2l0aCByZXF1aXJlIGFuZCB0aGF0IGRlYWwgd2l0aCB0aGUgLlVJXG4vLyBuYW1lc3BhY2UgdGhhdCBpcyBvbiB0aGF0IGRpcmVjdGx5LlxuXG52YXIgdWlNb2R1bGUgPSBUaS5VSTtcblxuaWYgKFRpLkFuZHJvaWQpIHtcbiAgdWlNb2R1bGUgPSBrcm9sbC5iaW5kaW5nKCdUaXRhbml1bScpLlRpdGFuaXVtLlVJO1xufVxuXG51aU1vZHVsZS5TRU1BTlRJQ19DT0xPUl9UWVBFX0xJR0hUID0gJ2xpZ2h0JztcbnVpTW9kdWxlLlNFTUFOVElDX0NPTE9SX1RZUEVfREFSSyA9ICdkYXJrJzsgLy8gV2UgbmVlZCB0byB0cmFjayB0aGlzIG1hbnVhbGx5IHdpdGggYSBnZXR0ZXIvc2V0dGVyXG4vLyBkdWUgdG8gdGhlIHNhbWUgcmVhc29ucyB3ZSB1c2UgdWlNb2R1bGUgaW5zdGVhZCBvZiBUaS5VSVxuXG52YXIgY3VycmVudENvbG9yVHlwZSA9IHVpTW9kdWxlLlNFTUFOVElDX0NPTE9SX1RZUEVfTElHSFQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkodWlNb2R1bGUsICdzZW1hbnRpY0NvbG9yVHlwZScsIHtcbiAgZ2V0OiAoKSA9PiB7XG4gICAgcmV0dXJuIGN1cnJlbnRDb2xvclR5cGU7XG4gIH0sXG4gIHNldDogY29sb3JUeXBlID0+IHtcbiAgICBjdXJyZW50Q29sb3JUeXBlID0gY29sb3JUeXBlO1xuICB9XG59KTtcblxudWlNb2R1bGUuZmV0Y2hTZW1hbnRpY0NvbG9yID0gZnVuY3Rpb24gZmV0Y2hTZW1hbnRpY0NvbG9yKGNvbG9yTmFtZSkge1xuICBpZiAoIW9zVmVyc2lvbikge1xuICAgIG9zVmVyc2lvbiA9IHBhcnNlSW50KFRpLlBsYXRmb3JtLnZlcnNpb24uc3BsaXQoJy4nKVswXSk7XG4gIH1cblxuICBpZiAoVGkuQXBwLmlPUyAmJiBvc1ZlcnNpb24gPj0gMTMpIHtcbiAgICByZXR1cm4gVGkuVUkuaU9TLmZldGNoU2VtYW50aWNDb2xvcihjb2xvck5hbWUpO1xuICB9IGVsc2Uge1xuICAgIGlmICghY29sb3JzZXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBjb2xvcnNldEZpbGUgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoVGkuRmlsZXN5c3RlbS5yZXNvdXJjZXNEaXJlY3RvcnksICdzZW1hbnRpYy5jb2xvcnMuanNvbicpO1xuXG4gICAgICAgIGlmIChjb2xvcnNldEZpbGUuZXhpc3RzKCkpIHtcbiAgICAgICAgICBjb2xvcnNldCA9IEpTT04ucGFyc2UoY29sb3JzZXRGaWxlLnJlYWQoKS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgY29sb3JzIGZpbGUgXFwnc2VtYW50aWMuY29sb3JzLmpzb25cXCcnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29sb3JzZXRbY29sb3JOYW1lXVt1aU1vZHVsZS5zZW1hbnRpY0NvbG9yVHlwZV0uY29sb3IgfHwgY29sb3JzZXRbY29sb3JOYW1lXVt1aU1vZHVsZS5zZW1hbnRpY0NvbG9yVHlwZV07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gbG9va3VwIGNvbG9yIGZvciBcIi5jb25jYXQoY29sb3JOYW1lKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIHRoZSBFdmVudEVtaXR0ZXIgaW5zdGFuY2UgdG8gdXNlIHRvIHJlZ2lzdGVyIGZvciBpdCdzIGV2ZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgZm9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgY2FsbGJhY2svZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJlcGVuZCB3aGV0aGVyIHRvIHByZXBlbmQgb3IgYXBwZW5kIHRoZSBsaXN0ZW5lclxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqL1xuZnVuY3Rpb24gX2FkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNUb0xpc3RlbmVycykge1xuICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgIGVtaXR0ZXIuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307IC8vIGluaXRpYWxpemUgaXRcbiAgfSAvLyBpZiB0aGVyZSdzIHNvbWVvbmUgbGlzdGVuaW5nIHRvICduZXdMaXN0ZW5lcicgZXZlbnRzLCBlbWl0IHRoYXQgKipiZWZvcmUqKiB3ZSBhZGQgdGhlIGxpc3RlbmVyICh0byBhdm9pZCBpbmZpbml0ZSByZWN1cnNpb24pXG5cblxuICBpZiAoZW1pdHRlci5fZXZlbnRzVG9MaXN0ZW5lcnMubmV3TGlzdGVuZXIpIHtcbiAgICBlbWl0dGVyLmVtaXQoJ25ld0xpc3RlbmVyJywgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cblxuICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSBlbWl0dGVyLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdO1xuXG4gIGlmIChwcmVwZW5kKSB7XG4gICAgZXZlbnRMaXN0ZW5lcnMudW5zaGlmdChsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICBlbWl0dGVyLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdID0gZXZlbnRMaXN0ZW5lcnM7IC8vIENoZWNrIG1heCBsaXN0ZW5lcnMgYW5kIHNwaXQgb3V0IHdhcm5pbmcgaWYgPlxuXG4gIHZhciBtYXggPSBlbWl0dGVyLmdldE1heExpc3RlbmVycygpO1xuICB2YXIgbGVuZ3RoID0gZXZlbnRMaXN0ZW5lcnMubGVuZ3RoO1xuXG4gIGlmIChtYXggPiAwICYmIGxlbmd0aCA+IG1heCkge1xuICAgIHZhciB3ID0gbmV3IEVycm9yKFwiUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiBcIi5jb25jYXQobGVuZ3RoLCBcIiBcIikuY29uY2F0KGV2ZW50TmFtZSwgXCIgbGlzdGVuZXJzIGFkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdFwiKSk7XG4gICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgdy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICB3LnR5cGUgPSBldmVudE5hbWU7XG4gICAgdy5jb3VudCA9IGxlbmd0aDtcbiAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKHcpO1xuICB9XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbmZ1bmN0aW9uIG9uY2VXcmFwKGVtaXR0ZXIsIGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgZnVuY3Rpb24gd3JhcHBlciguLi5hcmdzKSB7XG4gICAgdGhpcy5lbWl0dGVyLnJlbW92ZUxpc3RlbmVyKHRoaXMuZXZlbnROYW1lLCB0aGlzLndyYXBwZWRGdW5jKTsgLy8gcmVtb3ZlIG91cnNlbHZlc1xuXG4gICAgdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLmVtaXR0ZXIsIGFyZ3MpOyAvLyB0aGVuIGZvcndhcmQgdGhlIGV2ZW50IGNhbGxiYWNrXG4gIH0gLy8gd2UgaGF2ZSB0byB1c2UgYmluZCB3aXRoIGEgY3VzdG9tICd0aGlzJywgYmVjYXVzZSBldmVudHMgZmlyZSB3aXRoICd0aGlzJyBwb2ludGluZyBhdCB0aGUgZW1pdHRlclxuXG5cbiAgdmFyIHdyYXBwZXJUaGlzID0ge1xuICAgIGVtaXR0ZXIsXG4gICAgZXZlbnROYW1lLFxuICAgIGxpc3RlbmVyXG4gIH07XG4gIHZhciBib3VuZCA9IHdyYXBwZXIuYmluZCh3cmFwcGVyVGhpcyk7IC8vIGJpbmQgdG8gZm9yY2UgXCJ0aGlzXCIgdG8gcmVmZXIgdG8gb3VyIGN1c3RvbSBvYmplY3QgdHJhY2tpbmcgdGhlIHdyYXBwZXIvZW1pdHRlci9saXN0ZW5lclxuXG4gIGJvdW5kLmxpc3RlbmVyID0gbGlzdGVuZXI7IC8vIGhhdmUgdG8gYWRkIGxpc3RlbmVyIHByb3BlcnR5IGZvciBcInVud3JhcHBpbmdcIlxuXG4gIHdyYXBwZXJUaGlzLndyYXBwZWRGdW5jID0gYm91bmQ7XG4gIHJldHVybiBib3VuZDtcbn0gLy8gbWFueSBjb25zdW1lcnMgbWFrZSB1c2Ugb2YgdGhpcyB2aWEgdXRpbC5pbmhlcml0cywgd2hpY2ggZG9lcyBub3QgY2hhaW4gY29uc3RydWN0b3IgY2FsbHMhXG4vLyBzbyB3ZSBuZWVkIHRvIGJlIGF3YXJlIHRoYXQgX2V2ZW50c1RvTGlzdGVuZXJzIG1heWUgYmUgbnVsbC91bmRlZmluZWQgb24gaW5zdGFuY2VzLCBhbmQgY2hlY2sgaW4gbWV0aG9kcyBiZWZvcmUgYWNjZXNzaW5nIGl0XG5cblxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCBldmVudE5hbWUsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIH1cblxuICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cblxuICBwcmVwZW5kTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgZXZlbnROYW1lLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gIH1cblxuICBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLm9uKGV2ZW50TmFtZSwgb25jZVdyYXAodGhpcywgZXZlbnROYW1lLCBsaXN0ZW5lcikpO1xuICB9XG5cbiAgcHJlcGVuZE9uY2VMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIoZXZlbnROYW1lLCBvbmNlV3JhcCh0aGlzLCBldmVudE5hbWUsIGxpc3RlbmVyKSk7XG4gIH1cblxuICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNUb0xpc3RlbmVycykge1xuICAgICAgLy8gbm8gZXZlbnRzL2xpc3RlbmVycyByZWdpc3RlcmVkXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdO1xuICAgIHZhciBsZW5ndGggPSBldmVudExpc3RlbmVycy5sZW5ndGg7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICB2YXIgdW53cmFwcGVkTGlzdGVuZXI7IC8vIE5lZWQgdG8gc2VhcmNoIExJRk8sIGFuZCBuZWVkIHRvIGhhbmRsZSB3cmFwcGVkIGZ1bmN0aW9ucyAob25jZSB3cmFwcGVycylcblxuICAgIGZvciAodmFyIGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGV2ZW50TGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lciB8fCBldmVudExpc3RlbmVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgZm91bmRJbmRleCA9IGk7XG4gICAgICAgIHVud3JhcHBlZExpc3RlbmVyID0gZXZlbnRMaXN0ZW5lcnNbaV0ubGlzdGVuZXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBsZW5ndGggd2FzIDEgYW5kIHdlIHdhbnQgdG8gcmVtb3ZlIGxhc3QgZW50cnksIHNvIGRlbGV0ZSB0aGUgZXZlbnQgdHlwZSBmcm9tIG91ciBsaXN0ZW5lciBtYXBwaW5nIG5vdyFcbiAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBoYWQgMisgbGlzdGVuZXJzLCBzbyBzdG9yZSBhcnJheSB3aXRob3V0IHRoaXMgZ2l2ZW4gbGlzdGVuZXJcbiAgICAgICAgZXZlbnRMaXN0ZW5lcnMuc3BsaWNlKGZvdW5kSW5kZXgsIDEpOyAvLyBtb2RpZmllcyBpbiBwbGFjZSwgbm8gbmVlZCB0byBhc3NpZ24gdG8gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXVxuICAgICAgfSAvLyBEb24ndCBlbWl0IGlmIHRoZXJlJ3Mgbm8gbGlzdGVuZXJzIGZvciAncmVtb3ZlTGlzdGVuZXInIHR5cGUhXG5cblxuICAgICAgaWYgKHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCBldmVudE5hbWUsIHVud3JhcHBlZExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cblxuICBlbWl0KGV2ZW50TmFtZSwgLi4uYXJncykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBldmVudExpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW107XG5cbiAgICBmb3IgKHZhciBsaXN0ZW5lciBvZiBldmVudExpc3RlbmVycy5zbGljZSgpKSB7XG4gICAgICAvLyBtdXN0IG9wZXJhdGUgb24gY29weSBiZWNhdXNlIGxpc3RlbmVycyAsYXkgZ2V0IHJlbW92ZSBhcyBzaWRlLWVmZmVjdCBvZiBjYWxsaW5nXG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudExpc3RlbmVycy5sZW5ndGggIT09IDA7XG4gIH1cblxuICBsaXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50TGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXTtcbiAgICByZXR1cm4gZXZlbnRMaXN0ZW5lcnMubGVuZ3RoO1xuICB9XG5cbiAgZXZlbnROYW1lcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMgfHwge30pO1xuICB9XG5cbiAgbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gLy8gTmVlZCB0byBcInVud3JhcFwiIG9uY2Ugd3JhcHBlcnMhXG5cblxuICAgIHZhciByYXcgPSB0aGlzLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdO1xuICAgIHJldHVybiByYXcubWFwKGwgPT4gbC5saXN0ZW5lciB8fCBsKTsgLy8gaGVyZSB3ZSB1bndyYXAgdGhlIG9uY2Ugd3JhcHBlciBpZiB0aGVyZSBpcyBvbmUgb3IgZmFsbCBiYWNrIHRvIGxpc3RlbmVyIGZ1bmN0aW9uXG4gIH1cblxuICByYXdMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNUb0xpc3RlbmVycykge1xuICAgICAgLy8gbm8gZXZlbnRzL2xpc3RlbmVycyByZWdpc3RlcmVkXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdKS5zbGljZSgwKTsgLy8gcmV0dXJuIGEgY29weVxuICB9XG5cbiAgZ2V0TWF4TGlzdGVuZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH1cblxuICBzZXRNYXhMaXN0ZW5lcnMobikge1xuICAgIHRoaXMuX21heExpc3RlbmVycyA9IG47IC8vIFRPRE86IFR5cGUgY2hlY2sgbiwgbWFrZSBzdXJlID49IDAgKG8gZXF1YWxzIG5vIGxpbWl0KVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNUb0xpc3RlbmVycykge1xuICAgICAgLy8gbm8gZXZlbnRzL2xpc3RlbmVycyByZWdpc3RlcmVkXG4gICAgICB0aGlzLl9ldmVudHNUb0xpc3RlbmVycyA9IHt9OyAvLyBpbml0aWFsaXplIGl0XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9ldmVudHNUb0xpc3RlbmVycy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgLy8gbm8gbmVlZCB0byBlbWl0ISB3ZSBjYW4ganVzdCB3aXBlIVxuICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHJlbW92ZSBldmVyeSB0eXBlIVxuICAgICAgICB0aGlzLl9ldmVudHNUb0xpc3RlbmVycyA9IHt9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVtb3ZlIHNwZWNpZmljIHR5cGVcbiAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8geXVjaywgd2UnbGwgaGF2ZSB0byBlbWl0ICdyZW1vdmVMaXN0ZW5lcicgZXZlbnRzIGFzIHdlIGdvXG5cblxuICAgIGlmIChldmVudE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gUmVtb3ZlIGFsbCB0eXBlcyAoYnV0IGRvICdyZW1vdmVMaXN0ZW5lcicgbGFzdCEpXG4gICAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9ldmVudHNUb0xpc3RlbmVycykuZmlsdGVyKG5hbWUgPT4gbmFtZSAhPT0gJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICBuYW1lcy5mb3JFYWNoKG5hbWUgPT4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMobmFtZSkpO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICB0aGlzLl9ldmVudHNUb0xpc3RlbmVycyA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgbGlzdGVuZXJzIGZvciBvbmUgdHlwZSwgYmFjayB0byBmcm9udCAoTGFzdC1pbiwgZmlyc3Qtb3V0LCBleGNlcHQgd2hlcmUgcHJlcGVuZCBmLWVkIGl0IHVwKVxuICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW107XG5cbiAgICAgIGZvciAodmFyIGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufVxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgZXZlbnROYW1lKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKTtcbn07XG5cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8qKlxuICogQHBhcmFtICB7Kn0gYXJnIHBhc3NlZCBpbiBhcmd1bWVudCB2YWx1ZVxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGFyZ3VtZW50XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGVuYW1lIGkuZS4gJ3N0cmluZycsICdGdW5jdGlvbicgKHZhbHVlIGlzIGNvbXBhcmVkIHRvIHR5cGVvZiBhZnRlciBsb3dlcmNhc2luZylcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50VHlwZShhcmcsIG5hbWUsIHR5cGVuYW1lKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGFyZztcblxuICBpZiAodHlwZSAhPT0gdHlwZW5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIFwiKS5jb25jYXQodHlwZW5hbWUsIFwiLiBSZWNlaXZlZCB0eXBlIFwiKS5jb25jYXQodHlwZSkpO1xuICB9XG59XG5cbnZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uICdzdGFuZGFyZGl6ZXMnIHRoZSByZXBvcnRlZCBhcmNoaXRlY3R1cmVzIHRvIHRoZSBlcXVpdmFsZW50cyByZXBvcnRlZCBieSBOb2RlLmpzXG4gKiBub2RlIHZhbHVlczogJ2FybScsICdhcm02NCcsICdpYTMyJywgJ21pcHMnLCAnbWlwc2VsJywgJ3BwYycsICdwcGM2NCcsICdzMzkwJywgJ3MzOTB4JywgJ3gzMicsIGFuZCAneDY0Jy5cbiAqIGlPUyB2YWx1ZXM6IFwiYXJtNjRcIiwgXCJhcm12N1wiLCBcIng4Nl82NFwiLCBcImkzODZcIiwgXCJVbmtub3duXCJcbiAqIEFuZHJvaWQgdmFsdWVzOiBcImFybWVhYmlcIiwgXCJhcm1lYWJpLXY3YVwiLCBcImFybTY0LXY4YVwiLCBcIng4NlwiLCBcIng4Nl82NFwiLCBcIm1pcHNcIiwgXCJtaXBzNjRcIiwgXCJ1bmtub3duXCJcbiAqIFdpbmRvd3MgdmFsdWVzOiBcIng2NFwiLCBcImlhNjRcIiwgXCJBUk1cIiwgXCJ4ODZcIiwgXCJ1bmtub3duXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW5hbCBvcmlnaW5hbCBhcmNoaXRlY3R1cmUgcmVwb3J0ZWQgYnkgVGkuUGxhdGZvcm1cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gc3RhbmRhcmRpemVBcmNoKG9yaWdpbmFsKSB7XG4gIHN3aXRjaCAob3JpZ2luYWwpIHtcbiAgICAvLyBjb2VyY2UgJ2FybXY3JywgJ2FybWVhYmknLCAnYXJtZWFiaS12N2EnLCAnQVJNJyAtPiAnYXJtJ1xuICAgIC8vICdhcm1lYWJpJyBpcyBhIGRlYWQgQUJJIGZvciBBbmRyb2lkLCByZW1vdmVkIGluIE5ESyByMTdcbiAgICBjYXNlICdhcm12Nyc6XG4gICAgY2FzZSAnYXJtZWFiaSc6XG4gICAgY2FzZSAnYXJtZWFiaS12N2EnOlxuICAgIGNhc2UgJ0FSTSc6XG4gICAgICByZXR1cm4gJ2FybSc7XG4gICAgLy8gY29lcmNlICdhcm02NC12OGEnIC0+ICdhcm02NCdcblxuICAgIGNhc2UgJ2FybTY0LXY4YSc6XG4gICAgICByZXR1cm4gJ2FybTY0JztcbiAgICAvLyBjb2VyY2UgJ2kzODYnLCAneDg2JyAtPiAnaWEzMidcblxuICAgIGNhc2UgJ2kzODYnOlxuICAgIGNhc2UgJ3g4Nic6XG4gICAgICByZXR1cm4gJ2lhMzInO1xuICAgIC8vIGNvZXJjZSAneDg2XzY0JywgJ2lhNjQnLCAneDY0JyAtPiAneDY0J1xuXG4gICAgY2FzZSAneDg2XzY0JzpcbiAgICBjYXNlICdpYTY0JzpcbiAgICAgIHJldHVybiAneDY0JztcbiAgICAvLyBjb2VyY2UgJ21pcHM2NCcgLT4gJ21pcHMnIC8vICdtaXBzJyBhbmQgJ21pcHM2NCcgYXJlIGRlYWQgQUJJcyBmb3IgQW5kcm9pZCwgcmVtb3ZlZCBpbiBOREsgcjE3XG5cbiAgICBjYXNlICdtaXBzNjQnOlxuICAgICAgcmV0dXJuICdtaXBzJztcbiAgICAvLyBjb2VyY2UgJ1Vua25vd24nIC0+ICd1bmtub3duJ1xuXG4gICAgY2FzZSAnVW5rbm93bic6XG4gICAgICByZXR1cm4gJ3Vua25vd24nO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgfVxufVxuXG52YXIgcHJvY2VzcyQ1ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5wcm9jZXNzJDUuYWJvcnQgPSAoKSA9PiB7fTsgLy8gVE9ETzogRG8gd2UgaGF2ZSBlcXVpdmFsZW50IG9mIGZvcmNpYmx5IGtpbGxpbmcgdGhlIHByb2Nlc3M/IFdlIGhhdmUgcmVzdGFydCwgYnV0IEkgdGhpbmsgd2UganVzdCB3YW50IGEgbm8tb3Agc3R1YiBoZXJlXG5cblxucHJvY2VzcyQ1LmFyY2ggPSBzdGFuZGFyZGl6ZUFyY2goVGkuUGxhdGZvcm0uYXJjaGl0ZWN0dXJlKTtcbnByb2Nlc3MkNS5hcmd2ID0gW107IC8vIFRPRE86IFdoYXQgbWFrZXMgc2Vuc2UgaGVyZT8gcGF0aCB0byB0aXRhbml1bSBjbGkgZm9yIGZpcnN0IGFyZz8gcGF0aCB0byB0aS5tYWluL2FwcC5qcyBmb3Igc2Vjb25kP1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvY2VzcyQ1LCAnYXJndjAnLCB7XG4gIHZhbHVlOiAnJyxcbiAgLy8gVE9ETzogUGF0aCB0byAuYXBwIG9uIGlPUz9cbiAgd3JpdGFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59KTtcblxucHJvY2VzcyQ1LmJpbmRpbmcgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIHVuc3VwcG9ydGVkIGFuZCBub3QgdXNlci1mYWNpbmcgQVBJJyk7XG59O1xuXG5wcm9jZXNzJDUuY2hhbm5lbCA9IHVuZGVmaW5lZDtcblxucHJvY2VzcyQ1LmNoZGlyID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgdW5zdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MkNS5jb25maWcgPSB7fTtcbnByb2Nlc3MkNS5jb25uZWN0ZWQgPSBmYWxzZTtcblxucHJvY2VzcyQ1LmNwdVVzYWdlID0gKCkgPT4ge1xuICAvLyBGSVhNRTogQ2FuIHdlIGxvb2sgYXQgT1MuY3B1cyB0byBnZXQgdGhpcyBkYXRhP1xuICByZXR1cm4ge1xuICAgIHVzZXI6IDAsXG4gICAgc3lzdGVtOiAwXG4gIH07XG59O1xuXG5wcm9jZXNzJDUuY3dkID0gKCkgPT4gX19kaXJuYW1lO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvY2VzcyQ1LCAnZGVidWdQb3J0Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSAwOyAvLyBkZWZhdWx0IHRvIDBcblxuICAgIHRyeSB7XG4gICAgICBpZiAoVGkuUGxhdGZvcm0ub3NuYW1lID09PSAnYW5kcm9pZCcpIHtcbiAgICAgICAgdmFyIGFzc2V0cyA9IGtyb2xsLmJpbmRpbmcoJ2Fzc2V0cycpO1xuICAgICAgICB2YXIganNvbiA9IGFzc2V0cy5yZWFkQXNzZXQoJ2RlcGxveS5qc29uJyk7XG5cbiAgICAgICAgaWYgKGpzb24pIHtcbiAgICAgICAgICB2YXIgZGVwbG95RGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG5cbiAgICAgICAgICBpZiAoZGVwbG95RGF0YS5kZWJ1Z2dlclBvcnQgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyAtMSBtZWFucyBub3Qgc2V0IChub3QgaW4gZGVidWcgbW9kZSlcbiAgICAgICAgICAgIHZhbHVlID0gZGVwbG95RGF0YS5kZWJ1Z2dlclBvcnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRydWUpIHtcbiAgICAgICAgLy8gaU9TIGlzIDI3NzUzIGFzIG9mIGlvcyA8IDExLjMgZm9yIHNpbXVsYXRvcnNcbiAgICAgICAgLy8gZm9yIDExLjMrIGl0IHVzZXMgYSB1bml4IHNvY2tldFxuICAgICAgICAvLyBmb3IgZGV2aWNlcywgaXQgdXNlcyB1c2JtdXhkXG4gICAgICAgIHZhbHVlID0gMjc3NTM7IC8vIFRPRE86IENhbiB3ZSBvbmx5IHJldHVybiB0aGlzIGZvciBzaW11bGF0b3IgPCAxMS4zP1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7fSAvLyBpZ25vcmVcbiAgICAvLyBvdmVyd3JpdGUgdGhpcyBnZXR0ZXIgd2l0aCBzdGF0aWMgdmFsdWVcblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdkZWJ1Z1BvcnQnLCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbnByb2Nlc3MkNS5kaXNjb25uZWN0ID0gKCkgPT4ge307IC8vIG5vLW9wXG5cblxucHJvY2VzcyQ1LmRsb3BlbiA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmRsb3BlbiBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzJDUuZW1pdFdhcm5pbmcgPSBmdW5jdGlvbiAod2FybmluZywgb3B0aW9ucywgY29kZSwgY3Rvcikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciB0eXBlO1xuICB2YXIgZGV0YWlsO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICB0eXBlID0gb3B0aW9ucztcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICB0eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIGNvZGUgPSBvcHRpb25zLmNvZGU7XG4gICAgZGV0YWlsID0gb3B0aW9ucy5kZXRhaWw7XG4gIH1cblxuICBpZiAodHlwZW9mIHdhcm5pbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVE9ETzogbWFrZSB1c2Ugb2YgYGN0b3JgIGFyZyBmb3IgbGltaXRpbmcgc3RhY2sgdHJhY2VzPyBDYW4gb25seSByZWFsbHkgYmUgdXNlZCBvbiBWOFxuICAgIC8vIHNldCBzdGFjayB0cmFjZSBsaW1pdCB0byAwLCB0aGVuIGNhbGwgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2Uod2FybmluZywgY3Rvcik7XG4gICAgd2FybmluZyA9IG5ldyBFcnJvcih3YXJuaW5nKTtcbiAgICB3YXJuaW5nLm5hbWUgPSB0eXBlIHx8ICdXYXJuaW5nJztcblxuICAgIGlmIChjb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdhcm5pbmcuY29kZSA9IGNvZGU7XG4gICAgfVxuXG4gICAgaWYgKGRldGFpbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3YXJuaW5nLmRldGFpbCA9IGRldGFpbDtcbiAgICB9XG4gIH0gLy8gVE9ETzogVGhyb3cgVHlwZUVycm9yIGlmIG5vdCBhbiBpbnN0YW5jZW9mIEVycm9yIGF0IHRoaXMgcG9pbnQhXG5cblxuICB2YXIgaXNEZXByZWNhdGlvbiA9IHdhcm5pbmcubmFtZSA9PT0gJ0RlcHJlY2F0aW9uV2FybmluZyc7XG5cbiAgaWYgKGlzRGVwcmVjYXRpb24gJiYgcHJvY2VzcyQ1Lm5vRGVwcmVjYXRpb24pIHtcbiAgICByZXR1cm47IC8vIGlnbm9yZVxuICB9XG5cbiAgaWYgKGlzRGVwcmVjYXRpb24gJiYgcHJvY2VzcyQ1LnRocm93RGVwcmVjYXRpb24pIHtcbiAgICB0aHJvdyB3YXJuaW5nO1xuICB9XG5cbiAgdGhpcy5lbWl0KCd3YXJuaW5nJywgd2FybmluZyk7XG59O1xuXG5mdW5jdGlvbiBsb2FkRW52SnNvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIganNvbkZpbGUgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoVGkuRmlsZXN5c3RlbS5yZXNvdXJjZXNEaXJlY3RvcnksICdfZW52Xy5qc29uJyk7XG5cbiAgICBpZiAoanNvbkZpbGUuZXhpc3RzKCkpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25GaWxlLnJlYWQoKS50ZXh0KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgVGkuQVBJLmVycm9yKFwiRmFpbGVkIHRvIHJlYWQgXFxcIl9lbnZfLmpzb25cXFwiLiBSZWFzb246IFwiLmNvbmNhdChlcnJvci5tZXNzYWdlKSk7XG4gIH1cblxuICByZXR1cm4ge307XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9jZXNzJDUsICdlbnYnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGRlbGV0ZSB0aGlzLmVudjtcbiAgICByZXR1cm4gdGhpcy5lbnYgPSBsb2FkRW52SnNvbigpO1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xucHJvY2VzcyQ1LmV4ZWNBcmd2ID0gW107XG5wcm9jZXNzJDUuZXhlY1BhdGggPSAnJzsgLy8gRklYTUU6IFdoYXQgbWFrZXMgc2Vuc2UgaGVyZT8gUGF0aCB0byB0aXRhbml1bSBDTEkgaGVyZT9cblxucHJvY2VzcyQ1LmV4aXQgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5leGl0IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MkNS5leGl0Q29kZSA9IHVuZGVmaW5lZDtcbnByb2Nlc3MkNS5ub0RlcHJlY2F0aW9uID0gZmFsc2U7XG5wcm9jZXNzJDUucGlkID0gMDsgLy8gRklYTUU6IFNob3VsZCB3ZSB0cnkgYW5kIGFkb3B0ICdpcGFkJy8naXBob25lJyB0byAnZGFyd2luJz8gb3IgJ2lvcyc/XG5cbnByb2Nlc3MkNS5wbGF0Zm9ybSA9IFRpLlBsYXRmb3JtLm9zbmFtZTtcbnByb2Nlc3MkNS5wcGlkID0gMDsgLy8gVE9ETzogQWRkIHJlbGVhc2UgcHJvcGVydHkgKE9iamVjdClcbi8vIFRPRE86IENhbiB3ZSBleHBvc2Ugc3Rkb3V0L3N0ZGVyci9zdGRpbiBuYXRpdmVseT9cblxucHJvY2VzcyQ1LnN0ZGVyciA9IHtcbiAgaXNUVFk6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgd3JpdGU6IChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSA9PiB7XG4gICAgY29uc29sZS5lcnJvcihjaHVuayk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5wcm9jZXNzJDUuc3Rkb3V0ID0ge1xuICBpc1RUWTogZmFsc2UsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB3cml0ZTogKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spID0+IHtcbiAgICBjb25zb2xlLmxvZyhjaHVuayk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5wcm9jZXNzJDUudGl0bGUgPSBUaS5BcHAubmFtZTtcbnByb2Nlc3MkNS50aHJvd0RlcHJlY2F0aW9uID0gZmFsc2U7XG5wcm9jZXNzJDUudHJhY2VEZXByZWNhdGlvbiA9IGZhbHNlO1xuXG5wcm9jZXNzJDUudW1hc2sgPSAoKSA9PiAwOyAvLyBqdXN0IGFsd2F5cyByZXR1cm4gMFxuXG5cbnByb2Nlc3MkNS51cHRpbWUgPSAoKSA9PiB7XG4gIHZhciBkaWZmTXMgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICByZXR1cm4gZGlmZk1zIC8gMTAwMC4wOyAvLyBjb252ZXJ0IHRvIFwic2Vjb25kc1wiIHdpdGggZnJhY3Rpb25zXG59O1xuXG5wcm9jZXNzJDUudmVyc2lvbiA9IFwiOS4xLjBcIjtcbnByb2Nlc3MkNS52ZXJzaW9ucyA9IHtcbiAgbW9kdWxlczogJycsXG4gIC8vIFRPRE86IFJlcG9ydCBtb2R1bGUgYXBpIHZlcnNpb24gKGZvciBjdXJyZW50IHBsYXRmb3JtISlcbiAgdjg6ICcnLFxuICAvLyBUT0RPOiByZXBvcnQgYW5kcm9pZCdzIHY4IHZlcnNpb24gKGlmIG9uIEFuZHJvaWQhKVxuICBqc2M6ICcnIC8vIFRPRE86IHJlcG9ydCBqYXZhc2NyaXB0Y29yZSB2ZXJzaW9uIGZvciBpT1MvV0luZG93cz9cbiAgLy8gVE9ETzogUmVwb3J0IGlvcy9BbmRyb2lkL1dpbmRvd3MgcGxhdGZvcm0gdmVyc2lvbnM/XG5cbn07XG5nbG9iYWwucHJvY2VzcyA9IHByb2Nlc3MkNTsgLy8gaGFuZGxlIHNwaXR0aW5nIG91dCB3YXJuaW5nc1xuXG52YXIgV0FSTklOR19QUkVGSVggPSBcIih0aXRhbml1bTpcIi5jb25jYXQocHJvY2VzcyQ1LnBpZCwgXCIpIFwiKTtcbnByb2Nlc3MkNS5vbignd2FybmluZycsIHdhcm5pbmcgPT4ge1xuICB2YXIgaXNEZXByZWNhdGlvbiA9IHdhcm5pbmcubmFtZSA9PT0gJ0RlcHJlY2F0aW9uV2FybmluZyc7IC8vIGlmIHdlJ3JlIG5vdCBkb2luZyBkZXByZWNhdGlvbnMsIGlnbm9yZSFcblxuICBpZiAoaXNEZXByZWNhdGlvbiAmJiBwcm9jZXNzJDUubm9EZXByZWNhdGlvbikge1xuICAgIHJldHVybjtcbiAgfSAvLyBUT0RPOiBDaGVjayBwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24gYW5kIGlmIHNldCwgaW5jbHVkZSBzdGFjayB0cmFjZSBpbiBtZXNzYWdlIVxuXG5cbiAgdmFyIG1zZyA9IFdBUk5JTkdfUFJFRklYO1xuXG4gIGlmICh3YXJuaW5nLmNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgIG1zZyArPSBcIltcIi5jb25jYXQod2FybmluZy5jb2RlLCBcIl0gXCIpO1xuICB9XG5cbiAgaWYgKHdhcm5pbmcudG9TdHJpbmcpIHtcbiAgICBtc2cgKz0gd2FybmluZy50b1N0cmluZygpO1xuICB9XG5cbiAgaWYgKHdhcm5pbmcuZGV0YWlsKSB7XG4gICAgbXNnICs9IFwiXFxuXCIuY29uY2F0KHdhcm5pbmcuZGV0YWlsKTtcbiAgfVxuXG4gIGNvbnNvbGUuZXJyb3IobXNnKTtcbn0pO1xudmFyIHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2sgPSBudWxsO1xuXG5wcm9jZXNzJDUuaGFzVW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2sgPSAoKSA9PiB1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrICE9PSBudWxsO1xuXG5wcm9jZXNzJDUuc2V0VW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2sgPSBmbiA9PiB7XG4gIGlmIChmbiA9PT0gbnVsbCkge1xuICAgIHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2sgPSBudWxsO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFzc2VydEFyZ3VtZW50VHlwZShmbiwgJ2ZuJywgJ2Z1bmN0aW9uJyk7XG5cbiAgaWYgKHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bwcm9jZXNzLnNldFVuY2F1Z2h0RXhjZXB0aW9uQ2FwdHVyZUNhbGxiYWNrKClgIHdhcyBjYWxsZWQgd2hpbGUgYSBjYXB0dXJlIGNhbGxiYWNrIHdhcyBhbHJlYWR5IGFjdGl2ZScpO1xuICB9XG5cbiAgdW5jYXVnaHRFeGNlcHRpb25DYWxsYmFjayA9IGZuO1xufTtcblxuVGkuQXBwLmFkZEV2ZW50TGlzdGVuZXIoJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIENyZWF0ZSBhbiBFcnJvciBpbnN0YW5jZSB0aGF0IHdyYXBzIHRoZSBkYXRhIGZyb20gdGhlIGV2ZW50XG4gIC8vIGlkZWFsbHkgd2UnZCBqdXN0IGZvcndhcmQgYWxvbmcgdGhlIG9yaWdpbmFsIEVycm9yIVxuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoZXZlbnQubWVzc2FnZSk7XG4gIGVycm9yLnN0YWNrID0gZXZlbnQuYmFja3RyYWNlO1xuICBlcnJvci5maWxlTmFtZSA9IGV2ZW50LnNvdXJjZU5hbWU7XG4gIGVycm9yLmxpbmVOdW1iZXIgPSBldmVudC5saW5lO1xuICBlcnJvci5jb2x1bW5OdW1iZXIgPSBldmVudC5saW5lT2Zmc2V0O1xuXG4gIGlmIChwcm9jZXNzJDUuaGFzVW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2soKSkge1xuICAgIHJldHVybiB1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrKGVycm9yKTtcbiAgfSAvLyBvdGhlcndpc2UgZm9yd2FyZCB0aGUgZXZlbnQhXG5cblxuICBwcm9jZXNzJDUuZW1pdCgndW5jYXVnaHRFeGNlcHRpb24nLCBlcnJvcik7XG59KTtcbi8vIEpTIGVuZ2luZSBzaG91bGQgYmUgYWJsZSB0byBvcHRpbWl6ZSBlYXNpZXJcblxuY2xhc3MgQ2FsbGJhY2tXaXRoQXJncyB7XG4gIGNvbnN0cnVjdG9yKGZ1bmMsIGFyZ3MpIHtcbiAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gIH1cblxuICBydW4oKSB7XG4gICAgaWYgKHRoaXMuYXJncykge1xuICAgICAgdGhpcy5mdW5jLmFwcGx5KG51bGwsIHRoaXMuYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZnVuKCk7XG4gICAgfVxuICB9XG5cbn0gLy8gbmV4dFRpY2sgdnMgc2V0SW1tZWRpYXRlIHNob3VsZCBiZSBoYW5kbGVkIGluIGEgc2VtaS1zbWFydCB3YXlcbi8vIEJhc2ljYWxseSBuZXh0VGljayBuZWVkcyB0byBkcmFpbiB0aGUgZnVsbCBxdWV1ZSAoYW5kIGNhbiBjYXVzZSBpbmZpbml0ZSBsb29wcyBpZiBuZXh0VGljayBjYWxsYmFjayBjYWxscyBuZXh0VGljayEpXG4vLyBUaGVuIHdlIHNob3VsZCBnbyB0aHJvdWdoIHRoZSBcImltbWVkaWF0ZVwiIHF1ZXVlXG4vLyBodHRwOi8vcGxhZmVyLmdpdGh1Yi5pby8yMDE1LzA5LzA4L25leHRUaWNrLXZzLXNldEltbWVkaWF0ZS9cblxuXG52YXIgdGlja1F1ZXVlID0gW107XG52YXIgaW1tZWRpYXRlUXVldWUgPSBbXTtcbnZhciBkcmFpbmluZ1RpY2tRdWV1ZSA9IGZhbHNlO1xudmFyIGRyYWluUXVldWVzVGltZW91dCA9IG51bGw7XG4vKipcbiAqIEl0ZXJhdGl2ZWx5IHJ1bnMgYWxsIFwidGlja3NcIiB1bnRpbCB0aGVyZSBhcmUgbm8gbW9yZS5cbiAqIFRoaXMgY2FuIGNhdXNlIGluZmluaXRlIHJlY3Vyc2lvbiBpZiBhIHRpY2sgc2NoZWR1bGVzIGFub3RoZXIgZm9yZXZlci5cbiAqL1xuXG5mdW5jdGlvbiBkcmFpblRpY2tRdWV1ZSgpIHtcbiAgaWYgKGRyYWluaW5nVGlja1F1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZHJhaW5pbmdUaWNrUXVldWUgPSB0cnVlO1xuXG4gIHdoaWxlICh0aWNrUXVldWUubGVuZ3RoKSB7XG4gICAgdmFyIHRpY2sgPSB0aWNrUXVldWUuc2hpZnQoKTtcbiAgICB0aWNrLnJ1bigpO1xuICB9XG5cbiAgZHJhaW5pbmdUaWNrUXVldWUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZXMoKSB7XG4gIC8vIGRyYWluIHRoZSBmdWxsIHRpY2sgcXVldWUgZmlyc3QuLi5cbiAgZHJhaW5UaWNrUXVldWUoKTsgLy8gdGljayBxdWV1ZSBzaG91bGQgYmUgZW1wdHkhXG5cbiAgdmFyIGltbWVkaWF0ZXNSZW1haW5pbmcgPSBwcm9jZXNzSW1tZWRpYXRlUXVldWUoKTtcblxuICBpZiAoaW1tZWRpYXRlc1JlbWFpbmluZyAhPT0gMCkge1xuICAgIC8vIHJlLXNjaGVkdWxlIGRyYWluaW5nIG91ciBxdWV1ZXMsIGFzIHdlIGhhdmUgYXQgbGVhc3Qgb25lIG1vcmUgXCJpbW1lZGlhdGVcIiB0byBoYW5kbGVcbiAgICBkcmFpblF1ZXVlc1RpbWVvdXQgPSBzZXRUaW1lb3V0KGRyYWluUXVldWVzLCAwKTtcbiAgfSBlbHNlIHtcbiAgICBkcmFpblF1ZXVlc1RpbWVvdXQgPSBudWxsO1xuICB9XG59XG4vKipcbiAqIEF0dGVtcHRzIHRvIHByb2Nlc3MgXCJpbW1lZGlhdGVzXCIgKGluIGEgbXVjaCBtb3JlIGxlaXN1cmVseSB3YXkgdGhhbiB0aWNrcylcbiAqIFdlIGdpdmUgYSAxMDBtcyB3aW5kb3cgdG8gcnVuIHRoZW0gaW4gYmVmb3JlIHJlLXNjaGVkdWxpbmcgdGhlIHRpbWVvdXQgdG8gcHJvY2VzcyB0aGVtIGFnYWluLlxuICogSWYgYW55IHRpY2tzIGFyZSBhZGRlZCBkdXJpbmcgaW52b2NhdGlvbiBvZiBpbW1lZGlhdGUsIHdlIGRyYWluIHRoZSB0aWNrIHF1ZXVlIGZ1bGx5IGJlZm9yZVxuICogcHJvY2VlZGluZyB0byBuZXh0IGltbWVkaWF0ZSAoaWYgd2Ugc3RpbGwgaGF2ZSB0aW1lIGluIG91ciB3aW5kb3cpLlxuICogQHJldHVybnMge251bWJlcn0gbnVtYmVyIG9mIHJlbWFpbmluZyBpbW1lZGlhdGVzIHRvIGJlIHByb2Nlc3NlZFxuICovXG5cblxuZnVuY3Rpb24gcHJvY2Vzc0ltbWVkaWF0ZVF1ZXVlKCkge1xuICB2YXIgaW1tZWRpYXRlRGVhZGxpbmUgPSBEYXRlLm5vdygpICsgMTAwOyAvLyBnaXZlIHVzIHVwIHRvIDEwMG1zIHRvIHByb2Nlc3MgaW1tZWRpYXRlc1xuXG4gIHdoaWxlIChpbW1lZGlhdGVRdWV1ZS5sZW5ndGggJiYgRGF0ZS5ub3coKSA8IGltbWVkaWF0ZURlYWRsaW5lKSB7XG4gICAgdmFyIGltbWVkaWF0ZSA9IGltbWVkaWF0ZVF1ZXVlLnNoaWZ0KCk7XG4gICAgaW1tZWRpYXRlLnJ1bigpO1xuXG4gICAgaWYgKHRpY2tRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAvLyB0aGV5IGFkZGVkIGEgdGljayEgZHJhaW4gdGhlIHRpY2sgcXVldWUgYmVmb3JlIHdlIGRvIGFueXRoaW5nIGVsc2UgKHRoaXMgKm1heSogZWF0IHVwIG91ciBkZWFkbGluZS93aW5kb3cgdG8gcHJvY2VzcyBhbnkgbW9yZSBpbW1lZGlhdGVzKVxuICAgICAgZHJhaW5UaWNrUXVldWUoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW1tZWRpYXRlUXVldWUubGVuZ3RoO1xufVxuXG5wcm9jZXNzJDUubmV4dFRpY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIC4uLmFyZ3MpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGNhbGxiYWNrLCAnY2FsbGJhY2snLCAnZnVuY3Rpb24nKTtcbiAgdGlja1F1ZXVlLnB1c2gobmV3IENhbGxiYWNrV2l0aEFyZ3MoY2FsbGJhY2ssIGFyZ3MpKTtcblxuICBpZiAoIWRyYWluUXVldWVzVGltZW91dCkge1xuICAgIGRyYWluUXVldWVzVGltZW91dCA9IHNldFRpbWVvdXQoZHJhaW5RdWV1ZXMsIDApO1xuICB9XG59O1xuXG5nbG9iYWwuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCAuLi5hcmdzKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShjYWxsYmFjaywgJ2NhbGxiYWNrJywgJ2Z1bmN0aW9uJyk7XG4gIHZhciBpbW1lZGlhdGUgPSBuZXcgQ2FsbGJhY2tXaXRoQXJncyhjYWxsYmFjaywgYXJncyk7XG4gIGltbWVkaWF0ZVF1ZXVlLnB1c2goaW1tZWRpYXRlKTtcblxuICBpZiAoIWRyYWluUXVldWVzVGltZW91dCkge1xuICAgIGRyYWluUXVldWVzVGltZW91dCA9IHNldFRpbWVvdXQoZHJhaW5RdWV1ZXMsIDApO1xuICB9XG5cbiAgcmV0dXJuIGltbWVkaWF0ZTtcbn07XG5cbmdsb2JhbC5jbGVhckltbWVkaWF0ZSA9IGZ1bmN0aW9uIChpbW1lZGlhdGUpIHtcbiAgdmFyIGluZGV4ID0gaW1tZWRpYXRlUXVldWUuaW5kZXhPZihpbW1lZGlhdGUpO1xuXG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBpbW1lZGlhdGVRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59O1xuXG52YXIgRk9SV0FSRF9TTEFTSCA9IDQ3OyAvLyAnLydcblxudmFyIEJBQ0tXQVJEX1NMQVNIID0gOTI7IC8vICdcXFxcJ1xuXG4vKipcbiAqIElzIHRoaXMgW2EtekEtWl0/XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBjaGFyQ29kZSB2YWx1ZSBmcm9tIFN0cmluZy5jaGFyQ29kZUF0KClcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5mdW5jdGlvbiBpc1dpbmRvd3NEZXZpY2VOYW1lKGNoYXJDb2RlKSB7XG4gIHJldHVybiBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA5MCB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMjI7XG59XG4vKipcbiAqIFtpc0Fic29sdXRlIGRlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gaXNQb3NpeCB3aGV0aGVyIHRoaXMgaW1wbCBpcyBmb3IgUE9TSVggb3Igbm90XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoICAgaW5wdXQgZmlsZSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cblxuXG5mdW5jdGlvbiBpc0Fic29sdXRlKGlzUG9zaXgsIGZpbGVwYXRoKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmaWxlcGF0aCwgJ3BhdGgnLCAnc3RyaW5nJyk7XG4gIHZhciBsZW5ndGggPSBmaWxlcGF0aC5sZW5ndGg7IC8vIGVtcHR5IHN0cmluZyBzcGVjaWFsIGNhc2VcblxuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGZpcnN0Q2hhciA9IGZpbGVwYXRoLmNoYXJDb2RlQXQoMCk7XG5cbiAgaWYgKGZpcnN0Q2hhciA9PT0gRk9SV0FSRF9TTEFTSCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIHdlIGFscmVhZHkgZGlkIG91ciBjaGVja3MgZm9yIHBvc2l4XG5cblxuICBpZiAoaXNQb3NpeCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyB3aW4zMiBmcm9tIGhlcmUgb24gb3V0XG5cblxuICBpZiAoZmlyc3RDaGFyID09PSBCQUNLV0FSRF9TTEFTSCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGxlbmd0aCA+IDIgJiYgaXNXaW5kb3dzRGV2aWNlTmFtZShmaXJzdENoYXIpICYmIGZpbGVwYXRoLmNoYXJBdCgxKSA9PT0gJzonKSB7XG4gICAgdmFyIHRoaXJkQ2hhciA9IGZpbGVwYXRoLmNoYXJBdCgyKTtcbiAgICByZXR1cm4gdGhpcmRDaGFyID09PSAnLycgfHwgdGhpcmRDaGFyID09PSAnXFxcXCc7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFtkaXJuYW1lIGRlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoICAgaW5wdXQgZmlsZSBwYXRoXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gZGlybmFtZShzZXBhcmF0b3IsIGZpbGVwYXRoKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmaWxlcGF0aCwgJ3BhdGgnLCAnc3RyaW5nJyk7XG4gIHZhciBsZW5ndGggPSBmaWxlcGF0aC5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnLic7XG4gIH0gLy8gaWdub3JlIHRyYWlsaW5nIHNlcGFyYXRvclxuXG5cbiAgdmFyIGZyb21JbmRleCA9IGxlbmd0aCAtIDE7XG4gIHZhciBoYWRUcmFpbGluZyA9IGZpbGVwYXRoLmVuZHNXaXRoKHNlcGFyYXRvcik7XG5cbiAgaWYgKGhhZFRyYWlsaW5nKSB7XG4gICAgZnJvbUluZGV4LS07XG4gIH1cblxuICB2YXIgZm91bmRJbmRleCA9IGZpbGVwYXRoLmxhc3RJbmRleE9mKHNlcGFyYXRvciwgZnJvbUluZGV4KTsgLy8gbm8gc2VwYXJhdG9yc1xuXG4gIGlmIChmb3VuZEluZGV4ID09PSAtMSkge1xuICAgIC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2Ygcm9vdCB3aW5kb3dzIHBhdGhzXG4gICAgaWYgKGxlbmd0aCA+PSAyICYmIHNlcGFyYXRvciA9PT0gJ1xcXFwnICYmIGZpbGVwYXRoLmNoYXJBdCgxKSA9PT0gJzonKSB7XG4gICAgICB2YXIgZmlyc3RDaGFyID0gZmlsZXBhdGguY2hhckNvZGVBdCgwKTtcblxuICAgICAgaWYgKGlzV2luZG93c0RldmljZU5hbWUoZmlyc3RDaGFyKSkge1xuICAgICAgICByZXR1cm4gZmlsZXBhdGg7IC8vIGl0J3MgYSByb290IHdpbmRvd3MgcGF0aFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnLic7XG4gIH0gLy8gb25seSBmb3VuZCByb290IHNlcGFyYXRvclxuXG5cbiAgaWYgKGZvdW5kSW5kZXggPT09IDApIHtcbiAgICByZXR1cm4gc2VwYXJhdG9yOyAvLyBpZiBpdCB3YXMgJy8nLCByZXR1cm4gdGhhdFxuICB9IC8vIEhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgJy8vc29tZXRoaW5nJ1xuXG5cbiAgaWYgKGZvdW5kSW5kZXggPT09IDEgJiYgc2VwYXJhdG9yID09PSAnLycgJiYgZmlsZXBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZXR1cm4gJy8vJztcbiAgfVxuXG4gIHJldHVybiBmaWxlcGF0aC5zbGljZSgwLCBmb3VuZEluZGV4KTtcbn1cbi8qKlxuICogW2V4dG5hbWUgZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciAgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZXBhdGggICBpbnB1dCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cblxuXG5mdW5jdGlvbiBleHRuYW1lKHNlcGFyYXRvciwgZmlsZXBhdGgpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZpbGVwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcbiAgdmFyIGluZGV4ID0gZmlsZXBhdGgubGFzdEluZGV4T2YoJy4nKTtcblxuICBpZiAoaW5kZXggPT09IC0xIHx8IGluZGV4ID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9IC8vIGlnbm9yZSB0cmFpbGluZyBzZXBhcmF0b3JcblxuXG4gIHZhciBlbmRJbmRleCA9IGZpbGVwYXRoLmxlbmd0aDtcblxuICBpZiAoZmlsZXBhdGguZW5kc1dpdGgoc2VwYXJhdG9yKSkge1xuICAgIGVuZEluZGV4LS07XG4gIH1cblxuICByZXR1cm4gZmlsZXBhdGguc2xpY2UoaW5kZXgsIGVuZEluZGV4KTtcbn1cblxuZnVuY3Rpb24gbGFzdEluZGV4V2luMzJTZXBhcmF0b3IoZmlsZXBhdGgsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgY2hhciA9IGZpbGVwYXRoLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoY2hhciA9PT0gQkFDS1dBUkRfU0xBU0ggfHwgY2hhciA9PT0gRk9SV0FSRF9TTEFTSCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiBbYmFzZW5hbWUgZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciAgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZXBhdGggICBpbnB1dCBmaWxlIHBhdGhcbiAqIEBwYXJhbSAge3N0cmluZ30gW2V4dF0gICAgICBmaWxlIGV4dGVuc2lvbiB0byBkcm9wIGlmIGl0IGV4aXN0c1xuICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5cbmZ1bmN0aW9uIGJhc2VuYW1lKHNlcGFyYXRvciwgZmlsZXBhdGgsIGV4dCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoZmlsZXBhdGgsICdwYXRoJywgJ3N0cmluZycpO1xuXG4gIGlmIChleHQgIT09IHVuZGVmaW5lZCkge1xuICAgIGFzc2VydEFyZ3VtZW50VHlwZShleHQsICdleHQnLCAnc3RyaW5nJyk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gZmlsZXBhdGgubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaXNQb3NpeCA9IHNlcGFyYXRvciA9PT0gJy8nO1xuICB2YXIgZW5kSW5kZXggPSBsZW5ndGg7IC8vIGRyb3AgdHJhaWxpbmcgc2VwYXJhdG9yIChpZiB0aGVyZSBpcyBvbmUpXG5cbiAgdmFyIGxhc3RDaGFyQ29kZSA9IGZpbGVwYXRoLmNoYXJDb2RlQXQobGVuZ3RoIC0gMSk7XG5cbiAgaWYgKGxhc3RDaGFyQ29kZSA9PT0gRk9SV0FSRF9TTEFTSCB8fCAhaXNQb3NpeCAmJiBsYXN0Q2hhckNvZGUgPT09IEJBQ0tXQVJEX1NMQVNIKSB7XG4gICAgZW5kSW5kZXgtLTtcbiAgfSAvLyBGaW5kIGxhc3Qgb2NjdXJlbmNlIG9mIHNlcGFyYXRvclxuXG5cbiAgdmFyIGxhc3RJbmRleCA9IC0xO1xuXG4gIGlmIChpc1Bvc2l4KSB7XG4gICAgbGFzdEluZGV4ID0gZmlsZXBhdGgubGFzdEluZGV4T2Yoc2VwYXJhdG9yLCBlbmRJbmRleCAtIDEpO1xuICB9IGVsc2Uge1xuICAgIC8vIE9uIHdpbjMyLCBoYW5kbGUgKmVpdGhlciogc2VwYXJhdG9yIVxuICAgIGxhc3RJbmRleCA9IGxhc3RJbmRleFdpbjMyU2VwYXJhdG9yKGZpbGVwYXRoLCBlbmRJbmRleCAtIDEpOyAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIHJvb3QgcGF0aCBsaWtlICdDOicgb3IgJ0M6XFxcXCdcblxuICAgIGlmICgobGFzdEluZGV4ID09PSAyIHx8IGxhc3RJbmRleCA9PT0gLTEpICYmIGZpbGVwYXRoLmNoYXJBdCgxKSA9PT0gJzonICYmIGlzV2luZG93c0RldmljZU5hbWUoZmlsZXBhdGguY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH0gLy8gVGFrZSBmcm9tIGxhc3Qgb2NjdXJyZW5jZSBvZiBzZXBhcmF0b3IgdG8gZW5kIG9mIHN0cmluZyAob3IgYmVnaW5uaW5nIHRvIGVuZCBpZiBub3QgZm91bmQpXG5cblxuICB2YXIgYmFzZSA9IGZpbGVwYXRoLnNsaWNlKGxhc3RJbmRleCArIDEsIGVuZEluZGV4KTsgLy8gZHJvcCB0cmFpbGluZyBleHRlbnNpb24gKGlmIHNwZWNpZmllZClcblxuICBpZiAoZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIHJldHVybiBiYXNlLmVuZHNXaXRoKGV4dCkgPyBiYXNlLnNsaWNlKDAsIGJhc2UubGVuZ3RoIC0gZXh0Lmxlbmd0aCkgOiBiYXNlO1xufVxuLyoqXG4gKiBUaGUgYHBhdGgubm9ybWFsaXplKClgIG1ldGhvZCBub3JtYWxpemVzIHRoZSBnaXZlbiBwYXRoLCByZXNvbHZpbmcgJy4uJyBhbmQgJy4nIHNlZ21lbnRzLlxuICpcbiAqIFdoZW4gbXVsdGlwbGUsIHNlcXVlbnRpYWwgcGF0aCBzZWdtZW50IHNlcGFyYXRpb24gY2hhcmFjdGVycyBhcmUgZm91bmQgKGUuZy5cbiAqIC8gb24gUE9TSVggYW5kIGVpdGhlciBcXCBvciAvIG9uIFdpbmRvd3MpLCB0aGV5IGFyZSByZXBsYWNlZCBieSBhIHNpbmdsZVxuICogaW5zdGFuY2Ugb2YgdGhlIHBsYXRmb3JtLXNwZWNpZmljIHBhdGggc2VnbWVudCBzZXBhcmF0b3IgKC8gb24gUE9TSVggYW5kIFxcXG4gKiBvbiBXaW5kb3dzKS4gVHJhaWxpbmcgc2VwYXJhdG9ycyBhcmUgcHJlc2VydmVkLlxuICpcbiAqIElmIHRoZSBwYXRoIGlzIGEgemVyby1sZW5ndGggc3RyaW5nLCAnLicgaXMgcmV0dXJuZWQsIHJlcHJlc2VudGluZyB0aGVcbiAqIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoICBpbnB1dCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZ30gW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplJDEoc2VwYXJhdG9yLCBmaWxlcGF0aCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoZmlsZXBhdGgsICdwYXRoJywgJ3N0cmluZycpO1xuXG4gIGlmIChmaWxlcGF0aC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJy4nO1xuICB9IC8vIFdpbmRvd3MgY2FuIGhhbmRsZSAnLycgb3IgJ1xcXFwnIGFuZCBib3RoIHNob3VsZCBiZSB0dXJuZWQgaW50byBzZXBhcmF0b3JcblxuXG4gIHZhciBpc1dpbmRvd3MgPSBzZXBhcmF0b3IgPT09ICdcXFxcJztcblxuICBpZiAoaXNXaW5kb3dzKSB7XG4gICAgZmlsZXBhdGggPSBmaWxlcGF0aC5yZXBsYWNlKC9cXC8vZywgc2VwYXJhdG9yKTtcbiAgfVxuXG4gIHZhciBoYWRMZWFkaW5nID0gZmlsZXBhdGguc3RhcnRzV2l0aChzZXBhcmF0b3IpOyAvLyBPbiBXaW5kb3dzLCBuZWVkIHRvIGhhbmRsZSBVTkMgcGF0aHMgKFxcXFxob3N0LW5hbWVcXFxccmVzb3VyY2VcXFxcZGlyKSBzcGVjaWFsIHRvIHJldGFpbiBsZWFkaW5nIGRvdWJsZSBiYWNrc2xhc2hcblxuICB2YXIgaXNVTkMgPSBoYWRMZWFkaW5nICYmIGlzV2luZG93cyAmJiBmaWxlcGF0aC5sZW5ndGggPiAyICYmIGZpbGVwYXRoLmNoYXJBdCgxKSA9PT0gJ1xcXFwnO1xuICB2YXIgaGFkVHJhaWxpbmcgPSBmaWxlcGF0aC5lbmRzV2l0aChzZXBhcmF0b3IpO1xuICB2YXIgcGFydHMgPSBmaWxlcGF0aC5zcGxpdChzZXBhcmF0b3IpO1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIgc2VnbWVudCBvZiBwYXJ0cykge1xuICAgIGlmIChzZWdtZW50Lmxlbmd0aCAhPT0gMCAmJiBzZWdtZW50ICE9PSAnLicpIHtcbiAgICAgIGlmIChzZWdtZW50ID09PSAnLi4nKSB7XG4gICAgICAgIHJlc3VsdC5wb3AoKTsgLy8gRklYTUU6IFdoYXQgaWYgdGhpcyBnb2VzIGFib3ZlIHJvb3Q/IFNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvcj9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHNlZ21lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBub3JtYWxpemVkID0gaGFkTGVhZGluZyA/IHNlcGFyYXRvciA6ICcnO1xuICBub3JtYWxpemVkICs9IHJlc3VsdC5qb2luKHNlcGFyYXRvcik7XG5cbiAgaWYgKGhhZFRyYWlsaW5nKSB7XG4gICAgbm9ybWFsaXplZCArPSBzZXBhcmF0b3I7XG4gIH1cblxuICBpZiAoaXNVTkMpIHtcbiAgICBub3JtYWxpemVkID0gJ1xcXFwnICsgbm9ybWFsaXplZDtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuLyoqXG4gKiBbYXNzZXJ0U2VnbWVudCBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAgeyp9IHNlZ21lbnQgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7dm9pZH0gICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnRTZWdtZW50KHNlZ21lbnQpIHtcbiAgaWYgKHR5cGVvZiBzZWdtZW50ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXRoIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkIFwiLmNvbmNhdChzZWdtZW50KSk7XG4gIH1cbn1cbi8qKlxuICogVGhlIGBwYXRoLmpvaW4oKWAgbWV0aG9kIGpvaW5zIGFsbCBnaXZlbiBwYXRoIHNlZ21lbnRzIHRvZ2V0aGVyIHVzaW5nIHRoZVxuICogcGxhdGZvcm0tc3BlY2lmaWMgc2VwYXJhdG9yIGFzIGEgZGVsaW1pdGVyLCB0aGVuIG5vcm1hbGl6ZXMgdGhlIHJlc3VsdGluZyBwYXRoLlxuICogWmVyby1sZW5ndGggcGF0aCBzZWdtZW50cyBhcmUgaWdub3JlZC4gSWYgdGhlIGpvaW5lZCBwYXRoIHN0cmluZyBpcyBhIHplcm8tXG4gKiBsZW5ndGggc3RyaW5nIHRoZW4gJy4nIHdpbGwgYmUgcmV0dXJuZWQsIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSAge3N0cmluZ30gc2VwYXJhdG9yIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmdbXX0gcGF0aHMgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICBUaGUgam9pbmVkIGZpbGVwYXRoXG4gKi9cblxuXG5mdW5jdGlvbiBqb2luJDEoc2VwYXJhdG9yLCBwYXRocykge1xuICB2YXIgcmVzdWx0ID0gW107IC8vIG5haXZlIGltcGw6IGp1c3Qgam9pbiBhbGwgdGhlIHBhdGhzIHdpdGggc2VwYXJhdG9yXG5cbiAgZm9yICh2YXIgc2VnbWVudCBvZiBwYXRocykge1xuICAgIGFzc2VydFNlZ21lbnQoc2VnbWVudCk7XG5cbiAgICBpZiAoc2VnbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemUkMShzZXBhcmF0b3IsIHJlc3VsdC5qb2luKHNlcGFyYXRvcikpO1xufVxuLyoqXG4gKiBUaGUgYHBhdGgucmVzb2x2ZSgpYCBtZXRob2QgcmVzb2x2ZXMgYSBzZXF1ZW5jZSBvZiBwYXRocyBvciBwYXRoIHNlZ21lbnRzIGludG8gYW4gYWJzb2x1dGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nW119IHBhdGhzIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gcmVzb2x2ZShzZXBhcmF0b3IsIHBhdGhzKSB7XG4gIHZhciByZXNvbHZlZCA9ICcnO1xuICB2YXIgaGl0Um9vdCA9IGZhbHNlO1xuICB2YXIgaXNQb3NpeCA9IHNlcGFyYXRvciA9PT0gJy8nOyAvLyBnbyBmcm9tIHJpZ2h0IHRvIGxlZnQgdW50aWwgd2UgaGl0IGFic29sdXRlIHBhdGgvcm9vdFxuXG4gIGZvciAodmFyIGkgPSBwYXRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBzZWdtZW50ID0gcGF0aHNbaV07XG4gICAgYXNzZXJ0U2VnbWVudChzZWdtZW50KTtcblxuICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udGludWU7IC8vIHNraXAgZW1wdHlcbiAgICB9XG5cbiAgICByZXNvbHZlZCA9IHNlZ21lbnQgKyBzZXBhcmF0b3IgKyByZXNvbHZlZDsgLy8gcHJlcGVuZCBuZXcgc2VnbWVudFxuXG4gICAgaWYgKGlzQWJzb2x1dGUoaXNQb3NpeCwgc2VnbWVudCkpIHtcbiAgICAgIC8vIGhhdmUgd2UgYmFja2VkIGludG8gYW4gYWJzb2x1dGUgcGF0aD9cbiAgICAgIGhpdFJvb3QgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9IC8vIGlmIHdlIGRpZG4ndCBoaXQgcm9vdCwgcHJlcGVuZCBjd2RcblxuXG4gIGlmICghaGl0Um9vdCkge1xuICAgIHJlc29sdmVkID0gcHJvY2Vzcy5jd2QoKSArIHNlcGFyYXRvciArIHJlc29sdmVkO1xuICB9XG5cbiAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemUkMShzZXBhcmF0b3IsIHJlc29sdmVkKTtcblxuICBpZiAobm9ybWFsaXplZC5jaGFyQXQobm9ybWFsaXplZC5sZW5ndGggLSAxKSA9PT0gc2VwYXJhdG9yKSB7XG4gICAgLy8gRklYTUU6IEhhbmRsZSBVTkMgcGF0aHMgb24gV2luZG93cyBhcyB3ZWxsLCBzbyB3ZSBkb24ndCB0cmltIHRyYWlsaW5nIHNlcGFyYXRvciBvbiBzb21ldGhpbmcgbGlrZSAnXFxcXFxcXFxob3N0LW5hbWVcXFxccmVzb3VyY2VcXFxcJ1xuICAgIC8vIERvbid0IHJlbW92ZSB0cmFpbGluZyBzZXBhcmF0b3IgaWYgdGhpcyBpcyByb290IHBhdGggb24gd2luZG93cyFcbiAgICBpZiAoIWlzUG9zaXggJiYgbm9ybWFsaXplZC5sZW5ndGggPT09IDMgJiYgbm9ybWFsaXplZC5jaGFyQXQoMSkgPT09ICc6JyAmJiBpc1dpbmRvd3NEZXZpY2VOYW1lKG5vcm1hbGl6ZWQuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH0gLy8gb3RoZXJ3aXNlIHRyaW0gdHJhaWxpbmcgc2VwYXJhdG9yXG5cblxuICAgIHJldHVybiBub3JtYWxpemVkLnNsaWNlKDAsIG5vcm1hbGl6ZWQubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbi8qKlxuICogVGhlIGBwYXRoLnJlbGF0aXZlKClgIG1ldGhvZCByZXR1cm5zIHRoZSByZWxhdGl2ZSBwYXRoIGBmcm9tYCBmcm9tIHRvIGB0b2AgYmFzZWRcbiAqIG9uIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBJZiBmcm9tIGFuZCB0byBlYWNoIHJlc29sdmUgdG8gdGhlIHNhbWVcbiAqIHBhdGggKGFmdGVyIGNhbGxpbmcgYHBhdGgucmVzb2x2ZSgpYCBvbiBlYWNoKSwgYSB6ZXJvLWxlbmd0aCBzdHJpbmcgaXMgcmV0dXJuZWQuXG4gKlxuICogSWYgYSB6ZXJvLWxlbmd0aCBzdHJpbmcgaXMgcGFzc2VkIGFzIGBmcm9tYCBvciBgdG9gLCB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeVxuICogd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIHplcm8tbGVuZ3RoIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ30gZnJvbSBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRvICAgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbGF0aXZlKHNlcGFyYXRvciwgZnJvbSwgdG8pIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZyb20sICdmcm9tJywgJ3N0cmluZycpO1xuICBhc3NlcnRBcmd1bWVudFR5cGUodG8sICd0bycsICdzdHJpbmcnKTtcblxuICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBmcm9tID0gcmVzb2x2ZShzZXBhcmF0b3IsIFtmcm9tXSk7XG4gIHRvID0gcmVzb2x2ZShzZXBhcmF0b3IsIFt0b10pO1xuXG4gIGlmIChmcm9tID09PSB0bykge1xuICAgIHJldHVybiAnJztcbiAgfSAvLyB3ZSBub3cgaGF2ZSB0d28gYWJzb2x1dGUgcGF0aHMsXG4gIC8vIGxldHMgXCJnbyB1cFwiIGZyb20gYGZyb21gIHVudGlsIHdlIHJlYWNoIGNvbW1vbiBiYXNlIGRpciBvZiBgdG9gXG4gIC8vIGNvbnN0IG9yaWdpbmFsRnJvbSA9IGZyb207XG5cblxuICB2YXIgdXBDb3VudCA9IDA7XG4gIHZhciByZW1haW5pbmdQYXRoID0gJyc7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAodG8uc3RhcnRzV2l0aChmcm9tKSkge1xuICAgICAgLy8gbWF0Y2ghIHJlY29yZCByZXN0Li4uP1xuICAgICAgcmVtYWluaW5nUGF0aCA9IHRvLnNsaWNlKGZyb20ubGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gRklYTUU6IEJyZWFrL3Rocm93IGlmIHdlIGhpdCBiYWQgZWRnZSBjYXNlIG9mIG5vIGNvbW1vbiByb290IVxuXG5cbiAgICBmcm9tID0gZGlybmFtZShzZXBhcmF0b3IsIGZyb20pO1xuICAgIHVwQ291bnQrKztcbiAgfSAvLyByZW1vdmUgbGVhZGluZyBzZXBhcmF0b3IgZnJvbSByZW1haW5pbmdQYXRoIGlmIHRoZXJlIGlzIGFueVxuXG5cbiAgaWYgKHJlbWFpbmluZ1BhdGgubGVuZ3RoID4gMCkge1xuICAgIHJlbWFpbmluZ1BhdGggPSByZW1haW5pbmdQYXRoLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuICgnLi4nICsgc2VwYXJhdG9yKS5yZXBlYXQodXBDb3VudCkgKyByZW1haW5pbmdQYXRoO1xufVxuLyoqXG4gKiBUaGUgYHBhdGgucGFyc2UoKWAgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgcmVwcmVzZW50XG4gKiBzaWduaWZpY2FudCBlbGVtZW50cyBvZiB0aGUgcGF0aC4gVHJhaWxpbmcgZGlyZWN0b3J5IHNlcGFyYXRvcnMgYXJlIGlnbm9yZWQsXG4gKiBzZWUgYHBhdGguc2VwYC5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgb2JqZWN0IHdpbGwgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogLSBkaXIgPHN0cmluZz5cbiAqIC0gcm9vdCA8c3RyaW5nPlxuICogLSBiYXNlIDxzdHJpbmc+XG4gKiAtIG5hbWUgPHN0cmluZz5cbiAqIC0gZXh0IDxzdHJpbmc+XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlcGF0aCBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZShzZXBhcmF0b3IsIGZpbGVwYXRoKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmaWxlcGF0aCwgJ3BhdGgnLCAnc3RyaW5nJyk7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgcm9vdDogJycsXG4gICAgZGlyOiAnJyxcbiAgICBiYXNlOiAnJyxcbiAgICBleHQ6ICcnLFxuICAgIG5hbWU6ICcnXG4gIH07XG4gIHZhciBsZW5ndGggPSBmaWxlcGF0aC5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gLy8gQ2hlYXQgYW5kIGp1c3QgY2FsbCBvdXIgb3RoZXIgbWV0aG9kcyBmb3IgZGlybmFtZS9iYXNlbmFtZS9leHRuYW1lP1xuXG5cbiAgcmVzdWx0LmJhc2UgPSBiYXNlbmFtZShzZXBhcmF0b3IsIGZpbGVwYXRoKTtcbiAgcmVzdWx0LmV4dCA9IGV4dG5hbWUoc2VwYXJhdG9yLCByZXN1bHQuYmFzZSk7XG4gIHZhciBiYXNlTGVuZ3RoID0gcmVzdWx0LmJhc2UubGVuZ3RoO1xuICByZXN1bHQubmFtZSA9IHJlc3VsdC5iYXNlLnNsaWNlKDAsIGJhc2VMZW5ndGggLSByZXN1bHQuZXh0Lmxlbmd0aCk7XG4gIHZhciB0b1N1YnRyYWN0ID0gYmFzZUxlbmd0aCA9PT0gMCA/IDAgOiBiYXNlTGVuZ3RoICsgMTtcbiAgcmVzdWx0LmRpciA9IGZpbGVwYXRoLnNsaWNlKDAsIGZpbGVwYXRoLmxlbmd0aCAtIHRvU3VidHJhY3QpOyAvLyBkcm9wIHRyYWlsaW5nIHNlcGFyYXRvciFcblxuICB2YXIgZmlyc3RDaGFyQ29kZSA9IGZpbGVwYXRoLmNoYXJDb2RlQXQoMCk7IC8vIGJvdGggd2luMzIgYW5kIFBPU0lYIHJldHVybiAnLycgcm9vdFxuXG4gIGlmIChmaXJzdENoYXJDb2RlID09PSBGT1JXQVJEX1NMQVNIKSB7XG4gICAgcmVzdWx0LnJvb3QgPSAnLyc7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSAvLyB3ZSdyZSBkb25lIHdpdGggUE9TSVguLi5cblxuXG4gIGlmIChzZXBhcmF0b3IgPT09ICcvJykge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gLy8gZm9yIHdpbjMyLi4uXG5cblxuICBpZiAoZmlyc3RDaGFyQ29kZSA9PT0gQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAvLyBGSVhNRTogSGFuZGxlIFVOQyBwYXRocyBsaWtlICdcXFxcXFxcXGhvc3QtbmFtZVxcXFxyZXNvdXJjZVxcXFxmaWxlX3BhdGgnXG4gICAgLy8gbmVlZCB0byByZXRhaW4gJ1xcXFxcXFxcaG9zdC1uYW1lXFxcXHJlc291cmNlXFxcXCcgYXMgcm9vdCBpbiB0aGF0IGNhc2UhXG4gICAgcmVzdWx0LnJvb3QgPSAnXFxcXCc7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSAvLyBjaGVjayBmb3IgQzogc3R5bGUgcm9vdFxuXG5cbiAgaWYgKGxlbmd0aCA+IDEgJiYgaXNXaW5kb3dzRGV2aWNlTmFtZShmaXJzdENoYXJDb2RlKSAmJiBmaWxlcGF0aC5jaGFyQXQoMSkgPT09ICc6Jykge1xuICAgIGlmIChsZW5ndGggPiAyKSB7XG4gICAgICAvLyBpcyBpdCBsaWtlIEM6XFxcXD9cbiAgICAgIHZhciB0aGlyZENoYXJDb2RlID0gZmlsZXBhdGguY2hhckNvZGVBdCgyKTtcblxuICAgICAgaWYgKHRoaXJkQ2hhckNvZGUgPT09IEZPUldBUkRfU0xBU0ggfHwgdGhpcmRDaGFyQ29kZSA9PT0gQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgICAgcmVzdWx0LnJvb3QgPSBmaWxlcGF0aC5zbGljZSgwLCAzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9IC8vIG5vcGUsIGp1c3QgQzosIG5vIHRyYWlsaW5nIHNlcGFyYXRvclxuXG5cbiAgICByZXN1bHQucm9vdCA9IGZpbGVwYXRoLnNsaWNlKDAsIDIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogVGhlIGBwYXRoLmZvcm1hdCgpYCBtZXRob2QgcmV0dXJucyBhIHBhdGggc3RyaW5nIGZyb20gYW4gb2JqZWN0LiBUaGlzIGlzIHRoZVxuICogb3Bwb3NpdGUgb2YgYHBhdGgucGFyc2UoKWAuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge29iamVjdH0gcGF0aE9iamVjdCBvYmplY3Qgb2YgZm9ybWF0IHJldHVybmVkIGJ5IGBwYXRoLnBhcnNlKClgXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGhPYmplY3QuZGlyIGRpcmVjdG9yeSBuYW1lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGhPYmplY3Qucm9vdCBmaWxlIHJvb3QgZGlyLCBpZ25vcmVkIGlmIGBwYXRoT2JqZWN0LmRpcmAgaXMgcHJvdmlkZWRcbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aE9iamVjdC5iYXNlIGZpbGUgYmFzZW5hbWVcbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aE9iamVjdC5uYW1lIGJhc2VuYW1lIG1pbnVzIGV4dGVuc2lvbiwgaWdub3JlZCBpZiBgcGF0aE9iamVjdC5iYXNlYCBleGlzdHNcbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aE9iamVjdC5leHQgZmlsZSBleHRlbnNpb24sIGlnbm9yZWQgaWYgYHBhdGhPYmplY3QuYmFzZWAgZXhpc3RzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXQkMShzZXBhcmF0b3IsIHBhdGhPYmplY3QpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKHBhdGhPYmplY3QsICdwYXRoT2JqZWN0JywgJ29iamVjdCcpO1xuICB2YXIgYmFzZSA9IHBhdGhPYmplY3QuYmFzZSB8fCBcIlwiLmNvbmNhdChwYXRoT2JqZWN0Lm5hbWUgfHwgJycpLmNvbmNhdChwYXRoT2JqZWN0LmV4dCB8fCAnJyk7IC8vIGFwcGVuZCBiYXNlIHRvIHJvb3QgaWYgYGRpcmAgd2Fzbid0IHNwZWNpZmllZCwgb3IgaWZcbiAgLy8gZGlyIGlzIHRoZSByb290XG5cbiAgaWYgKCFwYXRoT2JqZWN0LmRpciB8fCBwYXRoT2JqZWN0LmRpciA9PT0gcGF0aE9iamVjdC5yb290KSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHBhdGhPYmplY3Qucm9vdCB8fCAnJykuY29uY2F0KGJhc2UpO1xuICB9IC8vIGNvbWJpbmUgZGlyICsgLyArIGJhc2VcblxuXG4gIHJldHVybiBcIlwiLmNvbmNhdChwYXRoT2JqZWN0LmRpcikuY29uY2F0KHNlcGFyYXRvcikuY29uY2F0KGJhc2UpO1xufVxuLyoqXG4gKiBPbiBXaW5kb3dzIHN5c3RlbXMgb25seSwgcmV0dXJucyBhbiBlcXVpdmFsZW50IG5hbWVzcGFjZS1wcmVmaXhlZCBwYXRoIGZvclxuICogdGhlIGdpdmVuIHBhdGguIElmIHBhdGggaXMgbm90IGEgc3RyaW5nLCBwYXRoIHdpbGwgYmUgcmV0dXJuZWQgd2l0aG91dCBtb2RpZmljYXRpb25zLlxuICogU2VlIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3dpbmRvd3MvZGVza3RvcC9GaWxlSU8vbmFtaW5nLWEtZmlsZSNuYW1lc3BhY2VzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gdG9OYW1lc3BhY2VkUGF0aChmaWxlcGF0aCkge1xuICBpZiAodHlwZW9mIGZpbGVwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmaWxlcGF0aDtcbiAgfVxuXG4gIGlmIChmaWxlcGF0aC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgcmVzb2x2ZWRQYXRoID0gcmVzb2x2ZSgnXFxcXCcsIFtmaWxlcGF0aF0pO1xuICB2YXIgbGVuZ3RoID0gcmVzb2x2ZWRQYXRoLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgMikge1xuICAgIC8vIG5lZWQgJ1xcXFxcXFxcJyBvciAnQzonIG1pbmltdW1cbiAgICByZXR1cm4gZmlsZXBhdGg7XG4gIH1cblxuICB2YXIgZmlyc3RDaGFyQ29kZSA9IHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDApOyAvLyBpZiBzdGFydCB3aXRoICdcXFxcXFxcXCcsIHByZWZpeCB3aXRoIFVOQyByb290LCBkcm9wIHRoZSBzbGFzaGVzXG5cbiAgaWYgKGZpcnN0Q2hhckNvZGUgPT09IEJBQ0tXQVJEX1NMQVNIICYmIHJlc29sdmVkUGF0aC5jaGFyQXQoMSkgPT09ICdcXFxcJykge1xuICAgIC8vIHJldHVybiBhcy1pcyBpZiBpdCdzIGFuIGFyZWFkeSBsb25nIHBhdGggKCdcXFxcXFxcXD9cXFxcJyBvciAnXFxcXFxcXFwuXFxcXCcgcHJlZml4KVxuICAgIGlmIChsZW5ndGggPj0gMykge1xuICAgICAgdmFyIHRoaXJkQ2hhciA9IHJlc29sdmVkUGF0aC5jaGFyQXQoMik7XG5cbiAgICAgIGlmICh0aGlyZENoYXIgPT09ICc/JyB8fCB0aGlyZENoYXIgPT09ICcuJykge1xuICAgICAgICByZXR1cm4gZmlsZXBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICdcXFxcXFxcXD9cXFxcVU5DXFxcXCcgKyByZXNvbHZlZFBhdGguc2xpY2UoMik7XG4gIH0gZWxzZSBpZiAoaXNXaW5kb3dzRGV2aWNlTmFtZShmaXJzdENoYXJDb2RlKSAmJiByZXNvbHZlZFBhdGguY2hhckF0KDEpID09PSAnOicpIHtcbiAgICByZXR1cm4gJ1xcXFxcXFxcP1xcXFwnICsgcmVzb2x2ZWRQYXRoO1xuICB9XG5cbiAgcmV0dXJuIGZpbGVwYXRoO1xufVxuXG52YXIgV2luMzJQYXRoID0ge1xuICBzZXA6ICdcXFxcJyxcbiAgZGVsaW1pdGVyOiAnOycsXG4gIGJhc2VuYW1lOiBmdW5jdGlvbiAoZmlsZXBhdGgsIGV4dCkge1xuICAgIHJldHVybiBiYXNlbmFtZSh0aGlzLnNlcCwgZmlsZXBhdGgsIGV4dCk7XG4gIH0sXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZSQxKHRoaXMuc2VwLCBmaWxlcGF0aCk7XG4gIH0sXG4gIGpvaW46IGZ1bmN0aW9uICguLi5wYXRocykge1xuICAgIHJldHVybiBqb2luJDEodGhpcy5zZXAsIHBhdGhzKTtcbiAgfSxcbiAgZXh0bmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGV4dG5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgZGlybmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGRpcm5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGlzQWJzb2x1dGUoZmFsc2UsIGZpbGVwYXRoKTtcbiAgfSxcbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgIHJldHVybiByZWxhdGl2ZSh0aGlzLnNlcCwgZnJvbSwgdG8pO1xuICB9LFxuICByZXNvbHZlOiBmdW5jdGlvbiAoLi4ucGF0aHMpIHtcbiAgICByZXR1cm4gcmVzb2x2ZSh0aGlzLnNlcCwgcGF0aHMpO1xuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIHBhcnNlKHRoaXMuc2VwLCBmaWxlcGF0aCk7XG4gIH0sXG4gIGZvcm1hdDogZnVuY3Rpb24gKHBhdGhPYmplY3QpIHtcbiAgICByZXR1cm4gZm9ybWF0JDEodGhpcy5zZXAsIHBhdGhPYmplY3QpO1xuICB9LFxuICB0b05hbWVzcGFjZWRQYXRoOiB0b05hbWVzcGFjZWRQYXRoXG59O1xudmFyIFBvc2l4UGF0aCA9IHtcbiAgc2VwOiAnLycsXG4gIGRlbGltaXRlcjogJzonLFxuICBiYXNlbmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoLCBleHQpIHtcbiAgICByZXR1cm4gYmFzZW5hbWUodGhpcy5zZXAsIGZpbGVwYXRoLCBleHQpO1xuICB9LFxuICBub3JtYWxpemU6IGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuICAgIHJldHVybiBub3JtYWxpemUkMSh0aGlzLnNlcCwgZmlsZXBhdGgpO1xuICB9LFxuICBqb2luOiBmdW5jdGlvbiAoLi4ucGF0aHMpIHtcbiAgICByZXR1cm4gam9pbiQxKHRoaXMuc2VwLCBwYXRocyk7XG4gIH0sXG4gIGV4dG5hbWU6IGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuICAgIHJldHVybiBleHRuYW1lKHRoaXMuc2VwLCBmaWxlcGF0aCk7XG4gIH0sXG4gIGRpcm5hbWU6IGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuICAgIHJldHVybiBkaXJuYW1lKHRoaXMuc2VwLCBmaWxlcGF0aCk7XG4gIH0sXG4gIGlzQWJzb2x1dGU6IGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuICAgIHJldHVybiBpc0Fic29sdXRlKHRydWUsIGZpbGVwYXRoKTtcbiAgfSxcbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgIHJldHVybiByZWxhdGl2ZSh0aGlzLnNlcCwgZnJvbSwgdG8pO1xuICB9LFxuICByZXNvbHZlOiBmdW5jdGlvbiAoLi4ucGF0aHMpIHtcbiAgICByZXR1cm4gcmVzb2x2ZSh0aGlzLnNlcCwgcGF0aHMpO1xuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIHBhcnNlKHRoaXMuc2VwLCBmaWxlcGF0aCk7XG4gIH0sXG4gIGZvcm1hdDogZnVuY3Rpb24gKHBhdGhPYmplY3QpIHtcbiAgICByZXR1cm4gZm9ybWF0JDEodGhpcy5zZXAsIHBhdGhPYmplY3QpO1xuICB9LFxuICB0b05hbWVzcGFjZWRQYXRoOiBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gZmlsZXBhdGg7IC8vIG5vLW9wXG4gIH1cbn07XG52YXIgcGF0aCQxID0gUG9zaXhQYXRoO1xucGF0aCQxLndpbjMyID0gV2luMzJQYXRoO1xucGF0aCQxLnBvc2l4ID0gUG9zaXhQYXRoO1xuXG52YXIgaXNBbmRyb2lkID0gVGkuUGxhdGZvcm0ub3NuYW1lID09PSAnYW5kcm9pZCc7XG52YXIgaXNJT1MgPSAhaXNBbmRyb2lkICYmIHRydWU7XG52YXIgUG9zaXhDb25zdGFudHMgPSB7XG4gIFVWX1VEUF9SRVVTRUFERFI6IDQsXG4gIGRsb3Blbjoge30sXG4gIGVycm5vOiB7XG4gICAgRTJCSUc6IDcsXG4gICAgRUFDQ0VTOiAxMyxcbiAgICBFQUREUklOVVNFOiA0OCxcbiAgICBFQUREUk5PVEFWQUlMOiA0OSxcbiAgICBFQUZOT1NVUFBPUlQ6IDQ3LFxuICAgIEVBR0FJTjogMzUsXG4gICAgRUFMUkVBRFk6IDM3LFxuICAgIEVCQURGOiA5LFxuICAgIEVCQURNU0c6IDk0LFxuICAgIEVCVVNZOiAxNixcbiAgICBFQ0FOQ0VMRUQ6IDg5LFxuICAgIEVDSElMRDogMTAsXG4gICAgRUNPTk5BQk9SVEVEOiA1MyxcbiAgICBFQ09OTlJFRlVTRUQ6IDYxLFxuICAgIEVDT05OUkVTRVQ6IDU0LFxuICAgIEVERUFETEs6IDExLFxuICAgIEVERVNUQUREUlJFUTogMzksXG4gICAgRURPTTogMzMsXG4gICAgRURRVU9UOiA2OSxcbiAgICBFRVhJU1Q6IDE3LFxuICAgIEVGQVVMVDogMTQsXG4gICAgRUZCSUc6IDI3LFxuICAgIEVIT1NUVU5SRUFDSDogNjUsXG4gICAgRUlEUk06IDkwLFxuICAgIEVJTFNFUTogOTIsXG4gICAgRUlOUFJPR1JFU1M6IDM2LFxuICAgIEVJTlRSOiA0LFxuICAgIEVJTlZBTDogMjIsXG4gICAgRUlPOiA1LFxuICAgIEVJU0NPTk46IDU2LFxuICAgIEVJU0RJUjogMjEsXG4gICAgRUxPT1A6IDYyLFxuICAgIEVNRklMRTogMjQsXG4gICAgRU1MSU5LOiAzMSxcbiAgICBFTVNHU0laRTogNDAsXG4gICAgRU1VTFRJSE9QOiA5NSxcbiAgICBFTkFNRVRPT0xPTkc6IDYzLFxuICAgIEVORVRET1dOOiA1MCxcbiAgICBFTkVUUkVTRVQ6IDUyLFxuICAgIEVORVRVTlJFQUNIOiA1MSxcbiAgICBFTkZJTEU6IDIzLFxuICAgIEVOT0JVRlM6IDU1LFxuICAgIEVOT0RBVEE6IDk2LFxuICAgIEVOT0RFVjogMTksXG4gICAgRU5PRU5UOiAyLFxuICAgIEVOT0VYRUM6IDgsXG4gICAgRU5PTENLOiA3NyxcbiAgICBFTk9MSU5LOiA5NyxcbiAgICBFTk9NRU06IDEyLFxuICAgIEVOT01TRzogOTEsXG4gICAgRU5PUFJPVE9PUFQ6IDQyLFxuICAgIEVOT1NQQzogMjgsXG4gICAgRU5PU1I6IDk4LFxuICAgIEVOT1NUUjogOTksXG4gICAgRU5PU1lTOiA3OCxcbiAgICBFTk9UQ09OTjogNTcsXG4gICAgRU5PVERJUjogMjAsXG4gICAgRU5PVEVNUFRZOiA2NixcbiAgICBFTk9UU09DSzogMzgsXG4gICAgRU5PVFNVUDogNDUsXG4gICAgRU5PVFRZOiAyNSxcbiAgICBFTlhJTzogNixcbiAgICBFT1BOT1RTVVBQOiAxMDIsXG4gICAgRU9WRVJGTE9XOiA4NCxcbiAgICBFUEVSTTogMSxcbiAgICBFUElQRTogMzIsXG4gICAgRVBST1RPOiAxMDAsXG4gICAgRVBST1RPTk9TVVBQT1JUOiA0MyxcbiAgICBFUFJPVE9UWVBFOiA0MSxcbiAgICBFUkFOR0U6IDM0LFxuICAgIEVST0ZTOiAzMCxcbiAgICBFU1BJUEU6IDI5LFxuICAgIEVTUkNIOiAzLFxuICAgIEVTVEFMRTogNzAsXG4gICAgRVRJTUU6IDEwMSxcbiAgICBFVElNRURPVVQ6IDYwLFxuICAgIEVUWFRCU1k6IDI2LFxuICAgIEVXT1VMREJMT0NLOiAzNSxcbiAgICBFWERFVjogMThcbiAgfSxcbiAgc2lnbmFsczoge1xuICAgIFNJR0hVUDogMSxcbiAgICBTSUdJTlQ6IDIsXG4gICAgU0lHUVVJVDogMyxcbiAgICBTSUdJTEw6IDQsXG4gICAgU0lHVFJBUDogNSxcbiAgICBTSUdBQlJUOiA2LFxuICAgIFNJR0lPVDogNixcbiAgICBTSUdCVVM6IDEwLFxuICAgIFNJR0ZQRTogOCxcbiAgICBTSUdLSUxMOiA5LFxuICAgIFNJR1VTUjE6IDMwLFxuICAgIFNJR1NFR1Y6IDExLFxuICAgIFNJR1VTUjI6IDMxLFxuICAgIFNJR1BJUEU6IDEzLFxuICAgIFNJR0FMUk06IDE0LFxuICAgIFNJR1RFUk06IDE1LFxuICAgIFNJR0NITEQ6IDIwLFxuICAgIFNJR0NPTlQ6IDE5LFxuICAgIFNJR1NUT1A6IDE3LFxuICAgIFNJR1RTVFA6IDE4LFxuICAgIFNJR1RUSU46IDIxLFxuICAgIFNJR1RUT1U6IDIyLFxuICAgIFNJR1VSRzogMTYsXG4gICAgU0lHWENQVTogMjQsXG4gICAgU0lHWEZTWjogMjUsXG4gICAgU0lHVlRBTFJNOiAyNixcbiAgICBTSUdQUk9GOiAyNyxcbiAgICBTSUdXSU5DSDogMjgsXG4gICAgU0lHSU86IDIzLFxuICAgIFNJR0lORk86IDI5LFxuICAgIFNJR1NZUzogMTJcbiAgfSxcbiAgcHJpb3JpdHk6IHtcbiAgICBQUklPUklUWV9MT1c6IDE5LFxuICAgIFBSSU9SSVRZX0JFTE9XX05PUk1BTDogMTAsXG4gICAgUFJJT1JJVFlfTk9STUFMOiAwLFxuICAgIFBSSU9SSVRZX0FCT1ZFX05PUk1BTDogLTcsXG4gICAgUFJJT1JJVFlfSElHSDogLTE0LFxuICAgIFBSSU9SSVRZX0hJR0hFU1Q6IC0yMFxuICB9XG59OyAvLyBkZWZhdWx0IGltcGxlbWVudGF0aW9uc1xuXG52YXIgT1MgPSB7XG4gIEVPTDogJ1xcbicsXG4gIGFyY2g6ICgpID0+IHByb2Nlc3MuYXJjaCxcbiAgY29uc3RhbnRzOiBQb3NpeENvbnN0YW50cyxcbiAgY3B1czogKCkgPT4ge1xuICAgIHZhciBjb3VudCA9IFRpLlBsYXRmb3JtLnByb2Nlc3NvckNvdW50O1xuICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBhcnJheS5wdXNoKHtcbiAgICAgICAgbW9kZWw6ICd1bmtub3duJyxcbiAgICAgICAgc3BlZWQ6IDAsXG4gICAgICAgIHRpbWVzOiB7XG4gICAgICAgICAgdXNlcjogMCxcbiAgICAgICAgICBuaWNlOiAwLFxuICAgICAgICAgIHN5czogMCxcbiAgICAgICAgICBpZGxlOiAwLFxuICAgICAgICAgIGlycTogMFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH0sXG4gIGVuZGlhbm5lc3M6ICgpID0+IHtcbiAgICAvLyBUT0RPOiBDYWNoZSB0aGUgdmFsdWUhXG4gICAgdmFyIHJlc3VsdCA9IFRpLkNvZGVjLmdldE5hdGl2ZUJ5dGVPcmRlcigpO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gVGkuQ29kZWMuTElUVExFX0VORElBTikge1xuICAgICAgcmV0dXJuICdMRSc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdCRSc7XG4gIH0sXG4gIGZyZWVtZW06ICgpID0+IFRpLlBsYXRmb3JtLmF2YWlsYWJsZU1lbW9yeSxcbiAgZ2V0UHJpb3JpdHk6ICgpID0+IDAsXG4gIC8vIGZha2UgaXRcbiAgaG9tZWRpcjogKCkgPT4gVGkuRmlsZXN5c3RlbS5hcHBsaWNhdGlvbkRhdGFEaXJlY3RvcnksXG4gIC8vIGZha2UgaXRcbiAgaG9zdG5hbWU6ICgpID0+IFRpLlBsYXRmb3JtLmFkZHJlc3MsXG4gIC8vIGZha2UgaXRcbiAgbG9hZGF2ZzogKCkgPT4gWzAsIDAsIDBdLFxuICAvLyBmYWtlIGl0XG4gIG5ldHdvcmtJbnRlcmZhY2VzOiAoKSA9PiB7fSxcbiAgLy8gRklYTUU6IFdoYXQgZG8gd2UgZG8gaGVyZT8gV2UgbWlnaHQgYmUgYWJsZSB0byBwaWVjZSBzb21lIG9mIHRoaXMgdG9nZXRoZXIgdXNpbmcgVGkuUGxhdGZvcm0ubmV0bWFzaywgVGkuUGxhdGZvcm0uYWRkcmVzc1xuICBwbGF0Zm9ybTogKCkgPT4gcHJvY2Vzcy5wbGF0Zm9ybSxcbiAgcmVsZWFzZTogKCkgPT4gVGkuUGxhdGZvcm0udmVyc2lvbixcbiAgc2V0UHJpb3JpdHk6ICgpID0+IHt9LFxuICAvLyBuby1vcCwgZmFrZSBpdFxuXG4gIC8qKlxuICAgKiBUaGUgYG9zLnRtcGRpcigpYCBtZXRob2QgcmV0dXJucyBhIHN0cmluZyBzcGVjaWZ5aW5nIHRoZSBvcGVyYXRpbmcgc3lzdGVtJ3MgZGVmYXVsdCBkaXJlY3RvcnkgZm9yIHRlbXBvcmFyeSBmaWxlcy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICB0bXBkaXI6ICgpID0+IFRpLkZpbGVzeXN0ZW0udGVtcERpcmVjdG9yeSxcblxuICAvKipcbiAgICogVGhlIGBvcy50b3RhbG1lbSgpYCBtZXRob2QgcmV0dXJucyB0aGUgdG90YWwgYW1vdW50IG9mIHN5c3RlbSBtZW1vcnkgaW4gYnl0ZXMgYXMgYW4gaW50ZWdlci5cbiAgICogQHJldHVybiB7aW50ZWdlcn0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdG90YWxtZW06ICgpID0+IFRpLlBsYXRmb3JtLnRvdGFsTWVtb3J5LFxuICB0eXBlOiAoKSA9PiAnVW5rbm93bicsXG4gIC8vIG92ZXJyaWRkZW4gcGVyLXBsYXRmb3JtIGF0IGJvdHRvbVxuXG4gIC8qKlxuICAgKiBUaGUgYG9zLnVwdGltZSgpYCBtZXRob2QgcmV0dXJucyB0aGUgc3lzdGVtIHVwdGltZSBpbiBudW1iZXIgb2Ygc2Vjb25kcy5cbiAgICogQHJldHVybiB7aW50ZWdlcn0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdXB0aW1lOiAoKSA9PiBUaS5QbGF0Zm9ybS51cHRpbWUsXG4gIHVzZXJJbmZvOiAoKSA9PiB7XG4gICAgLy8gZmFrZSBpdCFcbiAgICByZXR1cm4ge1xuICAgICAgdWlkOiAtMSxcbiAgICAgIGd1aWQ6IC0xLFxuICAgICAgdXNlcm5hbWU6IFRpLlBsYXRmb3JtLnVzZXJuYW1lLFxuICAgICAgaG9tZWRpcjogVGkuRmlsZXN5c3RlbS5hcHBsaWNhdGlvbkRhdGFEaXJlY3RvcnksXG4gICAgICBzaGVsbDogbnVsbFxuICAgIH07XG4gIH1cbn07IC8vIE9uIHNwZWNpZmljIHBsYXRmb3Jtcywgb3ZlcnJpZGUgaW1wbGVtZW50YXRpb25zIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGVtXG4vLyB5ZXQgYW5kIG5lZWQgdG8gZmFrZSBpdCwgb3IgdG8gaGFjayB0aGVtXG4vLyBJJ20gYWxzbyBkb2luZyB0aGlzIGluIGJsb2NrcyB0byBhc3NpZ24gaW1wbGVtZW50YXRpb25zIHRoYXQgZG9uJ3QgbmVlZCB0byBjb25zdWx0IHBsYXRmb3JtXG4vLyB0eXBlIGF0IHJ1bnRpbWUgKGhvcGVmdWxseSBzcGVlZGluZyB1cCBleGVjdXRpb24gYXQgcnVudGltZSlcblxuaWYgKGlzSU9TKSB7XG4gIE9TLnR5cGUgPSAoKSA9PiAnRGFyd2luJzsgLy8gTm93IGEgZ2lhbnQgaGFjayBmb3IgbG9va2luZyB1cCBDUFUgaW5mbyBmb3IgT1MuY3B1cygpIG9uIGlPU1xuICAvLyBodHRwczovL3d3dy50aGVpcGhvbmV3aWtpLmNvbS93aWtpL0xpc3Rfb2ZfaVBob25lc1xuXG5cbiAgdmFyIEFwcGxlTWFwID0ge1xuICAgIC8vIGlQaG9uZSAxMSBQcm8gTWF4XG4gICAgJ2lQaG9uZTEyLDUnOiBbJ0FwcGxlIEExMyBCaW9uaWMgQCAyLjY2IEdIeicsIDI2NjBdLFxuICAgIC8vIGlQaG9uZSAxMSBQcm9cbiAgICAnaVBob25lMTIsMyc6IFsnQXBwbGUgQTEzIEJpb25pYyBAIDIuNjYgR0h6JywgMjY2MF0sXG4gICAgLy8gaVBob25lIDExXG4gICAgJ2lQaG9uZTEyLDEnOiBbJ0FwcGxlIEExMyBCaW9uaWMgQCAyLjY2IEdIeicsIDI2NjBdLFxuICAgIC8vIGlQaG9uZSBYUlxuICAgICdpUGhvbmUxMSw4JzogWydBcHBsZSBBMTIgQmlvbmljIEAgMi40OSBHSHonLCAyNDkwXSxcbiAgICAvLyBpUGhvbmUgWFMgTWF4XG4gICAgJ2lQaG9uZTExLDYnOiBbJ0FwcGxlIEExMiBCaW9uaWMgQCAyLjQ5IEdIeicsIDI0OTBdLFxuICAgICdpUGhvbmUxMSw0JzogWydBcHBsZSBBMTIgQmlvbmljIEAgMi40OSBHSHonLCAyNDkwXSxcbiAgICAvLyBpUGhvbmUgWFNcbiAgICAnaVBob25lMTEsMic6IFsnQXBwbGUgQTEyIEJpb25pYyBAIDIuNDkgR0h6JywgMjQ5MF0sXG4gICAgLy8gaVBob25lIFhcbiAgICAnaVBob25lMTAsNic6IFsnQXBwbGUgQTExIEJpb25pYyBAIDIuMzkgR0h6JywgMjM5MF0sXG4gICAgJ2lQaG9uZTEwLDMnOiBbJ0FwcGxlIEExMSBCaW9uaWMgQCAyLjM5IEdIeicsIDIzOTBdLFxuICAgIC8vIGlQaG9uZSA4IFBsdXNcbiAgICAnaVBob25lMTAsNSc6IFsnQXBwbGUgQTExIEJpb25pYyBAIDIuMzkgR0h6JywgMjM5MF0sXG4gICAgJ2lQaG9uZTEwLDInOiBbJ0FwcGxlIEExMSBCaW9uaWMgQCAyLjM5IEdIeicsIDIzOTBdLFxuICAgIC8vIGlQaG9uZSA4XG4gICAgJ2lQaG9uZTEwLDQnOiBbJ0FwcGxlIEExMSBCaW9uaWMgQCAyLjM5IEdIeicsIDIzOTBdLFxuICAgICdpUGhvbmUxMCwxJzogWydBcHBsZSBBMTEgQmlvbmljIEAgMi4zOSBHSHonLCAyMzkwXSxcbiAgICAvLyBpUGhvbmUgNyBQbHVzXG4gICAgJ2lQaG9uZTksNCc6IFsnQXBwbGUgQTEwIEZ1c2lvbiBAIDIuMzQgR0h6JywgMjM0MF0sXG4gICAgJ2lQaG9uZTksMic6IFsnQXBwbGUgQTEwIEZ1c2lvbiBAIDIuMzQgR0h6JywgMjM0MF0sXG4gICAgLy8gaVBob25lIDdcbiAgICAnaVBob25lOSwzJzogWydBcHBsZSBBMTAgRnVzaW9uIEAgMi4zNCBHSHonLCAyMzQwXSxcbiAgICAnaVBob25lOSwxJzogWydBcHBsZSBBMTAgRnVzaW9uIEAgMi4zNCBHSHonLCAyMzQwXSxcbiAgICAvLyBpUGhvbmUgU0VcbiAgICAnaVBob25lOCw0JzogWydBcHBsZSBBOSBUd2lzdGVyIEAgMS44NSBHSHonLCAxODUwXSxcbiAgICAvLyBpUGhvbmUgNnMgUGx1c1xuICAgICdpUGhvbmU4LDInOiBbJ0FwcGxlIEE5IFR3aXN0ZXIgQCAxLjg1IEdIeicsIDE4NTBdLFxuICAgIC8vIGlQaG9uZSA2c1xuICAgICdpUGhvbmU4LDEnOiBbJ0FwcGxlIEE5IFR3aXN0ZXIgQCAxLjg1IEdIeicsIDE4NTBdLFxuICAgIC8vIGlQaG9uZSA2IFBsdXNcbiAgICAnaVBob25lNywxJzogWydBcHBsZSBBOCBUeXBob29uIEAgMS4zOCBHSHonLCAxMzgwXSxcbiAgICAvLyBpUGhvbmUgNlxuICAgICdpUGhvbmU3LDInOiBbJ0FwcGxlIEE4IFR5cGhvb24gQCAxLjM4IEdIeicsIDEzODBdLFxuICAgIC8vIGlQaG9uZSA1c1xuICAgICdpUGhvbmU2LDInOiBbJ0FwcGxlIEE3IEN5Y2xvbmUgQCAxLjMgR0h6JywgMTMwMF0sXG4gICAgJ2lQaG9uZTYsMSc6IFsnQXBwbGUgQTcgQ3ljbG9uZSBAIDEuMyBHSHonLCAxMzAwXSxcbiAgICAvLyBpUGhvbmUgNWNcbiAgICAnaVBob25lNSw0JzogWydBcHBsZSBBNiBTd2lmdCBAIDEuMiBHSHonLCAxMjAwXSxcbiAgICAnaVBob25lNSwzJzogWydBcHBsZSBBNiBTd2lmdCBAIDEuMiBHSHonLCAxMjAwXSxcbiAgICAvLyBpUGhvbmUgNVxuICAgICdpUGhvbmU1LDEnOiBbJ0FwcGxlIEE2IFN3aWZ0IEAgMS4yIEdIeicsIDEyMDBdLFxuICAgICdpUGhvbmU1LDInOiBbJ0FwcGxlIEE2IFN3aWZ0IEAgMS4yIEdIeicsIDEyMDBdLFxuICAgIC8vIGlQaG9uZSA0c1xuICAgICdpUGhvbmU0LDEnOiBbJ0FwcGxlIEE1IEAgODAwIE1IeicsIDgwMF0sXG4gICAgLy8gaVBob25lIDRcbiAgICAnaVBob25lMywzJzogWydBcHBsZSBBNCBAIDgwMCBNSHonLCA4MDBdLFxuICAgICdpUGhvbmUzLDInOiBbJ0FwcGxlIEE0IEAgODAwIE1IeicsIDgwMF0sXG4gICAgJ2lQaG9uZTMsMSc6IFsnQXBwbGUgQTQgQCA4MDAgTUh6JywgODAwXSxcbiAgICAvLyBpUGhvbmUgM0dTXG4gICAgJ2lQaG9uZTIsMSc6IFsnU2Ftc3VuZyBTNUw4OTIwIEAgNjIwIE1IeicsIDYyMF0sXG4gICAgLy8gaVBob25lIDNHXG4gICAgJ2lQaG9uZTEsMic6IFsnU2Ftc3VuZyBTNUw4OTAwIEAgNDEyIE1IeicsIDQxMl0sXG4gICAgLy8gaVBob25lXG4gICAgJ2lQaG9uZTEsMSc6IFsnU2Ftc3VuZyBTNUw4OTAwIEAgNDEyIE1IeicsIDQxMl0sXG4gICAgLy8gLy8vLy8vIGlQYWRzXG4gICAgLy8gaHR0cHM6Ly93d3cudGhlaXBob25ld2lraS5jb20vd2lraS9MaXN0X29mX2lQYWRzXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVBhZFxuICAgIC8vIGlQYWQgUHJvICgxMi45XCIgM3JkIGdlbilcbiAgICAnaVBhZDgsOCc6IFsnQXBwbGUgQTEyWCBAIDIuNDkgR0h6JywgMjQ5MF0sXG4gICAgJ2lQYWQ4LDcnOiBbJ0FwcGxlIEExMlggQCAyLjQ5IEdIeicsIDI0OTBdLFxuICAgICdpUGFkOCw2JzogWydBcHBsZSBBMTJYIEAgMi40OSBHSHonLCAyNDkwXSxcbiAgICAnaVBhZDgsNSc6IFsnQXBwbGUgQTEyWCBAIDIuNDkgR0h6JywgMjQ5MF0sXG4gICAgLy8gaVBhZCBQcm8gKDExXCIpXG4gICAgJ2lQYWQ4LDQnOiBbJ0FwcGxlIEExMlggQCAyLjQ5IEdIeicsIDI0OTBdLFxuICAgICdpUGFkOCwzJzogWydBcHBsZSBBMTJYIEAgMi40OSBHSHonLCAyNDkwXSxcbiAgICAnaVBhZDgsMic6IFsnQXBwbGUgQTEyWCBAIDIuNDkgR0h6JywgMjQ5MF0sXG4gICAgJ2lQYWQ4LDEnOiBbJ0FwcGxlIEExMlggQCAyLjQ5IEdIeicsIDI0OTBdLFxuICAgIC8vIGlQYWQgKDZ0aCBnZW4pXG4gICAgJ2lQYWQ3LDYnOiBbJ0FwcGxlIEExMCBAIDIuMzEgR0h6JywgMjMxMF0sXG4gICAgLy8gRklYTUU6IFdpa2lwZWRpYSBzYXlzIDIuMzQgR0h6XG4gICAgJ2lQYWQ3LDUnOiBbJ0FwcGxlIEExMCBAIDIuMzEgR0h6JywgMjMxMF0sXG4gICAgLy8gaVBhZCBQcm8gKDEwLjVcIilcbiAgICAnaVBhZDcsNCc6IFsnQXBwbGUgQTEwWCBAIDIuMzggR0h6JywgMjM4MF0sXG4gICAgJ2lQYWQ3LDMnOiBbJ0FwcGxlIEExMFggQCAyLjM4IEdIeicsIDIzODBdLFxuICAgIC8vIGlQYWQgUHJvICgxMi45XCIgMm5kIGdlbilcbiAgICAnaVBhZDcsMic6IFsnQXBwbGUgQTEwWCBAIDIuMzggR0h6JywgMjM4MF0sXG4gICAgJ2lQYWQ3LDEnOiBbJ0FwcGxlIEExMFggQCAyLjM4IEdIeicsIDIzODBdLFxuICAgIC8vIGlQYWQgKDV0aCBnZW4pXG4gICAgJ2lQYWQ2LDEyJzogWydBcHBsZSBBOSBAIDEuODUgR0h6JywgMTg1MF0sXG4gICAgJ2lQYWQ2LDExJzogWydBcHBsZSBBOSBAIDEuODUgR0h6JywgMTg1MF0sXG4gICAgLy8gaVBhZCBQcm8gKDEyLjlcIiAxc3QgZ2VuKVxuICAgICdpUGFkNiw4JzogWydBcHBsZSBBOVggQCAyLjI0IEdIeicsIDIyNDBdLFxuICAgICdpUGFkNiw3JzogWydBcHBsZSBBOVggQCAyLjI0IEdIeicsIDIyNDBdLFxuICAgIC8vIGlQYWQgUHJvICg5LjdcIilcbiAgICAnaVBhZDYsNCc6IFsnQXBwbGUgQTlYIEAgMi4xNiBHSHonLCAyMTYwXSxcbiAgICAnaVBhZDYsMyc6IFsnQXBwbGUgQTlYIEAgMi4xNiBHSHonLCAyMTYwXSxcbiAgICAvLyBpUGFkIEFpciAyXG4gICAgJ2lQYWQ1LDQnOiBbJ0FwcGxlIEE4WCBAIDEuNSBHSHonLCAxNTAwXSxcbiAgICAnaVBhZDUsMyc6IFsnQXBwbGUgQThYIEAgMS41IEdIeicsIDE1MDBdLFxuICAgIC8vIGlQYWQgTWluaSA0XG4gICAgJ2lQYWQ1LDInOiBbJ0FwcGxlIEE4IEAgMS40OSBHSHonLCAxNDkwXSxcbiAgICAnaVBhZDUsMSc6IFsnQXBwbGUgQTggQCAxLjQ5IEdIeicsIDE0OTBdLFxuICAgIC8vIGlQYWQgTWluaSAzXG4gICAgJ2lQYWQ0LDknOiBbJ0FwcGxlIEE3IEAgMS4zIEdIeicsIDEzMDBdLFxuICAgICdpUGFkNCw4JzogWydBcHBsZSBBNyBAIDEuMyBHSHonLCAxMzAwXSxcbiAgICAnaVBhZDQsNyc6IFsnQXBwbGUgQTcgQCAxLjMgR0h6JywgMTMwMF0sXG4gICAgLy8gaVBhZCBNaW5pIDJcbiAgICAnaVBhZDQsNic6IFsnQXBwbGUgQTcgQCAxLjMgR0h6JywgMTMwMF0sXG4gICAgJ2lQYWQ0LDUnOiBbJ0FwcGxlIEE3IEAgMS4zIEdIeicsIDEzMDBdLFxuICAgICdpUGFkNCw0JzogWydBcHBsZSBBNyBAIDEuMyBHSHonLCAxMzAwXSxcbiAgICAvLyBpUGFkIEFpciAyXG4gICAgJ2lQYWQ0LDMnOiBbJ0FwcGxlIEE3IFJldiBBIEAgMS40IEdIeicsIDE0MDBdLFxuICAgICdpUGFkNCwyJzogWydBcHBsZSBBNyBSZXYgQSBAIDEuNCBHSHonLCAxNDAwXSxcbiAgICAnaVBhZDQsMSc6IFsnQXBwbGUgQTcgUmV2IEEgQCAxLjQgR0h6JywgMTQwMF0sXG4gICAgLy8gaVBhZCAoNHRoIGdlbilcbiAgICAnaVBhZDMsNic6IFsnQXBwbGUgQTZYIEAgMS40IEdIeicsIDE0MDBdLFxuICAgICdpUGFkMyw1JzogWydBcHBsZSBBNlggQCAxLjQgR0h6JywgMTQwMF0sXG4gICAgJ2lQYWQzLDQnOiBbJ0FwcGxlIEE2WCBAIDEuNCBHSHonLCAxNDAwXSxcbiAgICAvLyBpUGFkICgzcmQgZ2VuKVxuICAgICdpUGFkMywzJzogWydBcHBsZSBBNVggQCAxIEdIeicsIDEwMDBdLFxuICAgICdpUGFkMywyJzogWydBcHBsZSBBNVggQCAxIEdIeicsIDEwMDBdLFxuICAgICdpUGFkMywxJzogWydBcHBsZSBBNVggQCAxIEdIeicsIDEwMDBdLFxuICAgIC8vIGlQYWQgTWluaVxuICAgICdpUGFkMiw3JzogWydBcHBsZSBBNSBSZXYgQSBAIDEgR0h6JywgMTAwMF0sXG4gICAgJ2lQYWQyLDYnOiBbJ0FwcGxlIEE1IFJldiBBIEAgMSBHSHonLCAxMDAwXSxcbiAgICAnaVBhZDIsNSc6IFsnQXBwbGUgQTUgUmV2IEEgQCAxIEdIeicsIDEwMDBdLFxuICAgIC8vIGlQYWQgMlxuICAgICdpUGFkMiw0JzogWydBcHBsZSBBNSBAIDEgR0h6JywgMTAwMF0sXG4gICAgJ2lQYWQyLDMnOiBbJ0FwcGxlIEE1IEAgMSBHSHonLCAxMDAwXSxcbiAgICAnaVBhZDIsMic6IFsnQXBwbGUgQTUgQCAxIEdIeicsIDEwMDBdLFxuICAgICdpUGFkMiwxJzogWydBcHBsZSBBNSBAIDEgR0h6JywgMTAwMF0sXG4gICAgLy8gaVBhZFxuICAgICdpUGFkMSwxJzogWydBcHBsZSBBNCBAIDEgR0h6JywgMTAwMF1cbiAgfTtcbiAgLyoqXG4gICAqIFtjcHVNb2RlbCBkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7c3RyaW5nfSBtb2RlbCBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuXG4gIHZhciBjcHVNb2RlbEFuZFNwZWVkID0gbW9kZWwgPT4ge1xuICAgIHZhciB0cmltbWVkID0gbW9kZWwucmVwbGFjZSgnIChTaW11bGF0b3IpJywgJycpLnRyaW0oKTtcbiAgICByZXR1cm4gQXBwbGVNYXBbdHJpbW1lZF0gfHwgWydVbmtub3duJywgMF07XG4gIH07IC8vIG92ZXJyaWRlIGNwdXMgaW1wbFxuXG5cbiAgT1MuY3B1cyA9ICgpID0+IHtcbiAgICAvLyBUT0RPOiBDYWNoZSB0aGUgcmVzdWx0IVxuICAgIHZhciBjb3VudCA9IFRpLlBsYXRmb3JtLnByb2Nlc3NvckNvdW50O1xuICAgIHZhciBtb2RlbEFuZFNwZWVkID0gY3B1TW9kZWxBbmRTcGVlZChUaS5QbGF0Zm9ybS5tb2RlbCk7XG4gICAgdmFyIGFycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2goe1xuICAgICAgICBtb2RlbDogbW9kZWxBbmRTcGVlZFswXSxcbiAgICAgICAgc3BlZWQ6IG1vZGVsQW5kU3BlZWRbMV0sXG4gICAgICAgIHRpbWVzOiB7fVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xufSBlbHNlIGlmIChpc0FuZHJvaWQpIHtcbiAgT1MuY3B1cyA9ICgpID0+IFRpLlBsYXRmb3JtLmNwdXMoKTtcblxuICBPUy50eXBlID0gKCkgPT4gJ0xpbnV4Jztcbn1cblxudmFyIHR0eSA9IHtcbiAgaXNhdHR5OiAoKSA9PiBmYWxzZSxcbiAgUmVhZFN0cmVhbTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcigndHR5LlJlYWRTdHJlYW0gaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH0sXG4gIFdyaXRlU3RyZWFtOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0dHkuV3JpdGVTdHJlYW0gaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cbn07XG5cbnZhciBNT05USFMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ107XG52YXIgdXRpbCA9IHtcbiAgZm9ybWF0LFxuICBmb3JtYXRXaXRoT3B0aW9ucyxcbiAgaW5zcGVjdCxcbiAgaXNBcnJheTogQXJyYXkuaXNBcnJheSxcbiAgaXNCb29sZWFuOiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgaXNCdWZmZXI6IEJ1ZmZlck1vZHVsZS5CdWZmZXIuaXNCdWZmZXIsXG4gIGlzRnVuY3Rpb246IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyxcbiAgaXNOdWxsOiB2YWx1ZSA9PiB2YWx1ZSA9PT0gbnVsbCxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IHZhbHVlID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwsXG4gIGlzTnVtYmVyOiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICBpc09iamVjdDogdmFsdWUgPT4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyxcbiAgaXNQcmltaXRpdmU6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nIHx8IHZhbHVlID09PSBudWxsLFxuICBpc1N0cmluZzogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyxcbiAgaXNTeW1ib2w6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcsXG4gIGlzVW5kZWZpbmVkOiB2YWx1ZSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkLFxuICBpc1JlZ0V4cDogaXNSZWdFeHAsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0Vycm9yOiBlID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IsXG4gIGxvZzogc3RyaW5nID0+IHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgdmFyIHRpbWUgPSBcIlwiLmNvbmNhdChkYXRlLmdldEhvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpLCBcIjpcIikuY29uY2F0KGRhdGUuZ2V0TWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKSwgXCI6XCIpLmNvbmNhdChkYXRlLmdldFNlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJykpOyAvLyBQcm9kdWNlcyBvdXRwdXQgbGlrZTogXCIyMSBGZWIgMTA6MDQ6MjMgLSBtZXNzYWdlXCJcblxuICAgIGNvbnNvbGUubG9nKFwiXCIuY29uY2F0KGRhdGUuZ2V0RGF0ZSgpLCBcIiBcIikuY29uY2F0KE1PTlRIU1tkYXRlLmdldE1vbnRoKCldLCBcIiBcIikuY29uY2F0KHRpbWUsIFwiIC0gXCIpLmNvbmNhdChzdHJpbmcpKTtcbiAgfSxcbiAgcHJpbnQ6ICguLi5hcmdzKSA9PiBjb25zb2xlLmxvZyhhcmdzLmpvaW4oJycpKSxcbiAgLy8gRklYTUU6IFNob3VsZG4ndCBhZGQgdHJhaWxpbmcgbmV3bGluZSBsaWtlIGNvbnNvbGUubG9nIGRvZXMhXG4gIHB1dHM6ICguLi5hcmdzKSA9PiBjb25zb2xlLmxvZyhhcmdzLmpvaW4oJ1xcbicpKSxcbiAgZXJyb3I6ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKGFyZ3Muam9pbignXFxuJykpLFxuICBkZWJ1Zzogc3RyaW5nID0+IGNvbnNvbGUuZXJyb3IoXCJERUJVRzogXCIuY29uY2F0KHN0cmluZykpLFxuICB0eXBlc1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3Igc3ViY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyQ29uc3RydWN0b3IgYmFzZSBjbGFzc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblxudXRpbC5pbmhlcml0cyA9IGZ1bmN0aW9uIChjb25zdHJ1Y3Rvciwgc3VwZXJDb25zdHJ1Y3Rvcikge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoY29uc3RydWN0b3IsICdjb25zdHJ1Y3RvcicsICdGdW5jdGlvbicpO1xuICBhc3NlcnRBcmd1bWVudFR5cGUoc3VwZXJDb25zdHJ1Y3RvciwgJ3N1cGVyQ29uc3RydWN0b3InLCAnRnVuY3Rpb24nKTtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLCAnc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUnLCAnT2JqZWN0Jyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgJ3N1cGVyXycsIHtcbiAgICB2YWx1ZTogc3VwZXJDb25zdHJ1Y3RvclxuICB9KTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3JpZ2luYWwgb3JpZ2luYWwgZnVuY3Rpb24gdG8gd3JhcCB3aGljaCBpcyBleHBlY3RlZCB0byBoYXZlIGEgZmluYWwgY2FsbGJhY2sgYXJndW1lbnRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZVxuICovXG5cblxudXRpbC5wcm9taXNpZnkgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKG9yaWdpbmFsLCAnb3JpZ2luYWwnLCAnRnVuY3Rpb24nKTtcblxuICBmdW5jdGlvbiB3cmFwcGVkKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgb3JpZ2luYWwuY2FsbCh0aGlzLCAuLi5hcmdzLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSAvLyBUT0RPOiBDb3B5IHByb3BlcnRpZXMgZnJvbSBvcmlnaW5hbCB0byB3cmFwcGVkXG4gIC8vIFRPRE86IGhvb2sgcHJvdG90eXBlIGNoYWluIHVwIGZyb20gd3JhcHBlZCB0byBvcmlnaW5hbFxuICAvLyBUT0RPOiBTdXBwb3J0IGN1c3RvbSBwcm9taXNpZnkgaG9va3NcblxuXG4gIHJldHVybiB3cmFwcGVkO1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3JpZ2luYWwgb3JpZ2luYWwgZnVuY3Rpb24gdG8gY29udmVydCBmcm9tIGFzeW5jL1Byb21pc2UgcmV0dXJuIHZhbHVlIHRvIGEgY2FsbGJhY2sgc3R5bGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gd3JhcHBlZCBmdW5jdGlvblxuICovXG5cblxudXRpbC5jYWxsYmFja2lmeSA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUob3JpZ2luYWwsICdvcmlnaW5hbCcsICdGdW5jdGlvbicpO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWQoLi4uYXJncykge1xuICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgdmFyIHByb21pc2UgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBwcm9taXNlLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJvbWlzZS9hbHdheXMtcmV0dXJuXG4gICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByb21pc2Uvbm8tY2FsbGJhY2staW4tcHJvbWlzZVxuICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICB2YXIgd3JhcHBlZEVycm9yID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGZhbHN5IHZhbHVlJyk7XG4gICAgICAgIHdyYXBwZWRFcnJvci5yZWFzb24gPSBlcnI7XG4gICAgICAgIGVyciA9IHdyYXBwZWRFcnJvcjtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2soZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL25vLWNhbGxiYWNrLWluLXByb21pc2VcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB3cmFwcGVkO1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBmdW5jdGlvbiB0byBkZXByZWNhdGUvd3JhcFxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBtZXNzYWdlIHRvIGdpdmUgd2hlbiBkZXByZWNhdGlvbiB3YXJuaW5nIGlzIGVtaXR0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIGRlcHJlY2F0aW9uIGNvZGUgdG8gdXNlIHRvIGdyb3VwIHdhcm5pbmdzXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHdyYXBwZWQgZnVuY3Rpb25cbiAqL1xuXG5cbnV0aWwuZGVwcmVjYXRlID0gZnVuY3Rpb24gKGZ1bmMsIHN0cmluZywgY29kZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24pIHtcbiAgICByZXR1cm4gZnVuYzsgLy8gc2tpcCB0aGUgd3JhcHBpbmchXG4gIH0gLy8gVE9ETzogU3VwcG9ydCBgY29kZWAgYXJndW1lbnQgYnkgdHJhY2tpbmcgYSBtYXAgb2YgY29kZXMgd2UndmUgd2FybmVkIGFib3V0XG5cblxuICBmdW5jdGlvbiB3cmFwcGVkKC4uLmFyZ3MpIHtcbiAgICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhzdHJpbmcsICdEZXByZWNhdGlvbldhcm5pbmcnKTtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gd3JhcHBlZDtcbn07IC8vIFRPRE86IFN1cHBvcnQgZGVidWdsb2c/IFdoYXQgaXMgb3VyIGVxdWl2YWxlbnQgb2YgcHJvY2Vzcy5lbnYoJ05PREVfREVCVUcnKT9cblxuXG52YXIgbm9vcCA9ICgpID0+IHt9O1xuXG51dGlsLmRlYnVnbG9nID0gKCkgPT4ge1xuICByZXR1cm4gbm9vcDtcbn07XG5cbnZhciBERUZBVUxUX01FU1NBR0VTID0ge1xuICBkZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgc3RyaWN0bHkgZGVlcC1lcXVhbDonLFxuICBzdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBlcXVhbDonLFxuICBkZWVwRXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBkZWVwLWVxdWFsOicsXG4gIGVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZXF1YWw6JyxcbiAgbm90RGVlcFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgc3RyaWN0bHkgZGVlcC1lcXVhbCB0bzonLFxuICBub3RTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgc3RyaWN0bHkgdW5lcXVhbCB0bzonLFxuICBub3REZWVwRXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIGxvb3NlbHkgdW5lcXVhbCB0bzonXG59OyAvLyBGYWtlIGVudW1zIHRvIHVzZSBpbnRlcm5hbGx5XG5cbnZhciBDT01QQVJFX1RZUEUgPSB7XG4gIE9iamVjdDogMCxcbiAgTWFwOiAxLFxuICBTZXQ6IDJcbn07XG52YXIgU1RSSUNUTkVTUyA9IHtcbiAgU3RyaWN0OiAwLFxuICBMb29zZTogMVxufTtcblxuY2xhc3MgQXNzZXJ0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIge1xuICAgICAgYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3JcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgLy8gRklYTUU6IEdlbmVyYXRlIHRoZSByZXN0IG9mIHRoZSBtZXNzYWdlIHdpdGggZGlmZiBvZiBhY3R1YWwvZXhwZWN0ZWQhXG4gICAgICBtZXNzYWdlID0gXCJcIi5jb25jYXQoREVGQVVMVF9NRVNTQUdFU1tvcGVyYXRvcl0sIFwiXFxuXFxuXCIpO1xuICAgIH1cblxuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuYWN0dWFsID0gYWN0dWFsO1xuICAgIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gIW1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yIFtFUlJfQVNTRVJUSU9OXSc7XG4gICAgdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICB9XG5cbn0gLy8gVE9ETzogQ2FuIHdlIGRlZmluZSBBc3NlcnRTdHJpY3QgYW5kIEFzc2VydExvb3NlIGFzIHN1YmNsYXNzZXMgb2YgYSBiYXNlIEFzc2VydCBjbGFzc1xuLy8gdGhhdCBjbGFzcyBob2xkcyBpbXBscyBmb3Igc2hhcmVkIG1ldGhvZHMsIHN1YmNsYXNzZXMgb3ZlcnJpZGUgc3BlY2lmaWNcbi8vIGNvbXBhcmlzb25zIHVzZWQgKE9iamVjdC5pcyB2cyA9PT0pP1xuXG5cbnZhciBhc3NlcnQkMSA9ICh2YWx1ZSwgbWVzc2FnZSkgPT4gYXNzZXJ0JDEub2sodmFsdWUsIG1lc3NhZ2UpO1xuXG5hc3NlcnQkMS5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuXG5hc3NlcnQkMS5vayA9ICguLi5hcmdzKSA9PiB7XG4gIHZhciB2YWx1ZSA9IGFyZ3NbMF07XG5cbiAgaWYgKHZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1lc3NhZ2UgPSBhcmdzWzFdO1xuICB2YXIgZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlOyAvLyBDaGVjayBpZiB2YWx1ZSAoMXN0IGFyZykgd2FzIG5vdCBzdXBwbGllZCFcbiAgLy8gSGF2ZSB0byB1c2UgdWdseSBoYWNrIG9uIGFyZ3MgZGVmaW5pdGlvbiB0byBkbyBzb1xuXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIG1lc3NhZ2UgPSAnTm8gdmFsdWUgYXJndW1lbnQgcGFzc2VkIHRvIGBhc3NlcnQub2soKWAnO1xuICAgIGdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9IGVsc2UgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgICAvLyBUT0RPOiBnZW5lcmF0ZSByZXN0IG9mIHRoZSBtZXNzYWdlLiBOb2RlIGFjdHVhbGx5IHJlYWRzIHRoZSBpbnB1dCBmaWxlISBUaGUgaGFja2VkIGJyb3dzZXJpZnkgZG9lcyBub3QgZG8gdGhpc1xuICAgIC8vIEl0IHRyZWF0ZXMgb2sgZmFpbGluZyBsaWtlIGB2YWx1ZSA9PSB0cnVlYCBmYWlsaW5nXG4gICAgbWVzc2FnZSA9ICdUaGUgZXhwcmVzc2lvbiBldmFsdWF0ZWQgdG8gYSBmYWxzeSB2YWx1ZTpcXG5cXG4nO1xuICAgIGdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9IGVsc2UgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHRocm93IG1lc3NhZ2U7XG4gIH1cblxuICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICBhY3R1YWw6IHZhbHVlLFxuICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgb3BlcmF0b3I6ICc9PSdcbiAgfSk7XG4gIGVyci5nZW5lcmF0ZWRNZXNzYWdlID0gZ2VuZXJhdGVkTWVzc2FnZTtcbiAgdGhyb3cgZXJyO1xufTtcblxuZnVuY3Rpb24gdGhyb3dFcnJvcihvYmopIHtcbiAgLy8gSWYgbWVzc2FnZSBpcyBhbiBFcnJvciBvYmplY3QsIHRocm93IHRoYXQgaW5zdGVhZCFcbiAgaWYgKG9iai5tZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICB0aHJvdyBvYmoubWVzc2FnZTtcbiAgfVxuXG4gIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihvYmopO1xufVxuXG5hc3NlcnQkMS5lcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93RXJyb3Ioe1xuICAgIGFjdHVhbCxcbiAgICBleHBlY3RlZCxcbiAgICBtZXNzYWdlLFxuICAgIG9wZXJhdG9yOiAnZXF1YWwnXG4gIH0pO1xufTtcblxuYXNzZXJ0JDEuc3RyaWN0RXF1YWwgPSAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgPT4ge1xuICBpZiAoT2JqZWN0LmlzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgLy8gcHJvdmlkZXMgU2FtZVZhbHVlIGNvbXBhcmlzb24gZm9yIHVzXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3dFcnJvcih7XG4gICAgYWN0dWFsLFxuICAgIGV4cGVjdGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgb3BlcmF0b3I6ICdzdHJpY3RFcXVhbCdcbiAgfSk7XG59O1xuXG5hc3NlcnQkMS5ub3RFcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93RXJyb3Ioe1xuICAgIGFjdHVhbCxcbiAgICBleHBlY3RlZCxcbiAgICBtZXNzYWdlLFxuICAgIG9wZXJhdG9yOiAnbm90RXF1YWwnXG4gIH0pO1xufTtcblxuYXNzZXJ0JDEubm90U3RyaWN0RXF1YWwgPSAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgPT4ge1xuICBpZiAoIU9iamVjdC5pcyhhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIC8vIHByb3ZpZGVzIFNhbWVWYWx1ZSBjb21wYXJpc29uIGZvciB1c1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93RXJyb3Ioe1xuICAgIGFjdHVhbCxcbiAgICBleHBlY3RlZCxcbiAgICBtZXNzYWdlLFxuICAgIG9wZXJhdG9yOiAnbm90U3RyaWN0RXF1YWwnXG4gIH0pO1xufTtcblxudmFyIGlzUHJpbWl0aXZlID0gdmFsdWUgPT4ge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgfHwgdmFsdWUgPT09IG51bGw7XG59O1xuLyoqXG4gKiBAcGFyYW0ge01hcH0gYWN0dWFsIG1hcCB3ZSBhcmUgY29tcGFyaW5nXG4gKiBAcGFyYW0ge01hcH0gZXhwZWN0ZWQgbWFwIHdlJ3JlIGNvbXBhcmluZyBhZ2FpbnN0XG4gKiBAcGFyYW0ge1NUUklDVE5FU1MuTG9vc2V8c3RyaWN0bmVzcy5TdHJpY3R9IHN0cmljdG5lc3MgaG93IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7b2JqZWN0fSByZWZlcmVuY2VzIG1lbW9pemVkIHJlZmVyZW5jZXMgdG8gb2JqZWN0cyBpbiB0aGUgZGVlcEVxdWFsIGhpZXJhcmNoeVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBjb21wYXJlTWFwcyhhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSB7XG4gIHZhciBsb29zZUNoZWNrcyA9IG5ldyBTZXQoKTsgLy8ga2VlcCB0cmFjayBvZiBvYmplY3RzIHdlIG5lZWQgdG8gdGVzdCBtb3JlIGV4dGVuc2l2ZWx5IHRoYW4gdXNpbmcgI2dldCgpLyNoYXMoKVxuXG4gIGZvciAodmFyIFtrZXksIHZhbHVlXSBvZiBhY3R1YWwpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAvLyBub24tbnVsbCBvYmplY3QuIFdlIG5lZWQgdG8gZG8gb3VyIG93biBjaGVja2luZywgbm90IHVzZSBnZXQoKS9oYXMoKVxuICAgICAgbG9vc2VDaGVja3MuYWRkKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhbmRsZSBcInByaW1pdGl2ZXNcIlxuICAgICAgaWYgKGV4cGVjdGVkLmhhcyhrZXkpICYmIGRlZXBFcXVhbCh2YWx1ZSwgZXhwZWN0ZWQuZ2V0KGtleSksIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpKSB7XG4gICAgICAgIC8vIHlheSEgYSBuaWNlIGVhc3kgbWF0Y2ggLSBib3RoIGtleSBhbmQgdmFsdWUgbWF0Y2hlZCBleGFjdGx5IC0gbW92ZSBvblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmljdG5lc3MgPT09IFNUUklDVE5FU1MuU3RyaWN0KSB7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBtYXRjaCBrZXkvdmFsdWUgcGVyZmVjdGx5IGluIHN0cmljdCBtb2RlLCBmYWlsIHJpZ2h0IGF3YXlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBvaywgc28gaXQgZGlkbid0IG1hdGNoIGtleS92YWx1ZSBwZXJmZWN0bHkgLSBidXQgd2UncmUgaW4gbG9vc2UgbW9kZSwgc28gZmFsbCBiYWNrIHRvIHRyeSBhZ2FpblxuXG5cbiAgICAgIGxvb3NlQ2hlY2tzLmFkZChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsb29zZUNoZWNrcy5zaXplID09PSAwKSB7XG4gICAgLy8gbm8gbG9vc2UgZW5kcyB0byB0aWUgdXAsIGV2ZXJ5dGhpbmcgbWF0Y2hlZFxuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIG9ubHkgZ28gdGhyb3VnaCB0aGUgc2Vjb25kIE1hcCBvbmNlIVxuXG5cbiAgZm9yICh2YXIgW2V4cGVjdGVkS2V5LCBleHBlY3RlZFZhbHVlXSBvZiBleHBlY3RlZCkge1xuICAgIC8vIGlmIGl0J3Mgbm90IGEgbm9uLW51bGwgb2JqZWN0IGluIHN0cmljdCBtb2RlLCBmYWlsIVxuICAgIC8vIChpLmUuIGlmIGl0J3MgYSBwcmltaXRpdmUgdGhhdCBmYWlsZWQgYSBtYXRjaCwgZG9uJ3QgZmFsbCBiYWNrIHRvIG1vcmUgbG9vc2VseSBtYXRjaCBpdClcbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBzaG91bGRuJ3QgZXZlciBoYXBwZW4gc2luY2Ugd2Ugc2hvdWxkIGJlIHJldHVybmluZyBmYWxzZSBpbW1lZGlhdGVseSBhYm92ZVxuICAgIGlmIChzdHJpY3RuZXNzID09PSBTVFJJQ1RORVNTLlN0cmljdCAmJiAhKHR5cGVvZiBleHBlY3RlZEtleSA9PT0gJ29iamVjdCcgJiYgZXhwZWN0ZWRLZXkgIT09IG51bGwpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBvdGhlcndpc2UsIHRlc3QgaXQgLy8gVE9ETzogV2lzaCB3ZSBjb3VsZCB1c2UgI2ZpbmQoKSBsaWtlIG9uIGFuIEFycmF5LCBidXQgU2V0IGRvZXNuJ3QgaGF2ZSBpdCFcblxuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBfa2V5IG9mIGxvb3NlQ2hlY2tzKSB7XG4gICAgICAvLyBpZiBib3RoIGtleSBhbmQgdmFsdWUgbWF0Y2hlc1xuICAgICAgaWYgKGRlZXBFcXVhbChfa2V5LCBleHBlY3RlZEtleSwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcykgJiYgZGVlcEVxdWFsKGFjdHVhbC5nZXQoX2tleSksIGV4cGVjdGVkVmFsdWUsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgbG9vc2VDaGVja3MuZGVsZXRlKF9rZXkpOyAvLyByZW1vdmUgZnJvbSBvdXIgbG9vc2VDaGVja3MgU2V0IHNpbmNlIHdlIGFscmVhZHkgbWF0Y2hlZCBpdFxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gaWYgbm90IGZvdW5kLCB3ZSBmYWlsZWQgdG8gbWF0Y2hcblxuXG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSAvLyBkaWQgd2UgbGVhdmUgdW4tbWF0Y2hlZCBrZXlzPyBpZiBzbywgZmFpbFxuXG5cbiAgcmV0dXJuIGxvb3NlQ2hlY2tzLnNpemUgPT09IDA7XG59XG4vKipcbiAqIEBwYXJhbSB7U2V0fSBhY3R1YWwgbWFwIHdlIGFyZSBjb21wYXJpbmdcbiAqIEBwYXJhbSB7U2V0fSBleHBlY3RlZCBtYXAgd2UncmUgY29tcGFyaW5nIGFnYWluc3RcbiAqIEBwYXJhbSB7c3RyaWN0bmVzcy5Mb29zZXxzdHJpY3RuZXNzLlN0cmljdH0gc3RyaWN0bmVzcyBob3cgdG8gY29tcGFyZVxuICogQHBhcmFtIHtvYmplY3R9IHJlZmVyZW5jZXMgbWVtb2l6ZWQgcmVmZXJlbmNlcyB0byBvYmplY3RzIGluIHRoZSBkZWVwRXF1YWwgaGllcmFyY2h5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbXBhcmVTZXRzKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpIHtcbiAgdmFyIGxvb3NlQ2hlY2tzID0gbmV3IFNldCgpOyAvLyBrZWVwIHRyYWNrIG9mIHZhbHVlcyB3ZSBuZWVkIHRvIHRlc3QgbW9yZSBleHRlbnNpdmVseSB0aGFuIHVzaW5nICNoYXMoKVxuXG4gIGZvciAodmFyIHZhbHVlIG9mIGFjdHVhbCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAvLyBub24tbnVsbCBvYmplY3QuIFdlIG5lZWQgdG8gZG8gb3VyIG93biBjaGVja2luZywgbm90IHVzZSBoYXMoKVxuICAgICAgbG9vc2VDaGVja3MuYWRkKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCFleHBlY3RlZC5oYXModmFsdWUpKSB7XG4gICAgICAvLyBGSVhNRTogaGFzIGRvZXMgXCJzYW1lLXZhbHVlLXplcm9cIiBjaGVjaywgd2hpY2ggaXMgbGlrZSBPYmplY3QuaXMgZXhjZXB0IGZvciAtMC8rMCBiZWluZyBjb25zaWRlcmVkIGVxdWFsXG4gICAgICAvLyBzbyBtYXkgbmVlZCB0byBzcGVjaWFsIGNhc2UgdGhhdCBoZXJlLCB0aGF0J2QgaGF2ZSB0byBiZSBpbiBhbiBlbHNlIGJlbG93IChzaW5jZSBoYXMgd2lsbCByZXR1cm4gdHJ1ZSBoZXJlKVxuICAgICAgaWYgKHN0cmljdG5lc3MgPT09IFNUUklDVE5FU1MuU3RyaWN0KSB7XG4gICAgICAgIC8vIGZhaWxlZCBcInNhbWUtdmFsdWVcIiBtYXRjaCBmb3IgcHJpbWl0aXZlIGluIHN0cmljdCBtb2RlLCBzbyBmYWlsIHJpZ2h0IGF3YXlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBXaGVuIGRvaW5nIGxvb3NlIGNoZWNrLCB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byBsb29zZXIgY2hlY2sgdGhhbiAjaGFzKCksIHNvIHdlIGNhbid0IGp1c3QgcmV0dXJuIGZhbHNlIGltbWVkaWF0ZWx5IGhlcmVcbiAgICAgIC8vIGFkZCB0byBzZXQgb2YgdmFsdWVzIHRvIGNoZWNrIG1vcmUgdGhvcm91Z2hseVxuXG5cbiAgICAgIGxvb3NlQ2hlY2tzLmFkZCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvb3NlQ2hlY2tzLnNpemUgPT09IDApIHtcbiAgICAvLyBubyBsb29zZSBlbmRzIHRvIHRpZSB1cCwgZXZlcnl0aGluZyBtYXRjaGVkXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gVHJ5IHRvIHdoaXR0bGUgZG93biB0aGUgbG9vc2UgY2hlY2tzIHNldCB0byBiZSBlbXB0eS4uLlxuICAvLyBvbmx5IGdvIHRocm91Z2ggdGhlIHNlY29uZCBTZXQgb25jZSFcblxuXG4gIGZvciAodmFyIGV4cGVjdGVkVmFsdWUgb2YgZXhwZWN0ZWQpIHtcbiAgICAvLyBpZiBpdCdzIG5vdCBhIG5vbi1udWxsIG9iamVjdCBpbiBzdHJpY3QgbW9kZSwgZmFpbCFcbiAgICAvLyAoaS5lLiBpZiBpdCdzIGEgcHJpbWl0aXZlIHRoYXQgZmFpbGVkIGEgbWF0Y2gsIGRvbid0IGZhbGwgYmFjayB0byBtb3JlIGxvb3NlbHkgbWF0Y2ggaXQpXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgc2hvdWxkbid0IGV2ZXIgaGFwcGVuIHNpbmNlIHdlIHNob3VsZCBiZSByZXR1cm5pbmcgZmFsc2UgaW1tZWRpYXRlbHkgYWJvdmVcbiAgICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QgJiYgISh0eXBlb2YgZXhwZWN0ZWRWYWx1ZSA9PT0gJ29iamVjdCcgJiYgZXhwZWN0ZWRWYWx1ZSAhPT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIG9iamVjdCBvZiBsb29zZUNoZWNrcykge1xuICAgICAgaWYgKGRlZXBFcXVhbChvYmplY3QsIGV4cGVjdGVkVmFsdWUsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTsgLy8gZm91bmQgYSBtYXRjaCFcblxuICAgICAgICBsb29zZUNoZWNrcy5kZWxldGUob2JqZWN0KTsgLy8gcmVtb3ZlIGZyb20gb3VyIGxvb3NlQ2hlY2tzIFNldCBzaW5jZSB3ZSBtYXRjaGVkIGl0XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBpZiBub3QgZm91bmQsIHdlIGZhaWxlZCB0byBtYXRjaFxuXG5cbiAgICBpZiAoIWZvdW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIGRpZCB3ZSBsZWF2ZSB1bi1tYXRjaGVkIHZhbHVlcz8gaWYgc28sIGZhaWxcblxuXG4gIHJldHVybiBsb29zZUNoZWNrcy5zaXplID09PSAwO1xufVxuLyoqXG4gKiBAcGFyYW0geyp9IGFjdHVhbCB2YWx1ZSB3ZSBhcmUgY29tcGFyaW5nXG4gKiBAcGFyYW0geyp9IGV4cGVjdGVkIHZhbHVlcyB3ZSdyZSBjb21wYXJpbmcgYWdhaW5zdFxuICogQHBhcmFtIHtTVFJJQ1RORVNTLlN0cmljdHxTVFJJQ1RORVNTLkxvb3NlfSBzdHJpY3RuZXNzIGhvdyBzdHJpY3QgYSBjb21wYXJpc29uIHRvIGRvXG4gKiBAcGFyYW0ge29iamVjdH0gW3JlZmVyZW5jZXNdIG9wdGlvbmFsIG9iamVjdCB0byBrZWVwIHRyYWNrIG9mIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4gdGhlIGhpZXJhcmNoeVxuICogQHBhcmFtIHtNYXA8b2JqZWN0LG51bWJlcj59IFtyZWZlcmVuY2VzLmFjdHVhbF0gbWFwcGluZyBmcm9tIG9iamVjdHMgdmlzaXRlZCAob24gYGFjdHVhbGApIHRvIHRoZWlyIGRlcHRoXG4gKiBAcGFyYW0ge01hcDxvYmplY3QsbnVtYmVyPn0gW3JlZmVyZW5jZXMuZXhwZWN0ZWRdIG1hcHBpbmcgZnJvbSBvYmplY3RzIHZpc2l0ZWQgKG9uIGBleHBlY3RlZGApIHRvIHRoZWlyIGRlcHRoXG4gKiBAcGFyYW0ge251bWJlcn0gW3JlZmVyZW5jZXMuZGVwdGhdIFRoZSBjdXJyZW50IGRlcHRoIG9mIHRoZSBoaWVyYXJjaHlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpIHtcbiAgLy8gaWYgcHJpbWl0aXZlcywgY29tcGFyZSB1c2luZyBPYmplY3QuaXNcbiAgLy8gVGhpcyBoYW5kbGVzOiBudWxsLCB1bmRlZmluZWQsIG51bWJlciwgc3RyaW5nLCBib29sZWFuXG4gIGlmIChpc1ByaW1pdGl2ZShhY3R1YWwpICYmIGlzUHJpbWl0aXZlKGV4cGVjdGVkKSkge1xuICAgIGlmIChzdHJpY3RuZXNzID09PSBTVFJJQ1RORVNTLlN0cmljdCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5pcyhhY3R1YWwsIGV4cGVjdGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFjdHVhbCA9PSBleHBlY3RlZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICB9XG4gIH0gLy8gTm93IHdlIGhhdmUgdmFyaW91cyBvYmplY3RzL2Z1bmN0aW9uczpcbiAgLy8gRGF0ZSwgRXJyb3IsIFJlZ0V4cCwgQXJyYXksIE1hcCwgU2V0LCBPYmplY3QsIEZ1bmN0aW9uLCBBcnJvdyBmdW5jdGlvbnMsIFdlYWtNYXAsIERhdGFWaWV3LCBBcnJheUJ1ZmZlciwgV2Vha1NldCwgdHlwZWQgYXJyYXlzXG4gIC8vIG5vdGFibHksIHRoaXMgaW5jbHVkZXMgXCJib3hlZFwiIHByaW1pdGl2ZXMgY3JlYXRlZCBieSBuZXcgQm9vbGVhbihmYWxzZSksIG5ldyBTdHJpbmcoJ3ZhbHVlJyksIFN5bWJvbCgnd2hhdGV2ZXInKSwgZXRjXG4gIC8vIFR5cGUgdGFncyBvZiBvYmplY3RzIHNob3VsZCBiZSB0aGUgc2FtZVxuXG5cbiAgdmFyIGFjdHVhbFRhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhY3R1YWwpO1xuICB2YXIgZXhwZWN0ZWRUYWcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpO1xuXG4gIGlmIChhY3R1YWxUYWcgIT09IGV4cGVjdGVkVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFtbUHJvdG90eXBlXV0gb2Ygb2JqZWN0cyBhcmUgY29tcGFyZWQgdXNpbmcgdGhlIFN0cmljdCBFcXVhbGl0eSBDb21wYXJpc29uLlxuXG5cbiAgaWYgKHN0cmljdG5lc3MgPT09IFNUUklDVE5FU1MuU3RyaWN0KSB7XG4gICAgLy8gZG9uJ3QgY2hlY2sgcHJvdG90eXBlIHdoZW4gZG9pbmcgXCJsb29zZVwiXG4gICAgdmFyIGFjdHVhbFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhY3R1YWwpO1xuICAgIHZhciBleHBlY3RlZFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihleHBlY3RlZCk7XG5cbiAgICBpZiAoYWN0dWFsUHJvdG90eXBlICE9PSBleHBlY3RlZFByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21wYXJpc29uID0gQ09NUEFSRV9UWVBFLk9iamVjdDtcblxuICBpZiAodXRpbC50eXBlcy5pc1JlZ0V4cChhY3R1YWwpKSB7XG4gICAgLy8gUmVnRXhwIHNvdXJjZSBhbmQgZmxhZ3Mgc2hvdWxkIG1hdGNoXG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzUmVnRXhwKGV4cGVjdGVkKSB8fCBhY3R1YWwuZmxhZ3MgIT09IGV4cGVjdGVkLmZsYWdzIHx8IGFjdHVhbC5zb3VyY2UgIT09IGV4cGVjdGVkLnNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY29udGludWUgb24gdG8gY2hlY2sgcHJvcGVydGllcy4uLlxuXG4gIH0gZWxzZSBpZiAodXRpbC50eXBlcy5pc0RhdGUoYWN0dWFsKSkge1xuICAgIC8vIERhdGUncyB1bmRlcmx5aW5nIHRpbWUgc2hvdWxkIG1hdGNoXG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzRGF0ZShleHBlY3RlZCkgfHwgYWN0dWFsLmdldFRpbWUoKSAhPT0gZXhwZWN0ZWQuZ2V0VGltZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjb250aW51ZSBvbiB0byBjaGVjayBwcm9wZXJ0aWVzLi4uXG5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIC8vIEVycm9yJ3MgbmFtZSBhbmQgbWVzc2FnZSBtdXN0IG1hdGNoXG4gICAgaWYgKCEoZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikgfHwgYWN0dWFsLm5hbWUgIT09IGV4cGVjdGVkLm5hbWUgfHwgYWN0dWFsLm1lc3NhZ2UgIT09IGV4cGVjdGVkLm1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cblxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYWN0dWFsKSkge1xuICAgIC8vIGlmIGFycmF5IGxlbmd0aHMgZGlmZmVyLCBxdWljayBmYWlsXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkKSB8fCBhY3R1YWwubGVuZ3RoICE9PSBleHBlY3RlZC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cblxuICB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNCb3hlZFByaW1pdGl2ZShhY3R1YWwpKSB7XG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzQm94ZWRQcmltaXRpdmUoZXhwZWN0ZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjaGVjayB0aGF0IHRoZXkncmUgdGhlIHNhbWUgdHlwZSBvZiB3cmFwcGVkIHByaW1pdGl2ZSBhbmQgdGhlbiBjYWxsIHRoZSByZWxldmFudCB2YWx1ZU9mKCkgZm9yIHRoYXQgdHlwZSB0byBjb21wYXJlIHRoZW0hXG5cblxuICAgIGlmICh1dGlsLnR5cGVzLmlzTnVtYmVyT2JqZWN0KGFjdHVhbCkgJiYgKCF1dGlsLnR5cGVzLmlzTnVtYmVyT2JqZWN0KGV4cGVjdGVkKSB8fCAhT2JqZWN0LmlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGFjdHVhbCksIE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGV4cGVjdGVkKSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzU3RyaW5nT2JqZWN0KGFjdHVhbCkgJiYgKCF1dGlsLnR5cGVzLmlzU3RyaW5nT2JqZWN0KGV4cGVjdGVkKSB8fCBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpICE9PSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbChleHBlY3RlZCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzQm9vbGVhbk9iamVjdChhY3R1YWwpICYmICghdXRpbC50eXBlcy5pc0Jvb2xlYW5PYmplY3QoZXhwZWN0ZWQpIHx8IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpICE9PSBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZXhwZWN0ZWQpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBGSVhNRTogVW5jb21tZW50IHdoZW4gd2Ugc3VwcG9ydCBCaWdJbnQgY3Jvc3MtcGxhdGZvcm0hXG4gICAgICAvLyB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNCaWdJbnRPYmplY3QoYWN0dWFsKVxuICAgICAgLy8gXHQmJiAoIXV0aWwudHlwZXMuaXNCaWdJbnRPYmplY3QoZXhwZWN0ZWQpXG4gICAgICAvLyBcdFx0fHwgQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoYWN0dWFsKSAhPT0gQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZXhwZWN0ZWQpKSkge1xuICAgICAgLy8gXHRyZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzU3ltYm9sT2JqZWN0KGFjdHVhbCkgJiYgKCF1dGlsLnR5cGVzLmlzU3ltYm9sT2JqZWN0KGV4cGVjdGVkKSB8fCBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpICE9PSBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbChleHBlY3RlZCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjb250aW51ZSBvbiB0byBjaGVjayBwcm9wZXJ0aWVzLi4uXG5cbiAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzU2V0KGFjdHVhbCkpIHtcbiAgICBpZiAoIXV0aWwudHlwZXMuaXNTZXQoZXhwZWN0ZWQpIHx8IGFjdHVhbC5zaXplICE9PSBleHBlY3RlZC5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29tcGFyaXNvbiA9IENPTVBBUkVfVFlQRS5TZXQ7IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cbiAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzTWFwKGFjdHVhbCkpIHtcbiAgICBpZiAoIXV0aWwudHlwZXMuaXNNYXAoZXhwZWN0ZWQpIHx8IGFjdHVhbC5zaXplICE9PSBleHBlY3RlZC5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29tcGFyaXNvbiA9IENPTVBBUkVfVFlQRS5NYXA7IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cbiAgfSAvLyBOb3cgaXRlcmF0ZSBvdmVyIHByb3BlcnRpZXMgYW5kIGNvbXBhcmUgdGhlbSFcblxuXG4gIHZhciBhY3R1YWxLZXlzID0gT2JqZWN0LmtleXMoYWN0dWFsKTsgLy8gZm9yIGFuIGFycmF5LCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBpbmRpY2VzIHRoYXQgaGF2ZSB2YWx1ZXNcblxuICB2YXIgZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0ZWQpOyAvLyBhbmQgaXQganVzdCBtYWdpY2FsbHkgd29ya3NcbiAgLy8gTXVzdCBoYXZlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXNcblxuICBpZiAoYWN0dWFsS2V5cy5sZW5ndGggIT09IGV4cGVjdGVkS2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gQXJlIHRoZXkgdGhlIHNhbWUga2V5cz8gSWYgb25lIGlzIG1pc3NpbmcsIHRoZW4gbm8sIGZhaWwgcmlnaHQgYXdheVxuXG5cbiAgaWYgKCFhY3R1YWxLZXlzLmV2ZXJ5KGtleSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwZWN0ZWQsIGtleSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIERvbid0IGNoZWNrIG93biBzeW1ib2xzIHdoZW4gZG9pbmcgXCJsb29zZVwiXG5cblxuICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QpIHtcbiAgICB2YXIgYWN0dWFsU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoYWN0dWFsKTtcbiAgICB2YXIgZXhwZWN0ZWRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhleHBlY3RlZCk7IC8vIE11c3QgaGF2ZSBzYW1lIG51bWJlciBvZiBzeW1ib2xzXG5cbiAgICBpZiAoYWN0dWFsU3ltYm9scy5sZW5ndGggIT09IGV4cGVjdGVkU3ltYm9scy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYWN0dWFsU3ltYm9scy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBIYXZlIHRvIGZpbHRlciB0aGVtIGRvd24gdG8gZW51bWVyYWJsZSBzeW1ib2xzIVxuICAgICAgZm9yICh2YXIga2V5IG9mIGFjdHVhbFN5bWJvbHMpIHtcbiAgICAgICAgdmFyIGFjdHVhbElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChhY3R1YWwsIGtleSk7XG4gICAgICAgIHZhciBleHBlY3RlZElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChleHBlY3RlZCwga2V5KTtcblxuICAgICAgICBpZiAoYWN0dWFsSXNFbnVtZXJhYmxlICE9PSBleHBlY3RlZElzRW51bWVyYWJsZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gdGhleSBkaWZmZXIgb24gd2hldGVociBzeW1ib2wgaXMgZW51bWVyYWJsZSwgZmFpbCFcbiAgICAgICAgfSBlbHNlIGlmIChhY3R1YWxJc0VudW1lcmFibGUpIHtcbiAgICAgICAgICAvLyBpdCdzIGVudW1lcmFibGUsIGFkZCB0byBrZXlzIHRvIGNoZWNrXG4gICAgICAgICAgYWN0dWFsS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgZXhwZWN0ZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBBdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzIVxuICAvLyBSZWNvcmQgbWFwIGZyb20gb2JqZWN0cyB0byBkZXB0aCBpbiB0aGUgaGllcmFyY2h5XG5cblxuICBpZiAocmVmZXJlbmNlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmVmZXJlbmNlcyA9IHtcbiAgICAgIGFjdHVhbDogbmV3IE1hcCgpLFxuICAgICAgZXhwZWN0ZWQ6IG5ldyBNYXAoKSxcbiAgICAgIGRlcHRoOiAwXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzZWUgaWYgd2UndmUgYWxyZWFkeSByZWNvcmRlZCB0aGVzZSBvYmplY3RzLlxuICAgIC8vIGlmIHNvLCBtYWtlIHN1cmUgdGhleSByZWZlciB0byBzYW1lIGRlcHRoIGluIG9iamVjdCBoaWVyYXJjaHlcbiAgICB2YXIgbWVtb2l6ZWRBY3R1YWwgPSByZWZlcmVuY2VzLmFjdHVhbC5nZXQoYWN0dWFsKTtcblxuICAgIGlmIChtZW1vaXplZEFjdHVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgbWVtb2l6ZWRFeHBlY3RlZCA9IHJlZmVyZW5jZXMuZXhwZWN0ZWQuZ2V0KGV4cGVjdGVkKTtcblxuICAgICAgaWYgKG1lbW9pemVkRXhwZWN0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbWVtb2l6ZWRBY3R1YWwgPT09IG1lbW9pemVkRXhwZWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVmZXJlbmNlcy5kZXB0aCsrO1xuICB9IC8vIHN0b3JlIHRoZSBvYmplY3QgLT4gZGVwdGggbWFwcGluZ1xuXG5cbiAgcmVmZXJlbmNlcy5hY3R1YWwuc2V0KGFjdHVhbCwgcmVmZXJlbmNlcy5kZXB0aCk7XG4gIHJlZmVyZW5jZXMuZXhwZWN0ZWQuc2V0KGV4cGVjdGVkLCByZWZlcmVuY2VzLmRlcHRoKTsgLy8gV2hlbiBjb21wYXJpbmcgTWFwcy9TZXRzLCBjb21wYXJlIGVsZW1lbnRzIGJlZm9yZSBjdXN0b20gcHJvcGVydGllc1xuXG4gIHZhciByZXN1bHQgPSB0cnVlO1xuXG4gIGlmIChjb21wYXJpc29uID09PSBDT01QQVJFX1RZUEUuU2V0KSB7XG4gICAgcmVzdWx0ID0gY29tcGFyZVNldHMoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcyk7XG4gIH0gZWxzZSBpZiAoY29tcGFyaXNvbiA9PT0gQ09NUEFSRV9UWVBFLk1hcCkge1xuICAgIHJlc3VsdCA9IGNvbXBhcmVNYXBzKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpO1xuICB9XG5cbiAgaWYgKHJlc3VsdCkge1xuICAgIC8vIE5vdyBsb29wIG92ZXIga2V5cyBhbmQgY29tcGFyZSB0aGVtIHRvIGVhY2ggb3RoZXIhXG4gICAgZm9yICh2YXIgX2tleTIgb2YgYWN0dWFsS2V5cykge1xuICAgICAgaWYgKCFkZWVwRXF1YWwoYWN0dWFsW19rZXkyXSwgZXhwZWN0ZWRbX2tleTJdLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHdpcGUgdGhlIG9iamVjdCB0byBkZXB0aCBtYXBwaW5nIGZvciB0aGVzZSBvYmplY3RzIG5vd1xuXG5cbiAgcmVmZXJlbmNlcy5hY3R1YWwuZGVsZXRlKGFjdHVhbCk7XG4gIHJlZmVyZW5jZXMuZXhwZWN0ZWQuZGVsZXRlKGV4cGVjdGVkKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuYXNzZXJ0JDEuZGVlcFN0cmljdEVxdWFsID0gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKCFkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgU1RSSUNUTkVTUy5TdHJpY3QpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCdcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0JDEubm90RGVlcFN0cmljdEVxdWFsID0gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBTVFJJQ1RORVNTLlN0cmljdCkpIHtcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcFN0cmljdEVxdWFsJ1xuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQkMS5kZWVwRXF1YWwgPSAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgPT4ge1xuICBpZiAoIWRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBTVFJJQ1RORVNTLkxvb3NlKSkge1xuICAgIHRocm93RXJyb3Ioe1xuICAgICAgYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdkZWVwRXF1YWwnXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydCQxLm5vdERlZXBFcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgU1RSSUNUTkVTUy5Mb29zZSkpIHtcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcEVxdWFsJ1xuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQkMS5mYWlsID0gKG1lc3NhZ2UgPSAnRmFpbGVkJykgPT4gdGhyb3dFcnJvcih7XG4gIG1lc3NhZ2Vcbn0pO1xuXG52YXIgTk9fRVhDRVBUSU9OID0ge307XG5cbmZ1bmN0aW9uIGV4ZWN1dGUoZm4pIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZuLCAnZm4nLCAnRnVuY3Rpb24nKTtcblxuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHJldHVybiBOT19FWENFUFRJT047XG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZUxpa2UoZm4pIHtcbiAgcmV0dXJuIHV0aWwudHlwZXMuaXNQcm9taXNlKGZuKSB8fCBmbiAmJiB0eXBlb2YgZm4gPT09ICdvYmplY3QnICYmIHR5cGVvZiBmbi50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBleGVjdXRlUHJvbWlzZShfeCkge1xuICByZXR1cm4gX2V4ZWN1dGVQcm9taXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9leGVjdXRlUHJvbWlzZSgpIHtcbiAgX2V4ZWN1dGVQcm9taXNlID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qIChmbikge1xuICAgIHZhciBwcm9taXNlO1xuICAgIHZhciBmblR5cGUgPSB0eXBlb2YgZm47XG5cbiAgICBpZiAoZm5UeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9taXNlID0gZm4oKTtcblxuICAgICAgaWYgKCFpc1Byb21pc2VMaWtlKHByb21pc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbnN0YW5jZW9mIFByb21pc2UgdG8gYmUgcmV0dXJuZWQgZnJvbSB0aGUgXFxcImZuXFxcIiBmdW5jdGlvbiBidXQgZ290IFwiLmNvbmNhdCh0eXBlb2YgcHJvbWlzZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWlzUHJvbWlzZUxpa2UoZm4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgXFxcImZuXFxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24gb3IgUHJvbWlzZS4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQoZm5UeXBlKSk7XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UgPSBmbjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgeWllbGQgcHJvbWlzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG5cbiAgICByZXR1cm4gTk9fRVhDRVBUSU9OO1xuICB9KTtcbiAgcmV0dXJuIF9leGVjdXRlUHJvbWlzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5hc3NlcnQkMS50aHJvd3MgPSAoZm4sIGVycm9yLCBtZXNzYWdlKSA9PiB7XG4gIHZhciBhY3R1YWwgPSBleGVjdXRlKGZuKTtcblxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT04pIHtcbiAgICAvLyBGSVhNRTogYXBwZW5kIG1lc3NhZ2UgaWYgbm90IG51bGxcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbDogdW5kZWZpbmVkLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgbWVzc2FnZTogJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uLicsXG4gICAgICBvcGVyYXRvcjogJ3Rocm93cydcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH0gLy8gVGhleSBkaWRuJ3Qgc3BlY2lmeSBob3cgdG8gdmFsaWRhdGUsIHNvIGp1c3Qgcm9sbCB3aXRoIGl0XG5cblxuICBpZiAoIWVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFjaGVja0Vycm9yKGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpKSB7XG4gICAgdGhyb3cgYWN0dWFsOyAvLyB0aHJvdyB0aGUgRXJyb3IgaXQgZGlkIGdlbmVyYXRlXG4gIH1cbn07XG5cbmFzc2VydCQxLnJlamVjdHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoYXN5bmNGbiwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgICB2YXIgYWN0dWFsID0geWllbGQgZXhlY3V0ZVByb21pc2UoYXN5bmNGbik7XG5cbiAgICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT04pIHtcbiAgICAgIC8vIEZJWE1FOiBhcHBlbmQgbWVzc2FnZSBpZiBub3QgbnVsbFxuICAgICAgdGhyb3dFcnJvcih7XG4gICAgICAgIGFjdHVhbDogdW5kZWZpbmVkLFxuICAgICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICAgIG1lc3NhZ2U6ICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbi4nLFxuICAgICAgICBvcGVyYXRvcjogJ3JlamVjdHMnXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRoZXkgZGlkbid0IHNwZWNpZnkgaG93IHRvIHZhbGlkYXRlLCBzbyBqdXN0IHJvbGwgd2l0aCBpdFxuXG5cbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFjaGVja0Vycm9yKGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpKSB7XG4gICAgICB0aHJvdyBhY3R1YWw7IC8vIHRocm93IHRoZSBFcnJvciBpdCBkaWQgZ2VuZXJhdGVcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoX3gyLCBfeDMsIF94NCkge1xuICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KCk7XG5cbmFzc2VydCQxLmRvZXNOb3RUaHJvdyA9IChmbiwgZXJyb3IsIG1lc3NhZ2UpID0+IHtcbiAgdmFyIGFjdHVhbCA9IGV4ZWN1dGUoZm4pOyAvLyBubyBFcnJvciwganVzdCByZXR1cm5cblxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT04pIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVGhleSBkaWRuJ3Qgc3BlY2lmeSBob3cgdG8gdmFsaWRhdGUsIHNvIGp1c3QgcmUtdGhyb3dcblxuXG4gIGlmICghZXJyb3IpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH0gLy8gSWYgZXJyb3IgbWF0Y2hlcyBleHBlY3RlZCwgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3JcblxuXG4gIGlmIChjaGVja0Vycm9yKGFjdHVhbCwgZXJyb3IpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogJ2RvZXNOb3RUaHJvdycsXG4gICAgICBtZXNzYWdlOiBcIkdvdCB1bndhbnRlZCBleGNlcHRpb25cIi5jb25jYXQobWVzc2FnZSA/ICc6ICcgKyBtZXNzYWdlIDogJy4nKVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfSAvLyBkb2Vzbid0IG1hdGNoLCByZS10aHJvd1xuXG5cbiAgdGhyb3cgYWN0dWFsO1xufTtcblxuYXNzZXJ0JDEuZG9lc05vdFJlamVjdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoZm4sIGVycm9yLCBtZXNzYWdlKSB7XG4gICAgdmFyIGFjdHVhbCA9IHlpZWxkIGV4ZWN1dGVQcm9taXNlKGZuKTsgLy8gbm8gRXJyb3IsIGp1c3QgcmV0dXJuXG5cbiAgICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT04pIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRoZXkgZGlkbid0IHNwZWNpZnkgaG93IHRvIHZhbGlkYXRlLCBzbyBqdXN0IHJlLXRocm93XG5cblxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIHRocm93IGFjdHVhbDtcbiAgICB9IC8vIElmIGVycm9yIG1hdGNoZXMgZXhwZWN0ZWQsIHRocm93IGFuIEFzc2VydGlvbkVycm9yXG5cblxuICAgIGlmIChjaGVja0Vycm9yKGFjdHVhbCwgZXJyb3IpKSB7XG4gICAgICB0aHJvd0Vycm9yKHtcbiAgICAgICAgYWN0dWFsLFxuICAgICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICAgIG9wZXJhdG9yOiAnZG9lc05vdFRocm93JyxcbiAgICAgICAgbWVzc2FnZTogXCJHb3QgdW53YW50ZWQgZXhjZXB0aW9uXCIuY29uY2F0KG1lc3NhZ2UgPyAnOiAnICsgbWVzc2FnZSA6ICcuJylcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZG9lc24ndCBtYXRjaCwgcmUtdGhyb3dcblxuXG4gICAgdGhyb3cgYWN0dWFsO1xuICB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKF94NSwgX3g2LCBfeDcpIHtcbiAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0oKTtcbi8qKlxuICogQHBhcmFtIHtFcnJvcn0gYWN0dWFsIHRoZSBhY3R1YWwgRXJyb3IgZ2VuZXJhdGVkIGJ5IHRoZSB3cmFwcGVkIGZ1bmN0aW9uL2Jsb2NrXG4gKiBAcGFyYW0ge29iamVjdHxSZWdFeHB8RnVuY3Rpb258RXJyb3J8Q2xhc3N9IGV4cGVjdGVkIFRoZSB2YWx1ZSB0byB0ZXN0IGFnYWluc3QgdGhlIEVycm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIGN1c3RvbSBtZXNzYWdlIHRvIGFwcGVuZFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIEVycm9yIG1hdGNoZXMgdGhlIGV4cGVjdGVkIHZhbHVlL29iamVjdFxuICovXG5cblxuZnVuY3Rpb24gY2hlY2tFcnJvcihhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIC8vIFdoYXQgd2UgZG8gaGVyZSBkZXBlbmRzIG9uIHdoYXQgYGV4cGVjdGVkYCBpczpcbiAgLy8gZnVuY3Rpb24gLSBjYWxsIGl0IHRvIHZhbGlkYXRlXG4gIC8vIG9iamVjdCAtIHRlc3QgcHJvcGVydGllcyBhZ2FpbnN0IGFjdHVhbFxuICAvLyBSZWdleHAgLSB0ZXN0IGFnYWluc3QgYWN0dWFsLnRvU3RyaW5nKClcbiAgLy8gRXJyb3IgdHlwZSAtIGNoZWNrIHR5cGUgbWF0Y2hlc1xuICAvLyBFcnJvciBpbnN0YW5jZSAtIGNvbXBhcmUgcHJvcGVydGllc1xuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnb2JqZWN0Jykge1xuICAgIGlmICh1dGlsLnR5cGVzLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTsgLy8gZG9lcyB0aGUgZXJyb3IgbWF0Y2ggdGhlIFJlZ0V4cCBleHByZXNzaW9uPyBpZiBzbywgcGFzc1xuICAgIH0gLy8gVGVzdCBwcm9wZXJ0aWVzIChgZXhwZWN0ZWRgIGlzIGVpdGhlciBhIGdlbmVyaWMgT2JqZWN0IG9yIGFuIEVycm9yIGluc3RhbmNlKVxuXG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV4cGVjdGVkKTsgLy8gSWYgd2UncmUgdGVzdGluZyBhZ2FpbnN0IGFuIGluc3RhbmNlIG9mIGFuIEVycm9yLCB3ZSBuZWVkIHRvIGhhY2sgaW4gbmFtZS9tZXNzYWdlIHByb3BlcnRpZXMuXG5cbiAgICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAga2V5cy51bnNoaWZ0KCduYW1lJywgJ21lc3NhZ2UnKTsgLy8gd2Ugd2FudCB0byBjb21wYXJlIG5hbWUgYW5kIG1lc3NhZ2UsIGJ1dCB0aGV5J3JlIG5vdCBzZXQgYXMgZW51bWVyYWJsZSBvbiBFcnJvclxuICAgIH1cblxuICAgIGZvciAodmFyIGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAoIWRlZXBFcXVhbChhY3R1YWxba2V5XSwgZXhwZWN0ZWRba2V5XSwgU1RSSUNUTkVTUy5TdHJpY3QpKSB7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgIC8vIGdlbmVyYXRlIGEgbWVhbmluZ2Z1bCBtZXNzYWdlISBDaGVhdCBieSB0cmVhdGluZyBsaWtlIGVxdWFsaXR5IGNoZWNrIG9mIHZhbHVlc1xuICAgICAgICAgIC8vIHRoZW4gc3RlYWwgdGhlIG1lc3NhZ2UgaXQgZ2VuZXJhdGVkXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe1xuICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbFtrZXldLFxuICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRba2V5XSxcbiAgICAgICAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvd0Vycm9yKHtcbiAgICAgICAgICBhY3R1YWwsXG4gICAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICBvcGVyYXRvcjogJ3Rocm93cydcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTsgLy8gVGhleSBhbGwgbWF0Y2hlZCwgcGFzcyFcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBpZiBgZXhwZWN0ZWRgIGlzIGEgXCJ0eXBlXCIgYW5kIGFjdHVhbCBpcyBhbiBpbnN0YW5jZSBvZiB0aGF0IHR5cGUsIHRoZW4gcGFzc1xuICAgIGlmIChleHBlY3RlZC5wcm90b3R5cGUgIT0gbnVsbCAmJiBhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBJZiBgZXhwZWN0ZWRgIGlzIGEgc3ViY2xhc3Mgb2YgRXJyb3IgYnV0IGBhY3R1YWxgIHdhc24ndCBhbiBpbnN0YW5jZSBvZiBpdCAoYWJvdmUpLCBmYWlsXG5cblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbChFcnJvciwgZXhwZWN0ZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBvaywgbGV0J3MgYXNzdW1lIHdoYXQncyBsZWZ0IGlzIHRoYXQgYGV4cGVjdGVkYCB3YXMgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uLFxuICAgIC8vIHNvIGNhbGwgaXQgd2l0aCBlbXB0eSBgdGhpc2AgYW5kIHNpbmdsZSBhcmd1bWVudCBvZiB0aGUgYWN0dWFsIGVycm9yIHdlIHJlY2VpdmVkXG5cblxuICAgIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5hc3NlcnQkMS5pZkVycm9yID0gdmFsdWUgPT4ge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93RXJyb3Ioe1xuICAgIGFjdHVhbDogdmFsdWUsXG4gICAgZXhwZWN0ZWQ6IG51bGwsXG4gICAgbWVzc2FnZTogXCJpZkVycm9yIGdvdCB1bndhbnRlZCBleGNlcHRpb246IFwiLmNvbmNhdCh2YWx1ZSksXG4gICAgb3BlcmF0b3I6ICdpZkVycm9yJ1xuICB9KTtcbn07IC8vIENyZWF0ZSBcInN0cmljdFwiIGNvcHkgd2hpY2ggb3ZlcnJpZGVzIFwibG9vc2VcIiBtZXRob2RzIHRvIGNhbGwgc3RyaWN0IGVxdWl2YWxlbnRzXG5cblxuYXNzZXJ0JDEuc3RyaWN0ID0gKHZhbHVlLCBtZXNzYWdlKSA9PiBhc3NlcnQkMS5vayh2YWx1ZSwgbWVzc2FnZSk7IC8vIFwiQ29weVwiIG1ldGhvZHMgZnJvbSBhc3NlcnQgdG8gYXNzZXJ0LnN0cmljdCFcblxuXG5PYmplY3QuYXNzaWduKGFzc2VydCQxLnN0cmljdCwgYXNzZXJ0JDEpOyAvLyBPdmVycmlkZSB0aGUgXCJsb29zZVwiIG1ldGhvZHMgdG8gcG9pbnQgdG8gdGhlIHN0cmljdCBvbmVzXG5cbmFzc2VydCQxLnN0cmljdC5kZWVwRXF1YWwgPSBhc3NlcnQkMS5kZWVwU3RyaWN0RXF1YWw7XG5hc3NlcnQkMS5zdHJpY3Qubm90RGVlcEVxdWFsID0gYXNzZXJ0JDEubm90RGVlcFN0cmljdEVxdWFsO1xuYXNzZXJ0JDEuc3RyaWN0LmVxdWFsID0gYXNzZXJ0JDEuc3RyaWN0RXF1YWw7XG5hc3NlcnQkMS5zdHJpY3Qubm90RXF1YWwgPSBhc3NlcnQkMS5ub3RTdHJpY3RFcXVhbDsgLy8gaGFuZyBzdHJpY3Qgb2ZmIGl0c2VsZlxuXG5hc3NlcnQkMS5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0JDEuc3RyaWN0O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIHRoZSBgU3RyaW5nRGVjb2RlcmAgd2lsbCB1c2UuXG4gKi9cbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgdGhpcy5faW1wbCA9IG5ldyBVdGY4U3RyaW5nRGVjb2RlcigpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTYtbGUnOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy5faW1wbCA9IG5ldyBVdGYxNlN0cmluZ0RlY29kZXIoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMuX2ltcGwgPSBuZXcgQmFzZTY0U3RyaW5nRGVjb2RlcigpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5faW1wbCA9IG5ldyBTdHJpbmdEZWNvZGVySW1wbCh0aGlzLmVuY29kaW5nKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG4vKipcbiAqIFJldHVybnMgYW55IHJlbWFpbmluZyBpbnB1dCBzdG9yZWQgaW4gdGhlIGludGVybmFsIGJ1ZmZlciBhcyBhIHN0cmluZy5cbiAqIEJ5dGVzIHJlcHJlc2VudGluZyBpbmNvbXBsZXRlIFVURi04IGFuZCBVVEYtMTYgY2hhcmFjdGVycyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggc3Vic3RpdHV0aW9uXG4gKiBjaGFyYWN0ZXJzIGFwcHJvcHJpYXRlIGZvciB0aGUgY2hhcmFjdGVyIGVuY29kaW5nLlxuICpcbiAqIElmIHRoZSBidWZmZXIgYXJndW1lbnQgaXMgcHJvdmlkZWQsIG9uZSBmaW5hbCBjYWxsIHRvIHN0cmluZ0RlY29kZXIud3JpdGUoKSBpcyBwZXJmb3JtZWQgYmVmb3JlIHJldHVybmluZyB0aGUgcmVtYWluaW5nIGlucHV0LlxuICogQHBhcmFtIHtCdWZmZXJ9IFtidWZmZXJdIGNvbnRhaW5pbmcgdGhlIGJ5dGVzIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQoYnVmZmVyKSB7XG4gIHJldHVybiB0aGlzLl9pbXBsLmVuZChidWZmZXIpO1xufTtcbi8qKlxuICogUmV0dXJucyBhIGRlY29kZWQgc3RyaW5nLCBlbnN1cmluZyB0aGF0IGFueSBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJzIGF0IHRoZSBlbmQgb2YgdGhlIEJ1ZmZlciwgb3JcbiAqIFR5cGVkQXJyYXksIG9yIERhdGFWaWV3IGFyZSBvbWl0dGVkIGZyb20gdGhlIHJldHVybmVkIHN0cmluZyBhbmQgc3RvcmVkIGluIGFuIGludGVybmFsIGJ1ZmZlciBmb3IgdGhlXG4gKiBuZXh0IGNhbGwgdG8gc3RyaW5nRGVjb2Rlci53cml0ZSgpIG9yIHN0cmluZ0RlY29kZXIuZW5kKCkuXG4gKiBAcGFyYW0ge0J1ZmZlcnxUeXBlZEFycmF5fERhdGFWaWV3fSBidWZmZXIgY29udGFpbmluZyB0aGUgYnl0ZXMgdG8gZGVjb2RlLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoYnVmZmVyKSB7XG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBidWZmZXI7XG4gIH0gLy8gZW1wdHkgc3RyaW5nIGZvciBlbXB0eSBidWZmZXJcblxuXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2ltcGwud3JpdGUoYnVmZmVyKTtcbn07XG4vKipcbiAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MuIFdlIG92ZXJyaWRlIHBhcnRzIG9mIGl0IGZvciBjZXJ0YWluIGVuY29kaW5ncy4gRm9yIGFzY2lpL2hleC9iaW5hcnkvbGF0aW4xIHRoZSBpbXBsIGlzIHN1cGVyLWVhc3lcbiAqL1xuXG5cbmNsYXNzIFN0cmluZ0RlY29kZXJJbXBsIHtcbiAgY29uc3RydWN0b3IoZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgdGhpcy5ieXRlQ291bnQgPSAwO1xuICAgIHRoaXMuY2hhckxlbmd0aCA9IDE7XG4gIH0gLy8gdGhlIGFjdHVhbCB1bmRlcmx5aW5nIGltcGxlbWVudGF0aW9uIVxuXG5cbiAgZW5kKGJ1ZmZlcikge1xuICAgIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMud3JpdGUoYnVmZmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB3cml0ZShidWZmZXIpIHtcbiAgICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7IC8vIHNpbmdsZSBieXRlIGNoYXJhY3RlciBlbmNvZGluZ3MgYXJlIGEgY2luY2hcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7IC8vIG5vIGJ1ZmZlciwgb3IgZW1wdHlcbiAgfVxuXG59IC8vIEZvciBtdWx0aS1ieXRlIGVuY29kaW5ncywgbGV0J3MgaW1wbGVtZW50IHNvbWUgYmFzZSBsb2dpYy4uLlxuXG5cbmNsYXNzIE11bHRpQnl0ZVN0cmluZ0RlY29kZXJJbXBsIGV4dGVuZHMgU3RyaW5nRGVjb2RlckltcGwge1xuICBjb25zdHJ1Y3RvcihlbmNvZGluZywgYnl0ZXNQZXJDaGFyKSB7XG4gICAgc3VwZXIoZW5jb2RpbmcpO1xuICAgIHRoaXMuaW5jb21wbGV0ZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShieXRlc1BlckNoYXIpOyAvLyB0ZW1wb3JhcnkgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnVmZmVyXG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEluY29tcGxldGVDaGFyT2JqZWN0XG4gICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gYnl0ZXNOZWVkZWQgYnl0ZXMgbWlzc2luZyB0byBjb21wbGV0ZSB0aGUgY2hhcmFjdGVyXG4gICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gY2hhckxlbmd0aCBieXRlcyBleHBlY3RlZCB0byBjb21wbGV0ZSB0aGUgY2hhcmFjdGVyXG4gICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gaW5kZXggbG9jYXRpb24gaW4gdGhlIGJ1ZmZlciB3aGVyZSB0aGUgY2hhcmFjdGVyIHN0YXJ0c1xuICAgKi9cblxuICAvKipcbiAgICogR2l2ZW4gYSBCdWZmZXIsIHNlZXMgaWYgd2UgaGF2ZSBhbiBpbmNvbXBsZXRlIFwiY2hhcmFjdGVyXCIgYXQgdGhlIGVuZCBvZiBpdC5cbiAgICogUmV0dXJucyBpbmZvIG9uIHRoYXQ6XG4gICAqIC0gYnl0ZXNOZWVkZWQ6IDAtMywgbnVtYmVyIG9mIGJ5dGVzIHN0aWxsIHJlbWFpbmluZ1xuICAgKiAtIGNoYXJMZW5ndGg6IGV4cGVjdGVkIG51bWJlciBvZiBieXRlcyBmb3IgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAqIC0gaW5kZXg6IGluZGV4IGluIHRoZSBidWZmZXIgd2hlcmUgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJlZ2luc1xuICAgKiBAcGFyYW0ge0J1ZmZlcn0gX2J1ZmZlciBCdWZmZXIgd2UgYXJlIGNoZWNraW5nIHRvIHNlZSBpZiBpdCBoYXMgYW4gaW5jb21wZWx0ZSBcImNoYXJhY3RlclwiIGF0IHRoZSBlbmRcbiAgICogQHJldHVybnMge0luY29tcGxldGVDaGFyT2JqZWN0fVxuICAgKi9cblxuXG4gIF9jaGVja0luY29tcGxldGVCeXRlcyhfYnVmZmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUhJyk7XG4gIH1cblxuICBfaW5jb21wbGV0ZUVuZCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSEnKTtcbiAgfVxuXG4gIF9pbmNvbXBsZXRlQnVmZmVyRW1wdGllZCgpIHtcbiAgICAvLyB0eXBpY2FsbHkgd2UgcmVzZXQgYnl0ZSBjb3VudCBiYWNrIHRvIDAgYW5kIGNoYXJhY3RlciBsZW5ndGggdG8gMVxuICAgIHRoaXMuYnl0ZUNvdW50ID0gMDtcbiAgICB0aGlzLmNoYXJMZW5ndGggPSAxO1xuICB9XG5cbiAgZW5kKGJ1ZmZlcikge1xuICAgIHZhciByZXN1bHQgPSBzdXBlci5lbmQoYnVmZmVyKTtcblxuICAgIGlmICh0aGlzLmJ5dGVDb3VudCAhPT0gMCkge1xuICAgICAgLy8gd2UgaGF2ZSBpbmNvbXBsZXRlIGNoYXJhY3RlcnMhXG4gICAgICByZXN1bHQgKz0gdGhpcy5faW5jb21wbGV0ZUVuZCgpO1xuICAgIH1cblxuICAgIHRoaXMuX2luY29tcGxldGVCdWZmZXJFbXB0aWVkKCk7IC8vIHJlc2V0IG91ciBpbnRlcm5hbHMgdG8gXCJ3aXBlXCIgdGhlIGluY29tcGxldGUgYnVmZmVyXG5cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB3cml0ZShidWZmZXIpIHtcbiAgICAvLyBmaXJzdCBsZXQncyBzZWUgaWYgd2UgaGFkIHNvbWUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIgd2UgZGlkbid0IGZpbmlzaC4uLlxuICAgIHZhciBjaGFyID0gJyc7XG5cbiAgICBpZiAodGhpcy5ieXRlQ291bnQgIT09IDApIHtcbiAgICAgIC8vIHdlIHN0aWxsIG5lZWRlZCBzb21lIGJ5dGVzIHRvIGZpbmlzaCB0aGUgY2hhcmFjdGVyXG4gICAgICAvLyBIb3cgbWFueSBieXRlcyBkbyB3ZSBzdGlsbCBuZWVkPyBjaGFyTGVuZ3RoIC0gYnl0ZXMgd2UgcmVjZWl2ZWRcbiAgICAgIHZhciBsZWZ0ID0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5ieXRlQ291bnQ7IC8vIG5lZWQgNCwgaGF2ZSAxPyB0aGVuIHdlIGhhdmUgMyBcImxlZnRcIlxuXG4gICAgICB2YXIgYnl0ZXNDb3BpZWQgPSBNYXRoLm1pbihsZWZ0LCBidWZmZXIubGVuZ3RoKTsgLy8gY29weSB1cCB0byB0aGF0IG1hbnkgYnl0ZXNcbiAgICAgIC8vIGNvcHkgYnl0ZXMgZnJvbSBgYnVmZmVyYCB0byBvdXIgaW5jb21wbGV0ZSBidWZmZXJcblxuICAgICAgYnVmZmVyLmNvcHkodGhpcy5pbmNvbXBsZXRlLCB0aGlzLmJ5dGVDb3VudCwgMCwgYnl0ZXNDb3BpZWQpO1xuICAgICAgdGhpcy5ieXRlQ291bnQgKz0gYnl0ZXNDb3BpZWQ7IC8vIHJlY29yZCBob3cgbWFueSBtb3JlIGJ5dGVzIHdlIGNvcGllZC4uLlxuXG4gICAgICBpZiAoYnl0ZXNDb3BpZWQgPCBsZWZ0KSB7XG4gICAgICAgIC8vIHN0aWxsIG5lZWQgbW9yZSBieXRlcyB0byBjb21wbGV0ZSFcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSAvLyB3ZSB3ZXJlIGFibGUgdG8gY29tcGxldGUsIHlheSFcbiAgICAgIC8vIGdyYWIgdGhlIGNoYXJhY3RlciB3ZSBjb21wbGV0ZWRcblxuXG4gICAgICBjaGFyID0gdGhpcy5pbmNvbXBsZXRlLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7IC8vIHJlc2V0IG91ciBjb3VudGVyc1xuXG4gICAgICB0aGlzLl9pbmNvbXBsZXRlQnVmZmVyRW1wdGllZCgpOyAvLyBkbyB3ZSBoYXZlIGFueSBieXRlcyBsZWZ0IGluIHRoaXMgYnVmZmVyP1xuXG5cbiAgICAgIGlmIChieXRlc0NvcGllZCA9PT0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2hhcjsgLy8gaWYgbm90LCByZXR1cm4gdGhlIGNoYXJhY3RlciB3ZSBmaW5pc2hlZCFcbiAgICAgIH0gLy8gd2Ugc3RpbGwgaGF2ZSBtb3JlIGJ5dGVzLCBzbyBzbGljZSB0aGUgYnVmZmVyIHVwXG5cblxuICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGJ5dGVzQ29waWVkLCBidWZmZXIubGVuZ3RoKTtcbiAgICB9IC8vIGNoZWNrIHRoaXMgYnVmZmVyIHRvIHNlZSBpZiBpdCBpbmRpY2F0ZXMgd2UgbmVlZCBtb3JlIGJ5dGVzP1xuXG5cbiAgICB2YXIgaW5jb21wbGV0ZUNoYXJEYXRhID0gdGhpcy5fY2hlY2tJbmNvbXBsZXRlQnl0ZXMoYnVmZmVyKTtcblxuICAgIGlmIChpbmNvbXBsZXRlQ2hhckRhdGEuYnl0ZXNOZWVkZWQgPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyICsgYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpOyAvLyBubyBpbmNvbXBsZXRlIGJ5dGVzLCByZXR1cm4gYW55IGNoYXJhY3RlciB3ZSBjb21wbGV0ZWQgcGx1cyB0aGUgYnVmZmVyXG4gICAgfSAvLyBvayBzbyB0aGUgYnVmZmVyIGhvbGRzIGFuIGluY29tcGxldGUgY2hhcmFjdGVyIGF0IGl0J3MgZW5kXG5cblxuICAgIHRoaXMuY2hhckxlbmd0aCA9IGluY29tcGxldGVDaGFyRGF0YS5jaGFyTGVuZ3RoOyAvLyByZWNvcmQgaG93IG1hbnkgYnl0ZXMgd2UgbmVlZCBmb3IgdGhlICdjaGFyYWN0ZXInXG5cbiAgICB2YXIgaW5jb21wbGV0ZUNoYXJJbmRleCA9IGluY29tcGxldGVDaGFyRGF0YS5pbmRleDsgLy8gdGhpcyBpcyB0aGUgaW5kZXggb2YgdGhlIG11bHRpYnl0ZSBjaGFyYWN0ZXIgdGhhdCBpcyBpbmNvbXBsZXRlXG4gICAgLy8gY29weSBmcm9tIGluZGV4IG9mIGluY29tcGxldGUgY2hhcmFjdGVyIHRvIGVuZCBvZiBidWZmZXJcblxuICAgIHZhciBieXRlc1RvQ29weSA9IGJ1ZmZlci5sZW5ndGggLSBpbmNvbXBsZXRlQ2hhckluZGV4O1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuaW5jb21wbGV0ZSwgMCwgaW5jb21wbGV0ZUNoYXJJbmRleCwgYnVmZmVyLmxlbmd0aCk7XG4gICAgdGhpcy5ieXRlQ291bnQgPSBieXRlc1RvQ29weTsgLy8gcmVjb3JkIGhvdyBtYW55IGJ5dGVzIHdlIGFjdHVhbGx5IGNvcGllZFxuXG4gICAgaWYgKGJ5dGVzVG9Db3B5IDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgLy8gYnVmZmVyIGhhZCBieXRlcyBiZWZvcmUgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgICAvLyBzbyBzbXVzaCBhbnkgY2hhcmFjdGVyIHdlIG1heSBoYXZlIGNvbXBsZXRlZCB3aXRoIGFueSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIHRoZSBidWZmZXJcbiAgICAgIHJldHVybiBjaGFyICsgYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGluY29tcGxldGVDaGFySW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFyOyAvLyBhbnkgbm93LWNvbXBsZXRlZCBjaGFyYWN0ZXIgdGhhdCB3YXMgcHJldmlvdXNseSBpbmNvbXBsZXRlLCBwb3NzaWJseSBlbXB0eVxuICB9XG5cbn1cblxuY2xhc3MgVXRmOFN0cmluZ0RlY29kZXIgZXh0ZW5kcyBNdWx0aUJ5dGVTdHJpbmdEZWNvZGVySW1wbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCd1dGY4JywgNCk7XG4gIH1cblxuICBfY2hlY2tJbmNvbXBsZXRlQnl0ZXMoYnVmZmVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7IC8vIEZJWE1FOiBJbiBOb2RlLCB0aGV5IGNoZWNrIHRoZSBsYXN0IGNoYXJhY3RlciBmaXJzdCFcbiAgICAvLyBBbmQgdGhleSByZWx5IG9uIEJ1ZmZlciN0b1N0cmluZygpIHRvIGhhbmRsZSBpbmplY3RpbmcgdGhlICdcXHVmZmZkJyBjaGFyYWN0ZXIgZm9yIGJ1c3RlZCBtdWx0aS1ieXRlIHNlcXVlbmNlcyFcbiAgICAvLyBpT1MgYXBwYXJlbnRseSBqdXN0IHJldHVybnMgdW5kZWZpbmVkIGluIHRoYXQgc3BlY2lhbCBjYXNlIGFuZFxuICAgIC8vIEFuZHJvaWQgZGlmZmVycyBoZXJlIGJlY2F1c2Ugd2UgZG9uJ3Qgd29yayBiYWNrd2FyZHMgZnJvbSB0aGUgbGFzdCBjaGFyXG4gICAgLy8gQ2FuIHdlIGNoZWF0IGhlcmUgYW5kLi4uXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvc3RyaW5nX2RlY29kZXIvYmxvYi9tYXN0ZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzI0wxNzMtTDE5OFxuICAgIC8vIC0gaWYgd2Ugc2VlIGEgbXVsdGktYnl0ZSBjaGFyYWN0ZXIgc3RhcnQsIHZhbGlkYXRlIHRoZSBuZXh0IGNoYXJhY3RlcnMgYXJlIGNvbnRpbnVhdGlvbiBjaGFyc1xuICAgIC8vIC0gaWYgdGhleSdyZSBub3QgcmVwbGFjZSB0aGUgc2VxdWVuY2Ugd2l0aCAnXFx1ZmZmZCcsIHRyZWF0IGxpa2UgdGhhdCBtdWx0aS1ieXRlIGNoYXJhY3RlciB3YXMgXCJjb21wbGV0ZWRcIlxuICAgIC8vIE5vdGUgdGhhdCBldmVuIGlmIHdlIGRvIGhhY2sgdGhpcywgaWYgdGhlcmUncyBzb21lIGludmFsaWQgbXVsdGktYnl0ZSBVVEYtOCBpbiB0aGUgYnVmZmVyIHRoYXQgaXNuJ3QgYXQgdGhlIGxhc3QgMyBieXRlc1xuICAgIC8vIHRoZW4gd2UncmUgYXQgdGhlIG1lcmN5IG9mIHRoZSBKUyBlbmdpbmUvcGxhdGZvcm0gY29kZSBmb3IgaGFuZGxpbmcgdGhhdFxuICAgIC8vIEhlcmUncyBzb21lb25lJ3MgaGFjayB0aGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vb2xlZ2FuemEvOTk3MTU1XG4gICAgLy8gaWYgYnVmZmVyLmxlbmd0aCA+PSAzLCBjaGVjayAzcmQgdG8gbGFzdCBieXRlXG5cbiAgICBpZiAobGVuZ3RoID49IDMpIHtcbiAgICAgIHZhciBjaGFyTGVuZ3RoID0gY2hlY2tDaGFyTGVuZ3RoRm9yVVRGOChidWZmZXJbbGVuZ3RoIC0gM10pO1xuXG4gICAgICBpZiAoY2hhckxlbmd0aCA9PT0gNCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJ5dGVzTmVlZGVkOiAxLFxuICAgICAgICAgIC8vIHdlIGhhdmUgMyBsYXN0IGJ5dGVzLCBuZWVkIDR0aFxuICAgICAgICAgIGluZGV4OiBsZW5ndGggLSAzLFxuICAgICAgICAgIGNoYXJMZW5ndGg6IDRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IC8vIGlmIGJ1ZmZlci5sZW5ndGggPj0gMiwgY2hlY2sgMm5kIHRvIGxhc3QgYnl0ZVxuXG5cbiAgICBpZiAobGVuZ3RoID49IDIpIHtcbiAgICAgIHZhciBfY2hhckxlbmd0aCA9IGNoZWNrQ2hhckxlbmd0aEZvclVURjgoYnVmZmVyW2xlbmd0aCAtIDJdKTtcblxuICAgICAgaWYgKF9jaGFyTGVuZ3RoID49IDMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBieXRlc05lZWRlZDogX2NoYXJMZW5ndGggLSAyLFxuICAgICAgICAgIC8vIHdlIGhhdmUgMiBieXRlcyBvZiB3aGF0ZXZlciB3ZSBuZWVkXG4gICAgICAgICAgaW5kZXg6IGxlbmd0aCAtIDIsXG4gICAgICAgICAgY2hhckxlbmd0aDogX2NoYXJMZW5ndGhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IC8vIGlmIGJ1ZmZlci5sZW5ndGggPj0gMSwgY2hlY2sgbGFzdCBieXRlXG5cblxuICAgIGlmIChsZW5ndGggPj0gMSkge1xuICAgICAgdmFyIF9jaGFyTGVuZ3RoMiA9IGNoZWNrQ2hhckxlbmd0aEZvclVURjgoYnVmZmVyW2xlbmd0aCAtIDFdKTtcblxuICAgICAgaWYgKF9jaGFyTGVuZ3RoMiA+PSAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYnl0ZXNOZWVkZWQ6IF9jaGFyTGVuZ3RoMiAtIDEsXG4gICAgICAgICAgLy8gd2UgaGF2ZSAxIGJ5dGUgb2Ygd2hhdGV2ZXIgd2UgbmVlZFxuICAgICAgICAgIGluZGV4OiBsZW5ndGggLSAxLFxuICAgICAgICAgIGNoYXJMZW5ndGg6IF9jaGFyTGVuZ3RoMlxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gLy8gYmFzZSBjYXNlLCBubyBieXRlcyBuZWVkZWQgLSBlbmRzIG9uIGNvbXBsZXRlIGNoYXJhY3RlclxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgYnl0ZXNOZWVkZWQ6IDAsXG4gICAgICBpbmRleDogbGVuZ3RoIC0gMSxcbiAgICAgIGNoYXJMZW5ndGg6IDFcbiAgICB9O1xuICB9XG5cbiAgX2luY29tcGxldGVFbmQoKSB7XG4gICAgcmV0dXJuICdcXHVmZmZkJzsgLy8gd2UgcmVwbGFjZSB0aGUgbWlzc2luZyBjaGFyYWN0ZXIgd2l0aCBhIHNwZWNpYWwgdXRmOCBjaGFyXG4gIH1cblxufVxuXG5jbGFzcyBVdGYxNlN0cmluZ0RlY29kZXIgZXh0ZW5kcyBNdWx0aUJ5dGVTdHJpbmdEZWNvZGVySW1wbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCd1dGYxNmxlJywgNCk7XG4gIH1cblxuICBfY2hlY2tJbmNvbXBsZXRlQnl0ZXMoYnVmZmVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgdmFyIG1vZHVsbyA9IGxlbmd0aCAlIDI7IC8vIG9rLCB3ZSBoYXZlIGEgbXVsdGlwbGUgb2YgMiBieXRlc1xuXG4gICAgaWYgKG1vZHVsbyA9PT0gMCkge1xuICAgICAgLy8gaXMgdGhlIGxhc3QgYnl0ZSBhIGxlYWRpbmcvaGlnaCBzdXJyb2dhdGU/XG4gICAgICB2YXIgYnl0ZSA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChieXRlID49IDB4RDggJiYgYnl0ZSA8PSAweERCKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYnl0ZXNOZWVkZWQ6IDIsXG4gICAgICAgICAgY2hhckxlbmd0aDogNCxcbiAgICAgICAgICBpbmRleDogbGVuZ3RoIC0gMlxuICAgICAgICB9O1xuICAgICAgfSAvLyB3ZSdyZSBnb29kLCBub3QgYSBzdXJyb2dhdGUsIHNvIHdlIGhhdmUgb3VyIG5lZWRlZCAyIGJ5dGVzXG5cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnl0ZXNOZWVkZWQ6IDAsXG4gICAgICAgIGNoYXJMZW5ndGg6IDJcbiAgICAgIH07XG4gICAgfSAvLyBvayB3ZSBoYXZlIDEgYnl0ZSBsZWZ0IG92ZXIsIGFzc3VtZSB3ZSBuZWVkIDIgdG8gZm9ybSB0aGUgY2hhcmFjdGVyXG5cblxuICAgIHJldHVybiB7XG4gICAgICBieXRlc05lZWRlZDogMSxcbiAgICAgIGluZGV4OiBsZW5ndGggLSAxLFxuICAgICAgY2hhckxlbmd0aDogMlxuICAgIH07XG4gIH1cblxuICBfaW5jb21wbGV0ZUVuZCgpIHtcbiAgICAvLyBKdXN0IHdyaXRlIG91dCB0aGUgbGFzdCBOIGJ5dGVzLCBob3BlZnVsbHkgdGhlIGVuZ2luZSBjYW4gaGFuZGxlIGl0IGZvciB1cz9cbiAgICByZXR1cm4gdGhpcy5pbmNvbXBsZXRlLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgdGhpcy5ieXRlQ291bnQpO1xuICB9XG5cbn1cblxuY2xhc3MgQmFzZTY0U3RyaW5nRGVjb2RlciBleHRlbmRzIE11bHRpQnl0ZVN0cmluZ0RlY29kZXJJbXBsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ2Jhc2U2NCcsIDMpO1xuICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7IC8vIGFsd2F5cyAzIVxuICB9XG5cbiAgX2NoZWNrSW5jb21wbGV0ZUJ5dGVzKGJ1ZmZlcikge1xuICAgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgIHZhciBtb2R1bG8gPSBsZW5ndGggJSAzOyAvLyBiYXNlNjQgbmVlZHMgMyBieXRlcyBhbHdheXMsIHNvIGlmIHdlIGhhdmUgdGhhdCBtYW55IChvciBhIG11bHRpcGxlKSwgd2UgaGF2ZSBhIGNvbXBsZXRlIGJ1ZmZlclxuXG4gICAgaWYgKG1vZHVsbyA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnl0ZXNOZWVkZWQ6IDAsXG4gICAgICAgIGNoYXJMZW5ndGg6IDNcbiAgICAgIH07XG4gICAgfSAvLyBvayB3ZSBoYXZlIDEgb3IgMiBieXRlcyBsZWZ0IG92ZXJcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGJ5dGVzTmVlZGVkOiAzIC0gbW9kdWxvLFxuICAgICAgLy8gYWx3YXlzIG5lZWQgMywgc28gaWYgd2UgaGF2ZSAxIGxlZnQgb3ZlciAtPiBuZWVkIDJcbiAgICAgIGluZGV4OiBsZW5ndGggLSBtb2R1bG8sXG4gICAgICBjaGFyTGVuZ3RoOiAzIC8vIGFsd2F5cyBuZWVkIDNcblxuICAgIH07XG4gIH1cblxuICBfaW5jb21wbGV0ZUJ1ZmZlckVtcHRpZWQoKSB7XG4gICAgdGhpcy5ieXRlQ291bnQgPSAwO1xuICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7IC8vIGFsd2F5cyAzIVxuICB9XG5cbiAgX2luY29tcGxldGVFbmQoKSB7XG4gICAgLy8gSnVzdCB3cml0ZSBvdXQgdGhlIGxhc3QgTiBieXRlcywgaXQgc2hvdWxkIGluc2VydCB0aGUgJz0nIHBsYWNlaG9sZGVyc1xuICAgIC8vIGl0J3Mgbm90IHJlYWxseSAnbWlzc2luZycvJ2luY29tcGxldGUnLCBqdXN0IG5lZWRzIHBsYWNlaG9sZGVyIGluc2VydGlvblxuICAgIHJldHVybiB0aGlzLmluY29tcGxldGUudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIHRoaXMuYnl0ZUNvdW50KTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGNoZWNrQ2hhckxlbmd0aEZvclVURjgoYnl0ZSkge1xuICAvLyAxMTExMFhYWCA9PiAxMTEwID0+IDB4MUVcbiAgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkge1xuICAgIHJldHVybiA0O1xuICB9IC8vIDExMTBYWFhYID0+IDExMTAgPT4gMHgxRVxuXG5cbiAgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkge1xuICAgIHJldHVybiAzO1xuICB9IC8vIDExMFhYWFhYID0+IDExMCA9PiAweDA2XG5cblxuICBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSB7XG4gICAgcmV0dXJuIDI7XG4gIH1cblxuICByZXR1cm4gMTtcbn1cblxudmFyIFN0cmluZ0RlY29kZXIkMSA9IHtcbiAgU3RyaW5nRGVjb2RlclxufTtcblxudmFyIGlzQW5kcm9pZCQxID0gVGkuUGxhdGZvcm0ubmFtZSA9PT0gJ2FuZHJvaWQnOyAvLyBLZWVwIHRyYWNrIG9mIHByaW50aW5nIG91dCBvbmUtdGltZSB3YXJuaW5nIG1lc3NhZ2VzIGZvciB1bnN1cHBvcnRlZCBvcGVyYXRpb25zL29wdGlvbnMvYXJndW1lbnRzXG5cbnZhciBwcmludGVkV2FybmluZ3MgPSB7fTtcblxuZnVuY3Rpb24gb25lVGltZVdhcm5pbmcoa2V5LCBtc2cpIHtcbiAgaWYgKCFwcmludGVkV2FybmluZ3Nba2V5XSkge1xuICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgIHByaW50ZWRXYXJuaW5nc1trZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBQcmludHMgYSBvbmUtdGltZSB3YXJuaW5nIG1lc3NhZ2UgdGhhdCB3ZSBkbyBub3Qgc3VwcG9ydCB0aGUgZ2l2ZW4gQVBJIGFuZCBwZXJmb3JtcyBhbiBlZmZlY3RpdmUgbm8tb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lIG5hbWUgb2YgdGhlIG1vZHVsZS9vYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLnByb3BlcnR5IHdlIGRvbid0IHN1cHBvcnRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gbm8tb3AgZnVuY3Rpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkTm9vcChtb2R1bGVOYW1lLCBuYW1lKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdmFyIGZxbiA9IFwiXCIuY29uY2F0KG1vZHVsZU5hbWUsIFwiLlwiKS5jb25jYXQobmFtZSk7XG4gICAgb25lVGltZVdhcm5pbmcoZnFuLCBcIlxcXCJcIi5jb25jYXQoZnFuLCBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZCB5ZXQgb24gVGl0YW5pdW0gYW5kIHVzZXMgYSBuby1vcCBmYWxsYmFjay5cIikpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lIG5hbWUgb2YgdGhlIG1vZHVsZS9vYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLnByb3BlcnR5IHdlIGRvbid0IHN1cHBvcnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrIHdlIGNhbGwgaW4gYSBxdWljayBzZXRUaW1lb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBhc3luY1Vuc3VwcG9ydGVkTm9vcChtb2R1bGVOYW1lLCBuYW1lLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spOyAvLyBlbmZvcmNlIHdlIGhhdmUgYSB2YWxpZCBjYWxsYmFja1xuXG4gIHVuc3VwcG9ydGVkTm9vcChtb2R1bGVOYW1lLCBuYW1lKSgpO1xuICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxKTtcbn0gLy8gVXNlZCB0byBjaG9vc2UgdGhlIGJ1ZmZlci9jaHVuayBzaXplIHdoZW4gcHVtcGluZyBieXRlcyBkdXJpbmcgY29waWVzXG5cblxudmFyIENPUFlfRklMRV9DSFVOS19TSVpFID0gODA5MjsgLy8gd2hhdCBzaG91bGQgd2UgdXNlIGhlcmU/XG4vLyBLZWVwIHRyYWNrIG9mIGludGVnZXIgLT4gRmlsZVN0cmVhbSBtYXBwaW5nc1xuXG52YXIgZmlsZURlc2NyaXB0b3JzID0gbmV3IE1hcCgpO1xudmFyIGZpbGVEZXNjcmlwdG9yQ291bnQgPSA0OyAvLyBnbG9iYWwgY291bnRlciB1c2VkIHRvIHJlcG9ydCBmaWxlIGRlc2NyaXB0b3IgaW50ZWdlcnNcbi8vIE1hcCBmaWxlIHN5c3RlbSBhY2Nlc3MgZmxhZ3MgdG8gVGkuRmlsZXN5c3RlbS5NT0RFXyogY29uc3RhbnRzXG5cbnZhciBGTEFHU19UT19USV9NT0RFID0gbmV3IE1hcCgpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ2EnLCBUaS5GaWxlc3lzdGVtLk1PREVfQVBQRU5EKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdheCcsIFRpLkZpbGVzeXN0ZW0uTU9ERV9BUFBFTkQpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ2ErJywgVGkuRmlsZXN5c3RlbS5NT0RFX0FQUEVORCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgnYXgrJywgVGkuRmlsZXN5c3RlbS5NT0RFX0FQUEVORCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgnYXMrJywgVGkuRmlsZXN5c3RlbS5NT0RFX0FQUEVORCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgncicsIFRpLkZpbGVzeXN0ZW0uTU9ERV9SRUFEKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdyKycsIFRpLkZpbGVzeXN0ZW0uTU9ERV9SRUFEKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdycysnLCBUaS5GaWxlc3lzdGVtLk1PREVfUkVBRCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgndycsIFRpLkZpbGVzeXN0ZW0uTU9ERV9XUklURSk7XG5GTEFHU19UT19USV9NT0RFLnNldCgnd3gnLCBUaS5GaWxlc3lzdGVtLk1PREVfV1JJVEUpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ3crJywgVGkuRmlsZXN5c3RlbS5NT0RFX1dSSVRFKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCd3eCsnLCBUaS5GaWxlc3lzdGVtLk1PREVfV1JJVEUpOyAvLyBDb21tb24gZXJyb3JzXG5cbnZhciBwZXJtaXNzaW9uRGVuaWVkID0gKHN5c2NhbGwsIHBhdGgpID0+IG1ha2VFcnJvcignRUFDQ0VTJywgJ3Blcm1pc3Npb24gZGVuaWVkJywgLTEzLCBzeXNjYWxsLCBwYXRoKTtcblxudmFyIG5vU3VjaEZpbGUgPSAoc3lzY2FsbCwgcGF0aCkgPT4gbWFrZUVycm9yKCdFTk9FTlQnLCAnbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeScsIC0yLCBzeXNjYWxsLCBwYXRoKTtcblxudmFyIGZpbGVBbHJlYWR5RXhpc3RzID0gKHN5c2NhbGwsIHBhdGgpID0+IG1ha2VFcnJvcignRUVYSVNUJywgJ2ZpbGUgYWxyZWFkeSBleGlzdHMnLCAtMTcsIHN5c2NhbGwsIHBhdGgpO1xuXG52YXIgbm90QURpcmVjdG9yeSA9IChzeXNjYWxsLCBwYXRoKSA9PiBtYWtlRXJyb3IoJ0VOT1RESVInLCAnbm90IGEgZGlyZWN0b3J5JywgLTIwLCBzeXNjYWxsLCBwYXRoKTtcblxudmFyIGRpcmVjdG9yeU5vdEVtcHR5ID0gKHN5c2NhbGwsIHBhdGgpID0+IG1ha2VFcnJvcignRU5PVEVNUFRZJywgJ2RpcmVjdG9yeSBub3QgZW1wdHknLCAtNjYsIHN5c2NhbGwsIHBhdGgpO1xuXG52YXIgaWxsZWdhbE9wZXJhdGlvbk9uQURpcmVjdG9yeSA9IChzeXNjYWxsLCBwYXRoKSA9PiBtYWtlRXJyb3IoJ0VJU0RJUicsICdpbGxlZ2FsIG9wZXJhdGlvbiBvbiBhIGRpcmVjdG9yeScsIC0yMSwgc3lzY2FsbCwgcGF0aCk7XG5cbnZhciBmcyA9IHtcbiAgY29uc3RhbnRzOiB7XG4gICAgT19SRE9OTFk6IDAsXG4gICAgT19XUk9OTFk6IDEsXG4gICAgT19SRFdSOiAyLFxuICAgIFNfSUZNVDogNjE0NDAsXG4gICAgU19JRlJFRzogMzI3NjgsXG4gICAgU19JRkRJUjogMTYzODQsXG4gICAgU19JRkNIUjogODE5MixcbiAgICBTX0lGQkxLOiAyNDU3NixcbiAgICBTX0lGSUZPOiA0MDk2LFxuICAgIFNfSUZMTks6IDQwOTYwLFxuICAgIFNfSUZTT0NLOiA0OTE1MixcbiAgICBPX0NSRUFUOiA1MTIsXG4gICAgT19FWENMOiAyMDQ4LFxuICAgIE9fTk9DVFRZOiAxMzEwNzIsXG4gICAgT19UUlVOQzogMTAyNCxcbiAgICBPX0FQUEVORDogOCxcbiAgICBPX0RJUkVDVE9SWTogMTA0ODU3NixcbiAgICBPX05PRk9MTE9XOiAyNTYsXG4gICAgT19TWU5DOiAxMjgsXG4gICAgT19EU1lOQzogNDE5NDMwNCxcbiAgICBPX1NZTUxJTks6IDIwOTcxNTIsXG4gICAgT19OT05CTE9DSzogNCxcbiAgICBTX0lSV1hVOiA0NDgsXG4gICAgU19JUlVTUjogMjU2LFxuICAgIFNfSVdVU1I6IDEyOCxcbiAgICBTX0lYVVNSOiA2NCxcbiAgICBTX0lSV1hHOiA1NixcbiAgICBTX0lSR1JQOiAzMixcbiAgICBTX0lXR1JQOiAxNixcbiAgICBTX0lYR1JQOiA4LFxuICAgIFNfSVJXWE86IDcsXG4gICAgU19JUk9USDogNCxcbiAgICBTX0lXT1RIOiAyLFxuICAgIFNfSVhPVEg6IDEsXG4gICAgRl9PSzogMCxcbiAgICBSX09LOiA0LFxuICAgIFdfT0s6IDIsXG4gICAgWF9PSzogMSxcbiAgICBVVl9GU19DT1BZRklMRV9FWENMOiAxLFxuICAgIENPUFlGSUxFX0VYQ0w6IDFcbiAgfVxufTtcblxuY2xhc3MgU3RhdHMge1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgdGhpcy5fZmlsZSA9IG51bGw7XG4gICAgdGhpcy5kZXYgPSAwO1xuICAgIHRoaXMuaW5vID0gMDtcbiAgICB0aGlzLm1vZGUgPSAwO1xuICAgIHRoaXMubmxpbmsgPSAwO1xuICAgIHRoaXMudWlkID0gMDtcbiAgICB0aGlzLmdpZCA9IDA7XG4gICAgdGhpcy5yZGV2ID0gMDtcbiAgICB0aGlzLnNpemUgPSAwO1xuICAgIHRoaXMuYmxrc2l6ZSA9IDQwOTY7IC8vIEZJWE1FOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzE1MzExL3doYXQtaXMtdGhlLWJsb2NrLXNpemUtb2YtdGhlLWlwaG9uZS1maWxlc3lzdGVtXG5cbiAgICB0aGlzLmJsb2NrcyA9IDA7XG4gICAgdGhpcy5hdGltZU1zID0gdGhpcy5tdGltZU1zID0gdGhpcy5jdGltZU1zID0gdGhpcy5iaXJ0aHRpbWVNcyA9IDA7XG4gICAgdGhpcy5hdGltZSA9IHRoaXMubXRpbWUgPSB0aGlzLmN0aW1lID0gdGhpcy5iaXJ0aHRpbWUgPSBuZXcgRGF0ZSgwKTtcblxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0aGlzLl9maWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCk7IC8vIFRPRE86IHVzZSBsYXp5IGdldHRlcnMgaGVyZT9cblxuICAgICAgdGhpcy5jdGltZSA9IHRoaXMuYmlydGh0aW1lID0gdGhpcy5fZmlsZS5jcmVhdGVkQXQoKTtcbiAgICAgIHRoaXMuYXRpbWUgPSB0aGlzLm10aW1lID0gdGhpcy5fZmlsZS5tb2RpZmllZEF0KCk7XG4gICAgICB0aGlzLmF0aW1lTXMgPSB0aGlzLmF0aW1lLmdldFRpbWUoKTtcbiAgICAgIHRoaXMuYmlydGh0aW1lTXMgPSB0aGlzLmJpcnRodGltZS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLmN0aW1lTXMgPSB0aGlzLmN0aW1lLmdldFRpbWUoKTtcbiAgICAgIHRoaXMubXRpbWVNcyA9IHRoaXMubXRpbWUuZ2V0VGltZSgpO1xuICAgICAgdGhpcy5zaXplID0gdGhpcy5fZmlsZS5zaXplO1xuICAgICAgdGhpcy5ibG9ja3MgPSBNYXRoLmNlaWwodGhpcy5zaXplIC8gdGhpcy5ibGtzaXplKTsgLy8gVE9ETzogQ2FuIHdlIGZha2Ugb3V0IHRoZSBtb2RlIGJhc2VkIG9uIHRoZSByZWFkb25seS93cml0YWJsZS9leGVjdXRhYmxlIHByb3BlcnRpZXM/XG4gICAgfVxuICB9XG5cbiAgaXNGaWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlLmlzRmlsZSgpO1xuICB9XG5cbiAgaXNEaXJlY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGUuaXNEaXJlY3RvcnkoKTtcbiAgfVxuXG4gIGlzQmxvY2tEZXZpY2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXNDaGFyYWN0ZXJEZXZpY2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXNTeW1ib2xpY0xpbmsoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGUuc3ltYm9saWNMaW5rO1xuICB9XG5cbiAgaXNGSUZPKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzU29ja2V0KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG59XG5cbmZzLlN0YXRzID0gU3RhdHM7XG5cbmNsYXNzIFJlYWRTdHJlYW0ge31cblxuZnMuUmVhZFN0cmVhbSA9IFJlYWRTdHJlYW07XG5cbmNsYXNzIFdyaXRlU3RyZWFtIHt9XG5cbmZzLldyaXRlU3RyZWFtID0gV3JpdGVTdHJlYW07XG4vKipcbiAqIEBjYWxsYmFjayBzdGF0c0NhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciBpZiBvbmUgb2NjdXJyZWRcbiAqIEBwYXJhbSB7ZnMuU3RhdHN9IHN0YXRzIC0gZmlsZSBzdGF0c1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfEJ1ZmZlcn0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW21vZGU9ZnMuY29uc3RhbnRzLkZfT0tdIGFjY2Vzc2liaWxpdHkgbW9kZS9jaGVja1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5mcy5hY2Nlc3MgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBtb2RlO1xuICAgIG1vZGUgPSBmcy5jb25zdGFudHMuRl9PSztcbiAgfVxuXG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmcy5hY2Nlc3NTeW5jKHBhdGgsIG1vZGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKCk7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfEJ1ZmZlcn0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW21vZGU9ZnMuY29uc3RhbnRzLkZfT0tdIGFjY2Vzc2liaWxpdHkgbW9kZS9jaGVja1xuICovXG5cblxuZnMuYWNjZXNzU3luYyA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlID0gZnMuY29uc3RhbnRzLkZfT0spIHtcbiAgLy8gRl9PSyBpcyBqdXN0IHdoZXRoZXIgZmlsZSBleGlzdHMgb3Igbm90LCBubyBwZXJtaXNzaW9ucyBjaGVja1xuICAvLyBSX09LIGlzIHJlYWQgY2hlY2tcbiAgLy8gV19PSyBpcyB3cml0ZSBjaGVja1xuICAvLyBYX09LIGlzIGV4ZWN1dGUgY2hlY2sgKGFjdHMgbGlrZSBGX09LIG9uIFdpbmRvd3MpXG4gIHZhciBmaWxlSGFuZGxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCk7XG5cbiAgaWYgKCFmaWxlSGFuZGxlLmV4aXN0cygpKSB7XG4gICAgdGhyb3cgbm9TdWNoRmlsZSgnYWNjZXNzJywgcGF0aCk7XG4gIH0gLy8gVE9ETzogV2UgaGF2ZSBubyBtZWFucyBvZiB0ZXN0aW5nIGlmIGEgZmlsZSBpcyByZWFkYWJsZS4gSXQncyBhc3N1bWVkIGFsbCBmaWxlcyB0aGF0IGV4aXN0IHVuZGVyIHRoZSBhcHAgYXJlP1xuXG5cbiAgaWYgKG1vZGUgJiBmcy5jb25zdGFudHMuV19PSyAmJiAhZmlsZUhhbmRsZS53cml0YWJsZSkge1xuICAgIHRocm93IHBlcm1pc3Npb25EZW5pZWQoJ2FjY2VzcycsIHBhdGgpO1xuICB9XG5cbiAgaWYgKG1vZGUgJiBmcy5jb25zdGFudHMuWF9PSyAmJiAhZmlsZUhhbmRsZS5leGVjdXRhYmxlICYmIGZpbGVIYW5kbGUuaXNGaWxlKCkpIHtcbiAgICB0aHJvdyBwZXJtaXNzaW9uRGVuaWVkKCdhY2Nlc3MnLCBwYXRoKTtcbiAgfVxufTtcbi8qKlxuICogQXN5bmNocm9ub3VzbHkgYXBwZW5kIGRhdGEgdG8gYSBmaWxlLCBjcmVhdGluZyB0aGUgZmlsZSBpZiBpdCBkb2VzIG5vdCB5ZXQgZXhpc3QuIGRhdGEgY2FuIGJlIGEgc3RyaW5nIG9yIGEgQnVmZmVyLlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTHxGaWxlU3RyZWFtfSBmaWxlIGZpbGVwYXRoIHRvIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YSBkYXRhIHRvIGFwcGVuZCB0byBmaWxlXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB0byB1c2VcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMubW9kZT0wbzY2Nl0gbW9kZSB0byBjcmVhdGUgZmlsZSwgaWYgbm90IGNyZWF0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mbGFnPSdhJ10gZmlsZSBzeXN0ZW0gZmxhZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCBiYWNrIHdpdGggZXJyb3IgaWYgZmFpbGVkXG4gKi9cblxuXG5mcy5hcHBlbmRGaWxlID0gKGZpbGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayB8fCBvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgbW9kZTogMG82NjYsXG4gICAgZmxhZzogJ2EnXG4gIH0pO1xuICBmcy53cml0ZUZpbGUoZmlsZSwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcbi8qKlxuICogU3luY2hyb25vdXNseSBhcHBlbmQgZGF0YSB0byBhIGZpbGUsIGNyZWF0aW5nIHRoZSBmaWxlIGlmIGl0IGRvZXMgbm90IHlldCBleGlzdC4gZGF0YSBjYW4gYmUgYSBzdHJpbmcgb3IgYSBCdWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfEZpbGVTdHJlYW19IGZpbGUgZmlsZXBhdGggdG8gZmlsZVxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBkYXRhIGRhdGEgdG8gYXBwZW5kIHRvIGZpbGVcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmOCddIGVuY29kaW5nIHRvIHVzZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5tb2RlPTBvNjY2XSBtb2RlIHRvIGNyZWF0ZSBmaWxlLCBpZiBub3QgY3JlYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZsYWc9J2EnXSBmaWxlIHN5c3RlbSBmbGFnXG4gKi9cblxuXG5mcy5hcHBlbmRGaWxlU3luYyA9IChmaWxlLCBkYXRhLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIG1vZGU6IDBvNjY2LFxuICAgIGZsYWc6ICdhJ1xuICB9KTtcbiAgZnMud3JpdGVGaWxlU3luYyhmaWxlLCBkYXRhLCBvcHRpb25zKTsgLy8gVE9ETzogVXNlIFRpLkZpbGVzeXN0ZW0uRmlsZS5hcHBlbmQoKSBpbnN0ZWFkP1xufTtcblxuZnMuY2htb2QgPSAocGF0aCwgbW9kZSwgY2FsbGJhY2spID0+IGFzeW5jVW5zdXBwb3J0ZWROb29wKCdmcycsICdjaG1vZCcsIGNhbGxiYWNrKTtcblxuZnMuY2htb2RTeW5jID0gdW5zdXBwb3J0ZWROb29wKCdmcycsICdjaG1vZFN5bmMnKTtcbi8qKlxuICogQ2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyB0aGF0IGNhbiBvbmx5IHRocm93IGVycm9yc1xuICpcbiAqIEBjYWxsYmFjayBlcnJvckNhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBbZXJyXSAtIEVycm9yIHRocm93blxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuXG5mcy5jbG9zZSA9IChmZCwgY2FsbGJhY2spID0+IHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLmNsb3NlU3luYyhmZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2soKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICovXG5cblxuZnMuY2xvc2VTeW5jID0gZmQgPT4ge1xuICB2YXIgc3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7XG4gIHN0cmVhbS5jbG9zZSgpO1xufTsgLy8gUmF0aGVyIHRoYW4gdXNlIGEgaGFjayB0byB3cmFwIHN5bmMgdmVyc2lvbiBpbiBzZXRUaW1lb3V0LCB1c2UgYWN0dWFsIGFzeW5jIEFQSXMhXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gc3JjIHNvdXJjZSBmaWxlbmFtZSB0byBjb3B5XG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBkZXN0IGRlc3RpbmF0aW9uIGZpbGVuYW1lIG9mIHRoZSBjb3B5IG9wZXJhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IFtmbGFncz0wXSBtb2RpZmllcnMgZm9yIGNvcHkgb3BlcmF0aW9uXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxlZCBhdCBlbmQgb2Ygb3BlcmF0aW9uXG4gKi9cblxuXG5mcy5jb3B5RmlsZSA9IGZ1bmN0aW9uIChzcmMsIGRlc3QsIGZsYWdzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGZsYWdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBmbGFncztcbiAgICBmbGFncyA9IDA7XG4gIH1cblxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spOyAvLyBGSVhNRTogSSBkb24ndCBrbm93IHdoeSwgYnV0IGNoYW5naW5nIHRoaXMgdG8gdXNlIFRpLkZpbGVzeXN0ZW0ub3BlblN0cmVhbShtb2RlLCBwYXRoKSBmYWlscyAoYXQgbGVhc3Qgb24gaU9TKVxuXG4gIHZhciBzcmNGaWxlID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKHNyYyk7XG4gIHZhciBzcmNTdHJlYW0gPSBzcmNGaWxlLm9wZW4oVGkuRmlsZXN5c3RlbS5NT0RFX1JFQUQpO1xuICB2YXIgZGVzdEZpbGUgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoZGVzdCk7XG4gIHZhciBkZXN0U3RyZWFtID0gZGVzdEZpbGUub3BlbihUaS5GaWxlc3lzdGVtLk1PREVfV1JJVEUpO1xuICBwaXBlKHNyY1N0cmVhbSwgZGVzdFN0cmVhbSwgY2FsbGJhY2spO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gc3JjIHNvdXJjZSBmaWxlbmFtZSB0byBjb3B5XG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBkZXN0IGRlc3RpbmF0aW9uIGZpbGVuYW1lIG9mIHRoZSBjb3B5IG9wZXJhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IFtmbGFncz0wXSBtb2RpZmllcnMgZm9yIGNvcHkgb3BlcmF0aW9uXG4gKi9cblxuXG5mcy5jb3B5RmlsZVN5bmMgPSBmdW5jdGlvbiAoc3JjLCBkZXN0LCBmbGFncyA9IDApIHtcbiAgdmFyIHNyY0ZpbGUgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoc3JjKTtcblxuICBpZiAoZmxhZ3MgPT09IGZzLmNvbnN0YW50cy5DT1BZRklMRV9FWENMICYmIGZzLmV4aXN0c1N5bmMoZGVzdCkpIHtcbiAgICB0aHJvdyBmaWxlQWxyZWFkeUV4aXN0cygnY29weUZpbGUnLCBkZXN0KTtcbiAgfVxuXG4gIGlmICghc3JjRmlsZS5jb3B5KGRlc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvcHkgXCIuY29uY2F0KHNyYywgXCIgdG8gXCIpLmNvbmNhdChkZXN0KSk7IC8vIEZJWE1FOiBXaGF0IGVycm9yIHNob3VsZCB3ZSBnaXZlP1xuICB9XG59OyAvLyBUT0RPOiBmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG4vLyAvKipcbi8vICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggcGF0aCBsaWtlXG4vLyAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zLCBpZiBhIHN0cmluZywgaXQncyB0aGUgZW5jb2Rpbmdcbi8vICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mbGFncz0nciddIFNlZSBzdXBwb3J0IG9mIGZpbGUgc3lzdGVtIGZsYWdzLlxuLy8gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPW51bGxdIGVuY29kaW5nXG4vLyAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLmZkPW51bGxdIGZpbGUgZGVzY3JpcHRvciwgaWYgc3BlY2lmaWVkLCBgcGF0aGAgaXMgaWdub3JlZFxuLy8gICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5tb2RlPTBvNjY2XSBwZXJtaXNzaW9ucyB0byBzZXQgaWYgZmlsZSBpcyBjcmVhdGVkXG4vLyAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9DbG9zZT10cnVlXSBpZiBmYWxzZSwgZmlsZSBkZXNjcmlwdG9yIHdpbGwgbm90IGJlIGNsb3NlZDsgaWYgdHJ1ZSBldmVuIG9uIGVycm9yIGl0IHdpbGwgYmUgY2xvc2VkXG4vLyAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLnN0YXJ0XSBzdGFydCBpbmRleCBvZiByYW5nZSBvZiBieXRlcyB0byByZWFkIGZyb20gZmlsZVxuLy8gICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5lbmQ9SW5maW5pdHldIGVuZCBpbmRleCBvZiByYW5nZSBvZiBieXRlcyB0byByZWFkIGZyb20gZmlsZVxuLy8gICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5oaWdoV2F0ZXJNYXJrPTY0ICogMTAyNF1cbi8vICAqIEByZXR1cm5zIHtmcy5SZWFkU3RyZWFtfVxuLy8gICovXG4vLyBmcy5jcmVhdGVSZWFkU3RyZWFtID0gKHBhdGgsIG9wdGlvbnMpID0+IHtcbi8vIFx0b3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywgeyBmbGFnczogJ3InLCBlbmNvZGluZzogbnVsbCwgZmQ6IG51bGwsIG1vZGU6IDBvNjY2LCBhdXRvQ2xvc2U6IHRydWUsIGVuZDogSW5maW5pdHksIGhpZ2hXYXRlck1hcms6IDY0ICogMTAyNCB9KTtcbi8vIFx0Ly8gRklYTUU6IElmIG9wdGlvbnMuZmQsIHVzZSB0aGF0IGluIHBsYWNlIG9mIHBhdGghXG4vLyBcdGNvbnN0IHRpRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpO1xuLy8gfTtcbi8vIFRPRE86IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG5cbi8qKlxuICogQGNhbGxiYWNrIGV4aXN0c0NhbGxiYWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4aXN0cyAtIHdoZXRoZXIgcGF0aCBleGlzdHNcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGggdG8gY2hlY2tcbiAqIEBwYXJhbSB7ZXhpc3RzQ2FsbGJhY2t9IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuXG5cbmZzLmV4aXN0cyA9IGZ1bmN0aW9uIChwYXRoLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBjYWxsYmFjayhmcy5leGlzdHNTeW5jKHBhdGgpKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBwYXRoIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBhIGZpbGUgb3IgZGlyZWN0b3J5IGV4aXN0cyBhdCB0aGF0IHBhdGhcbiAqL1xuXG5cbmZzLmV4aXN0c1N5bmMgPSBmdW5jdGlvbiAocGF0aCkge1xuICB0cnkge1xuICAgIGZzLmFjY2Vzc1N5bmMocGF0aCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZzLmZjaG1vZCA9IChmZCwgbW9kZSwgY2FsbGJhY2spID0+IGFzeW5jVW5zdXBwb3J0ZWROb29wKCdmcycsICdmY2htb2QnLCBjYWxsYmFjayk7XG5cbmZzLmZjaG1vZFN5bmMgPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2ZjaG1vZFN5bmMnKTtcblxuZnMuZmNob3duID0gKGZkLCB1aWQsIGdpZCwgY2FsbGJhY2spID0+IGFzeW5jVW5zdXBwb3J0ZWROb29wKCdmcycsICdmY2hvd24nLCBjYWxsYmFjayk7XG5cbmZzLmZjaG93blN5bmMgPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2ZjaG93blN5bmMnKTtcblxuZnMuZmRhdGFzeW5jID0gKGZkLCBjYWxsYmFjaykgPT4gYXN5bmNVbnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2ZkYXRhc3luYycsIGNhbGxiYWNrKTtcblxuZnMuZmRhdGFzeW5jU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnZmRhdGFzeW5jU3luYycpO1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJpZ2ludF0gd2hldGhlciBzdGF0IHZhbHVlcyBzaG91bGQgYmUgYmlnaW50XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBhc3luYyBjYWxsYmFjayBmdW5jdGlvblxuICovXG5cbmZzLmZzdGF0ID0gKGZkLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdmFyIHN0YXRzO1xuXG4gICAgdHJ5IHtcbiAgICAgIHN0YXRzID0gZnMuZnN0YXRTeW5jKGZkLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCBzdGF0cyk7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbX29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW19vcHRpb25zLmJpZ2ludF0gd2hldGhlciBzdGF0IHZhbHVlcyBzaG91bGQgYmUgYmlnaW50XG4gKiBAcmV0dXJucyB7ZnMuU3RhdHN9IHN0YXRzIGZvciBmaWxlIGRlc2NyaXB0b3JcbiAqL1xuXG5cbmZzLmZzdGF0U3luYyA9IChmZCwgX29wdGlvbnMpID0+IHtcbiAgdmFyIHBhdGggPSBwYXRoRm9yRmlsZURlc2NyaXB0b3IoZmQpO1xuICByZXR1cm4gZnMuc3RhdFN5bmMocGF0aCk7XG59OyAvLyBUT0RPOiBBZGQgdmVyc2lvbnMgb2YgdGhlc2UgQVBJczpcbi8vIGZzLmZzeW5jKGZkLCBjYWxsYmFjaylcbi8vIGZzLmZzeW5jU3luYyhmZClcbi8vIGZzLmZ0cnVuY2F0ZShmZFssIGxlbl0sIGNhbGxiYWNrKVxuLy8gZnMuZnRydW5jYXRlU3luYyhmZFssIGxlbl0pXG4vLyBmcy5mdXRpbWVzKGZkLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrKVxuLy8gZnMuZnV0aW1lc1N5bmMoZmQsIGF0aW1lLCBtdGltZSlcbi8vIGZzLmxjaG1vZChwYXRoLCBtb2RlLCBjYWxsYmFjaylcbi8vIGZzLmxjaG1vZFN5bmMocGF0aCwgbW9kZSlcbi8vIGZzLmxjaG93bihwYXRoLCB1aWQsIGdpZCwgY2FsbGJhY2spXG4vLyBmcy5sY2hvd25TeW5jKHBhdGgsIHVpZCwgZ2lkKVxuLy8gZnMubGluayhleGlzdGluZ1BhdGgsIG5ld1BhdGgsIGNhbGxiYWNrKVxuLy8gZnMubGlua1N5bmMoZXhpc3RpbmdQYXRoLCBuZXdQYXRoKVxuLy8gRklYTUU6IElmIHN5bWJvbGljIGxpbmsgd2UgbmVlZCB0byBmb2xsb3cgbGluayB0byB0YXJnZXQgdG8gZ2V0IHN0YXRzISBPdXIgQVBJIGRvZXNuJ3Qgc3VwcG9ydCB0aGF0IVxuXG5cbmZzLmxzdGF0ID0gKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiBmcy5zdGF0KHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKTtcblxuZnMubHN0YXRTeW5jID0gKHBhdGgsIG9wdGlvbnMpID0+IGZzLnN0YXRTeW5jKHBhdGgsIG9wdGlvbnMpO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWN1cnNpdmU9ZmFsc2VdIHJlY3Vyc2l2bGV5IGNyZWF0ZSBkaXJzP1xuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5tb2RlPTBvNzc3XSBwZXJtaXNzaW9uc1xuICogQHBhcmFtIHtlcnJvckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnMubWtkaXIgPSAocGF0aCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICByZWN1cnNpdmU6IGZhbHNlLFxuICAgICAgbW9kZTogMG83NzdcbiAgICB9O1xuICB9XG5cbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLm1rZGlyU3luYyhwYXRoLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWN1cnNpdmU9ZmFsc2VdIHJlY3Vyc2l2bGV5IGNyZWF0ZSBkaXJzP1xuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5tb2RlPTBvNzc3XSBwZXJtaXNzaW9uc1xuICovXG5cblxuZnMubWtkaXJTeW5jID0gKHBhdGgsIG9wdGlvbnMpID0+IHtcbiAgdmFyIHRpRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgcmVjdXJzaXZlOiBmYWxzZSxcbiAgICAgIG1vZGU6IG9wdGlvbnNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIHJlY3Vyc2l2ZTogZmFsc2UsXG4gICAgICBtb2RlOiAwbzc3N1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCF0aUZpbGUuY3JlYXRlRGlyZWN0b3J5KG9wdGlvbnMucmVjdXJzaXZlKSAmJiAhb3B0aW9ucy5yZWN1cnNpdmUpIHtcbiAgICBpZiAodGlGaWxlLmV4aXN0cygpKSB7XG4gICAgICAvLyBhbHJlYWR5IGV4aXN0ZWQhXG4gICAgICB0aHJvdyBmaWxlQWxyZWFkeUV4aXN0cygnbWtkaXInLCBwYXRoKTtcbiAgICB9IC8vIFdlIGZhaWxlZCwgcHJvYmFibHkgYmVjYXVzZSB3ZSBkaWRuJ3QgYXNrIGZvciByZWN1cnNpdmUgYW5kIHBhcmVudCBkb2Vzbid0IGV4aXN0LCBzbyByZXByb2R1Y2Ugbm9kZSdzIGVycm9yXG5cblxuICAgIHRocm93IG5vU3VjaEZpbGUoJ21rZGlyJywgcGF0aCk7XG4gIH1cbn07XG4vKipcbiAqIEBjYWxsYmFjayB0ZW1wRGlyQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlciAtIGdlbmVyYXRlZCBmb2xkZXIgbmFtZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCBkaXJlY3RvcnkgbmFtZSBwcmVmaXhcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmLTgnXSBwcmVmaXggZW5jb2RpbmdcbiAqIEBwYXJhbSB7dGVtcERpckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnMubWtkdGVtcCA9IChwcmVmaXgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShwcmVmaXgsICdwcmVmaXgnLCAnc3RyaW5nJyk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0Zi04J1xuICB9KTsgLy8gdHJ5IHRvIGJlIGFsbCBhc3luY1xuXG4gIHZhciB0cnlNa2R0ZW1wID0gKCkgPT4ge1xuICAgIHZhciBnZW5lcmF0ZWQgPSByYW5kb21DaGFyYWN0ZXJzKDYsIG9wdGlvbnMuZW5jb2RpbmcpOyAvLyBnZW5lcmF0ZSBzaXggcmFuZG9tIGNoYXJhY3RlcnNcblxuICAgIHZhciBwYXRoID0gXCJcIi5jb25jYXQocHJlZml4KS5jb25jYXQoZ2VuZXJhdGVkKTtcbiAgICBmcy5ta2RpcihwYXRoLCAwbzcwMCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRUVYSVNUJykge1xuICAgICAgICAgIC8vIHJldHJ5IVxuICAgICAgICAgIHNldFRpbWVvdXQodHJ5TWtkdGVtcCwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIGJ1YmJsZSB1cCBlcnJvclxuXG5cbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBzdWNjZWVkZWQhIEh1cnJheSFcblxuXG4gICAgICBjYWxsYmFjayhudWxsLCBwYXRoKTtcbiAgICB9KTtcbiAgfTtcblxuICBzZXRUaW1lb3V0KHRyeU1rZHRlbXAsIDEpO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIHVuaXF1ZSB0ZW1wb3JhcnkgZGlyZWN0b3J5LlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCBkaXJlY3RvcnkgbmFtZSBwcmVmaXhcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmLTgnXSBwcmVmaXggZW5jb2RpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHBhdGggdG8gY3JlYXRlZCBkaXJlY3RvcnlcbiAqL1xuXG5cbmZzLm1rZHRlbXBTeW5jID0gKHByZWZpeCwgb3B0aW9ucykgPT4ge1xuICBhc3NlcnRBcmd1bWVudFR5cGUocHJlZml4LCAncHJlZml4JywgJ3N0cmluZycpO1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGYtOCdcbiAgfSk7XG4gIHZhciByZXRyeUNvdW50ID0gMDtcbiAgdmFyIE1BWF9SRVRSSUVTID0gMTAwO1xuXG4gIHdoaWxlIChyZXRyeUNvdW50IDwgTUFYX1JFVFJJRVMpIHtcbiAgICB2YXIgZ2VuZXJhdGVkID0gcmFuZG9tQ2hhcmFjdGVycyg2LCBvcHRpb25zLmVuY29kaW5nKTsgLy8gZ2VuZXJhdGUgc2l4IHJhbmRvbSBjaGFyYWN0ZXJzXG5cbiAgICB2YXIgX3BhdGggPSBcIlwiLmNvbmNhdChwcmVmaXgpLmNvbmNhdChnZW5lcmF0ZWQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZzLm1rZGlyU3luYyhfcGF0aCwgMG83MDApOyAvLyBkb24ndCB0cnkgcmVjdXJzaXZlXG5cbiAgICAgIHJldHVybiBfcGF0aDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5jb2RlICE9PSAnRUVYSVNUJykge1xuICAgICAgICB0aHJvdyBlOyAvLyBidWJibGUgdXAgZXJyb3JcbiAgICAgIH0gLy8gbmFtZSB3YXMgbm90IHVuaXF1ZSwgc28gcmV0cnlcblxuXG4gICAgICByZXRyeUNvdW50Kys7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBhIHVuaXF1ZSBkaXJlY3RvcnkgbmFtZSB3aXRoIHByZWZpeCBcIi5jb25jYXQocHJlZml4KSk7XG59O1xuLyoqXG4gKiBAY2FsbGJhY2sgZmlsZURlc2NyaXB0b3JDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZpbGVEZXNjcmlwdG9yIC0gZ2VuZXJhdGVkIGZpbGUgZGVzY3JpcHRvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBwYXRoIHRvIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3M9J3InXSBmaWxlIHN5c3RlbSBhY2Nlc3MgZmxhZ3NcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW21vZGU9MG82NjZdIGZpbGUgbW9kZSB0byB1c2Ugd2hlbiBjcmVhdGluZyBmaWxlXG4gKiBAcGFyYW0ge2ZpbGVEZXNjcmlwdG9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mcy5vcGVuID0gKHBhdGgsIGZsYWdzLCBtb2RlLCBjYWxsYmFjaykgPT4ge1xuICAvLyBmbGFncyBhbmQgbW9kZSBhcmUgb3B0aW9uYWwsIHdlIG5lZWQgdG8gaGFuZGxlIGlmIG5vdCBzdXBwbGllZCFcbiAgaWYgKHR5cGVvZiBmbGFncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gZmxhZ3M7XG4gICAgZmxhZ3MgPSAncic7XG4gICAgbW9kZSA9IDBvNjY2O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBtb2RlO1xuICAgIG1vZGUgPSAwbzY2NjtcbiAgfVxuXG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHZhciBmaWxlRGVzY3JpcHRvcjtcblxuICAgIHRyeSB7XG4gICAgICBmaWxlRGVzY3JpcHRvciA9IGZzLm9wZW5TeW5jKHBhdGgsIGZsYWdzLCBtb2RlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCBmaWxlRGVzY3JpcHRvcik7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBwYXRoIHRvIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3M9J3InXSBmaWxlIHN5c3RlbSBhY2Nlc3MgZmxhZ3NcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW19tb2RlPTBvNjY2XSBmaWxlIG1vZGUgdG8gdXNlIHdoZW4gY3JlYXRpbmcgZmlsZVxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5mcy5vcGVuU3luYyA9IChwYXRoLCBmbGFncyA9ICdyJywgX21vZGUgPSAwbzY2NikgPT4ge1xuICB2YXIgdGlGaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCk7XG5cbiAgaWYgKCF0aUZpbGUuZXhpc3RzKCkpIHtcbiAgICAvLyBUT0RPOiBTdXBwb3J0IGNyZWF0aW5nIGZpbGUgd2l0aCBzcGVjaWZpYyBtb2RlXG4gICAgb25lVGltZVdhcm5pbmcoJ2ZzLm9wZW5TeW5jLm1vZGUnLCAnZnMub3BlblN5bmNcXCdzIG1vZGUgcGFyYW1ldGVyIGlzIHVuc3VwcG9ydGVkIGluIFRpdGFuaXVtIGFuZCB3aWxsIGJlIGlnbm9yZWQnKTtcblxuICAgIGlmICghdGlGaWxlLmNyZWF0ZUZpbGUoKSkge1xuICAgICAgLy8gT2ggY3JhcCwgd2UgZmFpbGVkIHRvIGNyZWF0ZSB0aGUgZmlsZS4gd2h5P1xuICAgICAgaWYgKCF0aUZpbGUucGFyZW50LmV4aXN0cygpKSB7XG4gICAgICAgIC8vIHBhcmVudCBkb2VzIG5vdCBleGlzdCFcbiAgICAgICAgdGhyb3cgbm9TdWNoRmlsZSgnb3BlbicsIHBhdGgpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gY3JlYXRlIGZpbGUgYXQgcGF0aCBcIi5jb25jYXQocGF0aCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmbGFncykge1xuICAgIC8vIGZpbGUvZGlyIGV4aXN0cy4uLlxuICAgIGlmICgoZmxhZ3MuY2hhckF0KDApID09PSAndycgfHwgZmxhZ3MuY2hhckF0KDApID09PSAnYScpICYmIHRpRmlsZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAvLyBJZiB1c2VyIGlzIHRyeWluZyB0byB3cml0ZSBvciBhcHBlbmQgYW5kIGl0J3MgYSBkaXJlY3RvcnksIGZhaWxcbiAgICAgIHRocm93IGlsbGVnYWxPcGVyYXRpb25PbkFEaXJlY3RvcnkoJ29wZW4nLCBwYXRoKTtcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MubGVuZ3RoID4gMSAmJiBmbGFncy5jaGFyQXQoMSkgPT09ICd4Jykge1xuICAgICAgLy8gSWYgdXNlciBoYXMgXCJleGNsdXNpdmVcIiBmbGFnIG9uLCBmYWlsIGlmIGZpbGUgYWxyZWFkeSBleGlzdHNcbiAgICAgIHRocm93IGZpbGVBbHJlYWR5RXhpc3RzKCdvcGVuJywgcGF0aCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRpTW9kZSA9IEZMQUdTX1RPX1RJX01PREUuZ2V0KGZsYWdzKTtcblxuICBpZiAodGlNb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUT0RPOiBNYWtlIHVzZSBvZiBjb21tb24gZXJyb3IgdHlwZS9jb2RlIGZvciB0aGlzIG9uY2Ugd2UgaGF2ZSBpbnRlcm5hbC9lcnJvcnMuanNcbiAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcihcIlRoZSB2YWx1ZSBcXFwiXCIuY29uY2F0KFN0cmluZyhmbGFncyksIFwiXFxcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXFxcImZsYWdzXFxcIlwiKSk7XG4gICAgZXJyLmNvZGUgPSAnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJztcbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlRmlsZURlc2NyaXB0b3IocGF0aCwgdGlGaWxlLm9wZW4odGlNb2RlKSk7XG59O1xuLyoqXG4gKiBAY2FsbGJhY2sgcmVhZENhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciBpZiBvbmUgb2NjdXJyZWRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZXNSZWFkIC0gbnVtYmVyIG9mIGJ5dGVzIHJlYWRcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgYnVmZmVyXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtCdWZmZXJ8VGkuQnVmZmVyfSBidWZmZXIgYnVmZmVyIHRvIHJlYWQgaW50b1xuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgdGhlIG9mZnNldCBpbiB0aGUgYnVmZmVyIHRvIHN0YXJ0IHdyaXRpbmcgYXQuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBwb3NpdGlvbiB3aGVyZSB0byBiZWdpbiByZWFkaW5nIGZyb20gaW4gdGhlIGZpbGVcbiAqIEBwYXJhbSB7cmVhZENhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnMucmVhZCA9IChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHZhciB0aUZpbGVTdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZkKTtcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyKTtcbiAgfSAvLyBGSVhNRTogQWxsb3cgdXNpbmcgcG9zaXRpb24gYXJndW1lbnQhXG5cblxuICBpZiAocG9zaXRpb24gIT09IG51bGwpIHtcbiAgICBvbmVUaW1lV2FybmluZygnZnMucmVhZFN5bmMucG9zaXRpb24nLCAnZnMucmVhZFN5bmNcXCdzIHBvc2l0aW9uIGFyZ3VtZW50IGlzIHVuc3VwcG9ydGVkIGJ5IFRpdGFuaXVtIGFuZCB3aWxsIGJlIHRyZWF0ZWQgYXMgbnVsbCcpO1xuICB9XG5cbiAgdGlGaWxlU3RyZWFtLnJlYWQoYnVmZmVyLnRvVGlCdWZmZXIoKSwgb2Zmc2V0LCBsZW5ndGgsIHJlYWRPYmogPT4ge1xuICAgIGlmICghcmVhZE9iai5zdWNjZXNzKSB7XG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3IocmVhZE9iai5lcnJvcikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHJlYWRPYmouYnl0ZXNQcm9jZXNzZWQsIGJ1ZmZlcik7XG4gIH0pO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfFRpLkJ1ZmZlcn0gYnVmZmVyIGJ1ZmZlciB0byByZWFkIGludG9cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IHRoZSBvZmZzZXQgaW4gdGhlIGJ1ZmZlciB0byBzdGFydCB3cml0aW5nIGF0LlxuICogQHBhcmFtIHtpbnRlZ2VyfSBsZW5ndGggaW50ZWdlciBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gX3Bvc2l0aW9uIHdoZXJlIHRvIGJlZ2luIHJlYWRpbmcgZnJvbSBpbiB0aGUgZmlsZVxuICogQHJldHVybnMge2ludGVnZXJ9IGJ5dGVzIHJlYWRcbiAqL1xuXG5cbmZzLnJlYWRTeW5jID0gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBfcG9zaXRpb24pID0+IHtcbiAgdmFyIGZpbGVTdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZkKTtcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyKTtcbiAgfSAvLyBGSVhNRTogQWxsb3cgdXNpbmcgcG9zaXRpb24gYXJndW1lbnQhXG5cblxuICBpZiAoX3Bvc2l0aW9uICE9PSBudWxsKSB7XG4gICAgb25lVGltZVdhcm5pbmcoJ2ZzLnJlYWRTeW5jLnBvc2l0aW9uJywgJ2ZzLnJlYWRTeW5jXFwncyBwb3NpdGlvbiBhcmd1bWVudCBpcyB1bnN1cHBvcnRlZCBieSBUaXRhbml1bSBhbmQgd2lsbCBiZSB0cmVhdGVkIGFzIG51bGwnKTtcbiAgfVxuXG4gIHJldHVybiBmaWxlU3RyZWFtLnJlYWQoYnVmZmVyLnRvVGlCdWZmZXIoKSwgb2Zmc2V0LCBsZW5ndGgpO1xufTtcbi8qKlxuICogQGNhbGxiYWNrIGZpbGVzQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtzdHJpbmdbXXxCdWZmZXJbXXxmcy5EaXJlbnRbXX0gZmlsZXMgLSBmaWxlIGxpc3RpbmdcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGRpcmVjdG9yeSB0byBsaXN0XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB0byB1c2UgZm9yIGZpbGVuYW1lcywgaWYgYCdidWZmZXInYCwgcmV0dXJucyBgQnVmZmVyYCBvYmplY3RzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLndpdGhGaWxlVHlwZXM9ZmFsc2VdIGlmIHRydWUsIHJldHVybnMgYGZzLkRpcmVudGAgb2JqZWN0c1xuICogQHBhcmFtIHtmaWxlc0NhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnMucmVhZGRpciA9IChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBmcy5yZWFkZGlyU3luYyhwYXRoLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICB9LCAxKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlcGF0aCBkaXJlY3RvcnkgdG8gbGlzdFxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPSd1dGY4J10gZW5jb2RpbmcgdG8gdXNlIGZvciBmaWxlbmFtZXMsIGlmIGAnYnVmZmVyJ2AsIHJldHVybnMgYEJ1ZmZlcmAgb2JqZWN0c1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy53aXRoRmlsZVR5cGVzPWZhbHNlXSBpZiB0cnVlLCByZXR1cm5zIGBmcy5EaXJlbnRgIG9iamVjdHNcbiAqIEByZXR1cm5zIHtzdHJpbmdbXXxCdWZmZXJbXXxmcy5EaXJlbnRbXX1cbiAqL1xuXG5cbmZzLnJlYWRkaXJTeW5jID0gKGZpbGVwYXRoLCBvcHRpb25zKSA9PiB7XG4gIHZhciBmaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUoZmlsZXBhdGgpO1xuXG4gIGlmICghZmlsZS5leGlzdHMoKSkge1xuICAgIHRocm93IG5vU3VjaEZpbGUoJ3NjYW5kaXInLCBmaWxlcGF0aCk7XG4gIH1cblxuICBpZiAoIWZpbGUuaXNEaXJlY3RvcnkoKSkge1xuICAgIHRocm93IG5vdEFEaXJlY3RvcnkoJ3NjYW5kaXInLCBmaWxlcGF0aCk7XG4gIH1cblxuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGYtOCcsXG4gICAgd2l0aEZpbGVUeXBlczogZmFsc2VcbiAgfSk7XG4gIHZhciBsaXN0aW5nID0gZmlsZS5nZXREaXJlY3RvcnlMaXN0aW5nKCk7XG5cbiAgaWYgKG9wdGlvbnMud2l0aEZpbGVUeXBlcyA9PT0gdHJ1ZSkge1xuICAgIC8vIFRPRE86IGlmIG9wdGlvbnMud2l0aEZpbGVUeXBlcyA9PT0gdHJ1ZSwgcmV0dXJuIGZzLkRpcmVudCBvYmplY3RzXG4gICAgb25lVGltZVdhcm5pbmcoJ2ZzLnJlYWRkaXJcXCdzIG9wdGlvbnMud2l0aEZpbGVUeXBlcyBpcyB1bnN1cHBvcnRlZCBieSBUaXRhbml1bSBhbmQgc3RyaW5ncyB3aWxsIGJlIHJldHVybmVkJyk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gJ2J1ZmZlcicpIHtcbiAgICByZXR1cm4gbGlzdGluZy5tYXAobmFtZSA9PiBCdWZmZXIuZnJvbShuYW1lKSk7XG4gIH1cblxuICByZXR1cm4gbGlzdGluZztcbn07XG4vKipcbiAqIEBjYWxsYmFjayByZWFkRmlsZVBvc3RPcGVuQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtUaS5CdWZmZXJ9IGJ1ZmZlclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmaWxlRGVzY3JpcHRvciBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7cmVhZEZpbGVQb3N0T3BlbkNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnVuY3Rpb24gcmVhZEZpbGVQb3N0T3BlbihmaWxlRGVzY3JpcHRvciwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgZnMuZnN0YXQoZmlsZURlc2NyaXB0b3IsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZmlsZVNpemUgPSBzdGF0cy5zaXplOyAvLyBDcmVhdGUgYSBUaS5CdWZmZXIgdG8gcmVhZCBpbnRvXG5cbiAgICB2YXIgYnVmZmVyID0gVGkuY3JlYXRlQnVmZmVyKHtcbiAgICAgIGxlbmd0aDogZmlsZVNpemVcbiAgICB9KTsgLy8gVXNlIFRpLlN0cmVhbS5yZWFkQWxsKHNvdXJjZVN0cmVhbSwgYnVmZmVyLCBjYWxsYmFjaykgd2hpY2ggc3BpbnMgb2ZmIGEgc2VwYXJhdGUgdGhyZWFkIHRvIHJlYWQgaW4gd2hpbGUgbG9vcCFcblxuICAgIHZhciBzb3VyY2VTdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZpbGVEZXNjcmlwdG9yKTtcbiAgICBUaS5TdHJlYW0ucmVhZEFsbChzb3VyY2VTdHJlYW0sIGJ1ZmZlciwgcmVhZEFsbE9iaiA9PiB7XG4gICAgICBpZiAoIXJlYWRBbGxPYmouc3VjY2Vzcykge1xuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IocmVhZEFsbE9iai5lcnJvcikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGJ1ZmZlcik7XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXG4gKiBAY2FsbGJhY2sgcmVhZEZpbGVDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHJlYWQgZW50aXJlIGNvbnRlbnRzIG9mIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx8aW50ZWdlcn0gcGF0aCBmaWxlbmFtZSBvciBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz1udWxsXSBlbmNvZGluZyB0byB1c2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mbGFnPSdyJ10gZmlsZSBzeXN0ZW0gZmxhZ1xuICogQHBhcmFtIHtyZWFkRmlsZUNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnMucmVhZEZpbGUgPSAocGF0aCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBlbmNvZGluZzogbnVsbCxcbiAgICAgIGZsYWc6ICdyJ1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgICAgZW5jb2Rpbmc6IG51bGwsXG4gICAgICBmbGFnOiAncidcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHZhciB3YXNGaWxlRGVzY3JpcHRvciA9IHR5cGVvZiBwYXRoID09PSAnbnVtYmVyJztcbiAgdmFyIGZpbGVEZXNjcmlwdG9yID0gcGF0aDsgLy8gbWF5IGJlIG92ZXJyaWRlbiBsYXRlclxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgcG9zc2libGUgRXJyb3JcbiAgICogQHBhcmFtIHtUaS5CdWZmZXJ9IGJ1ZmZlciBUaS5CdWZmZXIgaW5zdGFuY2VcbiAgICovXG5cbiAgdmFyIGhhbmRsZUJ1ZmZlciA9IChlcnIsIGJ1ZmZlcikgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBmcy5jbG9zZVN5bmMgaWYgaXQgd2FzIG5vdCBvcmlnaW5hbGx5IGEgZmlsZSBkZXNjcmlwdG9yXG5cblxuICAgIGlmICghd2FzRmlsZURlc2NyaXB0b3IpIHtcbiAgICAgIGZzLmNsb3NlU3luYyhmaWxlRGVzY3JpcHRvcik7XG4gICAgfSAvLyBUT0RPOiB0cmltIGJ1ZmZlciBpZiB3ZSBkaWRuJ3QgcmVhZCBmdWxsIHNpemU/XG5cblxuICAgIGNhbGxiYWNrKG51bGwsIGVuY29kZUJ1ZmZlcihvcHRpb25zLmVuY29kaW5nLCBidWZmZXIpKTtcbiAgfTtcblxuICBpZiAoIXdhc0ZpbGVEZXNjcmlwdG9yKSB7XG4gICAgZnMub3BlbihwYXRoLCBvcHRpb25zLmZsYWcsIChlcnIsIGZkKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZmlsZURlc2NyaXB0b3IgPSBmZDtcbiAgICAgIHJlYWRGaWxlUG9zdE9wZW4oZmQsIGhhbmRsZUJ1ZmZlcik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVhZEZpbGVQb3N0T3BlbihwYXRoLCBoYW5kbGVCdWZmZXIpO1xuICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGUgcGF0aC5cbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx8aW50ZWdlcn0gcGF0aCBwYXRoIHRvIGZpbGVcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz1udWxsXSBlbmNvZGluZyB0byB1c2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mbGFnPSdyJ10gZmlsZSBzeXN0ZW0gZmxhZ1xuICogQHJldHVybnMge3N0cmluZ3xCdWZmZXJ9IHN0cmluZyBpZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQsIG90aGVyd2lzZSBCdWZmZXJcbiAqL1xuXG5cbmZzLnJlYWRGaWxlU3luYyA9IChwYXRoLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogbnVsbCxcbiAgICBmbGFnOiAncidcbiAgfSk7XG4gIHZhciB3YXNGaWxlRGVzY3JpcHRvciA9IHR5cGVvZiBwYXRoID09PSAnbnVtYmVyJztcbiAgdmFyIGZpbGVEZXNjcmlwdG9yID0gd2FzRmlsZURlc2NyaXB0b3IgPyBwYXRoIDogZnMub3BlblN5bmMocGF0aCwgb3B0aW9ucy5mbGFnKTsgLy8gdXNlIGRlZmF1bHQgbW9kZVxuXG4gIHZhciB0aUZpbGVTdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZpbGVEZXNjcmlwdG9yKTsgLy8gSnVzdCB1c2Ugb3VyIG93biBBUEkgdGhhdCByZWFkcyBmdWxsIHN0cmVhbSBpblxuXG4gIHZhciBidWZmZXIgPSBUaS5TdHJlYW0ucmVhZEFsbCh0aUZpbGVTdHJlYW0pOyAvLyBmcy5jbG9zZVN5bmMgaWYgaXQgd2FzIG5vdCBvcmlnaW5hbGx5IGEgZmlsZSBkZXNjcmlwdG9yXG5cbiAgaWYgKCF3YXNGaWxlRGVzY3JpcHRvcikge1xuICAgIGZzLmNsb3NlU3luYyhmaWxlRGVzY3JpcHRvcik7XG4gIH0gLy8gVE9ETzogdHJpbSBidWZmZXIgaWYgd2UgZGlkbid0IHJlYWQgZnVsbCBzaXplP1xuXG5cbiAgcmV0dXJuIGVuY29kZUJ1ZmZlcihvcHRpb25zLmVuY29kaW5nLCBidWZmZXIpO1xufTsgLy8gVE9ETzogZnMucmVhZGxpbmsocGF0aFssIG9wdGlvbnNdLCBjYWxsYmFjaylcbi8vIFRPRE86IGZzLnJlYWRsaW5rU3luYyhwYXRoWywgb3B0aW9uc10pXG5cbi8qKlxuICogQGNhbGxiYWNrIHJlYWxwYXRoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSByZXNvbHZlZFBhdGggdGhlIHJlc29sdmVkIHBhdGhcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IGZpbGVwYXRoIG9yaWdpbmFsIGZpbGVwYXRoXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIG9wdGlvc24gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB1c2VkIGZvciByZXR1cm5lZCBvYmplY3QuIElmICdidWZmZXJcIiwgd2UnbGwgcmV0dXJuIGEgQnVmZmVyIGluIHBhbGNlIG9mIGEgc3RyaW5nXG4gKiBAcGFyYW0ge3JlYWxwYXRoQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mcy5yZWFscGF0aCA9IChmaWxlcGF0aCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrIHx8IG9wdGlvbnMpO1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGY4J1xuICB9KTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBubyBzeW1saW5rcywgd2hpY2ggd2UgcmVhbGx5IGRvbid0IGhhdmUgZnVsbCBzdXBwb3J0IGZvciBpbiBvdXIgU0RLIGFueXdheXMuXG4gICAgdmFyIHJlc3VsdCA9IHBhdGgkMS5ub3JtYWxpemUoZmlsZXBhdGgpO1xuICAgIGZzLmV4aXN0cyhyZXN1bHQsIHJlc3VsdEV4aXN0cyA9PiB7XG4gICAgICBpZiAocmVzdWx0RXhpc3RzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmVuY29kaW5nID09PSAnYnVmZmVyJykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBCdWZmZXIuZnJvbShyZXN1bHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgfSAvLyB0aGlzIHBhdGggZG9lc24ndCBleGlzdCwgdHJ5IGVhY2ggc2VnbWVudCB1bnRpbCB3ZSBmaW5kIGZpcnN0IHRoYXQgZG9lc24ndFxuXG5cbiAgICAgIHZhciBzZWdtZW50cyA9IHJlc3VsdC5zcGxpdChwYXRoJDEuc2VwKTsgLy8gRklYTUU6IERyb3AgbGFzdCBzZWdtZW50IGFzIHdlIGFscmVhZHkga25vdyB0aGUgZnVsbCBwYXRoIGRvZXNuJ3QgZXhpc3Q/XG5cbiAgICAgIHZhciBwYXJ0aWFsRmlsZVBhdGggPSAnJztcbiAgICAgIHZhciBpbmRleCA9IDA7IC8vIGhhbmRsZSB0eXBpY2FsIGNhc2Ugb2YgZW1wdHkgZmlyc3Qgc2VnbWVudCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFuIGFzeW5jIHNldFRpbWVvdXQgdG8gZ2V0IHRvIGZpcnN0IHJlYWwgY2FzZVxuXG4gICAgICBpZiAoc2VnbWVudHNbaW5kZXhdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuXG4gICAgICBzZXRUaW1lb3V0KHRyeVBhdGgsIDEpO1xuXG4gICAgICBmdW5jdGlvbiB0cnlQYXRoKCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gZG9uJ3QgcnVuIHBhc3QgZW5kIG9mIHNlZ21lbnRzLCB0aHJvdyBlcnJvciBmb3IgcmVzb2x2ZWQgcGF0aFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhub1N1Y2hGaWxlKHJlc3VsdCkpO1xuICAgICAgICB9IC8vIGdyYWIgbmV4dCBzZWdtZW50XG5cblxuICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4KytdO1xuXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vIGlmIGl0J3MgYW4gZW1wdHkgc2VnbWVudC4uLlxuICAgICAgICAgIC8vIHRyeSBhZ2FpbiBhdCBuZXh0IGluZGV4XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQodHJ5UGF0aCwgMSk7XG4gICAgICAgIH0gLy8gbm9ybWFsIGNhc2VcblxuXG4gICAgICAgIHBhcnRpYWxGaWxlUGF0aCArPSBwYXRoJDEuc2VwICsgc2VnbWVudDsgLy8gY2hlY2sgaWYgcGF0aCB1cCB0byB0aGlzIHBvaW50IGV4aXN0cy4uLlxuXG4gICAgICAgIGZzLmV4aXN0cyhwYXJ0aWFsRmlsZVBhdGgsIHBhcnRpYWxFeGlzdHMgPT4ge1xuICAgICAgICAgIGlmICghcGFydGlhbEV4aXN0cykge1xuICAgICAgICAgICAgLy8gbm9wZSwgdGhyb3cgdGhlIEVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobm9TdWNoRmlsZSgnbHN0YXQnLCBwYXJ0aWFsRmlsZVBhdGgpKTtcbiAgICAgICAgICB9IC8vIHRyeSBhZ2FpbiBhdCBuZXh0IGRlcHRoIG9mIGRpciB0cmVlXG5cblxuICAgICAgICAgIHNldFRpbWVvdXQodHJ5UGF0aCwgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCAxKTtcbn07XG5cbmZzLnJlYWxwYXRoLm5hdGl2ZSA9IChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBmcy5yZWFscGF0aChwYXRoLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBmaWxlcGF0aCBvcmlnaW5hbCBmaWxlcGF0aFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPSd1dGY4J10gZW5jb2RpbmcgdXNlZCBmb3IgcmV0dXJuZWQgb2JqZWN0LiBJZiAnYnVmZmVyXCIsIHdlJ2xsIHJldHVybiBhIEJ1ZmZlciBpbiBwYWxjZSBvZiBhIHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ3xCdWZmZXJ9XG4gKi9cblxuXG5mcy5yZWFscGF0aFN5bmMgPSAoZmlsZXBhdGgsIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmOCdcbiAgfSk7IC8vIEZJWE1FOiBUaGlzIGFzc3VtZXMgbm8gc3ltbGlua3MsIHdoaWNoIHdlIHJlYWxseSBkb24ndCBoYXZlIGZ1bGwgc3VwcG9ydCBmb3IgaW4gb3VyIFNESyBhbnl3YXlzLlxuXG4gIHZhciByZXN1bHQgPSBwYXRoJDEubm9ybWFsaXplKGZpbGVwYXRoKTtcblxuICBpZiAoIWZzLmV4aXN0c1N5bmMocmVzdWx0KSkge1xuICAgIC8vIHRoaXMgcGF0aCBkb2Vzbid0IGV4aXN0LCB0cnkgZWFjaCBzZWdtZW50IHVudGlsIHdlIGZpbmQgZmlyc3QgdGhhdCBkb2Vzbid0XG4gICAgdmFyIHNlZ21lbnRzID0gcmVzdWx0LnNwbGl0KHBhdGgkMS5zZXApO1xuICAgIHZhciBwYXJ0aWFsRmlsZVBhdGggPSAnJztcblxuICAgIGZvciAodmFyIHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcGFydGlhbEZpbGVQYXRoICs9IHBhdGgkMS5zZXAgKyBzZWdtZW50O1xuXG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMocGFydGlhbEZpbGVQYXRoKSkge1xuICAgICAgICB0aHJvdyBub1N1Y2hGaWxlKCdsc3RhdCcsIHBhcnRpYWxGaWxlUGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdidWZmZXInKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJlc3VsdCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnMucmVhbHBhdGhTeW5jLm5hdGl2ZSA9IChwYXRoLCBvcHRpb25zKSA9PiB7XG4gIGZzLnJlYWxwYXRoU3luYyhwYXRoLCBvcHRpb25zKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IG9sZFBhdGggc291cmNlIGZpbGVwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBuZXdQYXRoIGRlc3RpbmF0aW9uIGZpbGVwYXRoXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mcy5yZW5hbWUgPSAob2xkUGF0aCwgbmV3UGF0aCwgY2FsbGJhY2spID0+IHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLnJlbmFtZVN5bmMob2xkUGF0aCwgbmV3UGF0aCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2soKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBvbGRQYXRoIHNvdXJjZSBmaWxlcGF0aFxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gbmV3UGF0aCBkZXN0aW5hdGlvbiBmaWxlcGF0aFxuICovXG5cblxuZnMucmVuYW1lU3luYyA9IChvbGRQYXRoLCBuZXdQYXRoKSA9PiB7XG4gIHZhciB0aUZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZShvbGRQYXRoKTsgLy8gc3JjIGRvZXNuJ3QgYWN0dWFsbHkgZXhpc3Q/XG5cbiAgaWYgKCF0aUZpbGUuZXhpc3RzKCkpIHtcbiAgICB2YXIgZXJyID0gbm9TdWNoRmlsZSgncmVuYW1lJywgb2xkUGF0aCk7XG4gICAgZXJyLm1lc3NhZ2UgPSBcIlwiLmNvbmNhdChlcnIubWVzc2FnZSwgXCIgLT4gJ1wiKS5jb25jYXQobmV3UGF0aCwgXCInXCIpO1xuICAgIGVyci5kZXN0ID0gbmV3UGF0aDtcbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICB2YXIgZGVzdEZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZShuZXdQYXRoKTtcblxuICBpZiAoZGVzdEZpbGUuaXNEaXJlY3RvcnkoKSkge1xuICAgIC8vIGRlc3QgaXMgYSBkaXJlY3RvcnkgdGhhdCBhbHJlYWR5IGV4aXN0c1xuICAgIHZhciBfZXJyMiA9IGlsbGVnYWxPcGVyYXRpb25PbkFEaXJlY3RvcnkoJ3JlbmFtZScsIG9sZFBhdGgpO1xuXG4gICAgX2VycjIubWVzc2FnZSA9IFwiXCIuY29uY2F0KF9lcnIyLm1lc3NhZ2UsIFwiIC0+ICdcIikuY29uY2F0KG5ld1BhdGgsIFwiJ1wiKTtcbiAgICBfZXJyMi5kZXN0ID0gbmV3UGF0aDtcbiAgICB0aHJvdyBfZXJyMjtcbiAgfVxuXG4gIHZhciB0ZW1wUGF0aDtcblxuICBpZiAoZGVzdEZpbGUuaXNGaWxlKCkpIHtcbiAgICAvLyBkZXN0aW5hdGlvbiBmaWxlIGV4aXN0cywgd2Ugc2hvdWxkIG92ZXJ3cml0ZVxuICAgIC8vIE91ciBBUElzIHdpbGwgZmFpbCBpZiB3ZSB0cnksIHNvIGZpcnN0IGxldCdzIG1ha2UgYSBiYWNrdXAgY29weSBhbmQgZGVsZXRlIHRoZSB0aGUgb3JpZ2luYWxcbiAgICB0ZW1wUGF0aCA9IHBhdGgkMS5qb2luKGZzLm1rZHRlbXBTeW5jKHBhdGgkMS5qb2luKFRpLkZpbGVzeXN0ZW0udGVtcERpcmVjdG9yeSwgJ3JlbmFtZS0nKSksIHBhdGgkMS5iYXNlbmFtZShuZXdQYXRoKSk7XG4gICAgZGVzdEZpbGUubW92ZSh0ZW1wUGF0aCk7XG4gIH1cblxuICB2YXIgc3VjY2VzcyA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgc3VjY2VzcyA9IHRpRmlsZS5tb3ZlKG5ld1BhdGgpO1xuICB9IGZpbmFsbHkge1xuICAgIGlmICh0ZW1wUGF0aCkge1xuICAgICAgLy8gd2UgdGVtcG9yYXJpbHkgY29waWVkIHRoZSBleGlzdGluZyBkZXN0aW5hdGlvbiB0byBiYWNrIGl0IHVwLi4uXG4gICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAvLyBtb3ZlIHdvcmtlZCwgc28gd2UgY2FuIHdpcGUgaXQgYXdheSB3aGVuZXZlci4uLlxuICAgICAgICBmcy51bmxpbmsodGVtcFBhdGgsIF9lcnIgPT4ge30pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbW92ZSBpdCBiYWNrLCBiZWNhdXNlIHdlIGZhaWxlZCFcbiAgICAgICAgdmFyIHRtcEZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZSh0ZW1wUGF0aCk7XG4gICAgICAgIHRtcEZpbGUubW92ZShuZXdQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mcy5ybWRpciA9IChwYXRoLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgZnMucm1kaXJTeW5jKHBhdGgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKCk7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqL1xuXG5cbmZzLnJtZGlyU3luYyA9IHBhdGggPT4ge1xuICB2YXIgdGlGaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCk7XG5cbiAgaWYgKCF0aUZpbGUuZGVsZXRlRGlyZWN0b3J5KGZhbHNlKSkge1xuICAgIC8vIGRvIG5vdCBkZWxldGUgY29udGVudHMhXG4gICAgLy8gd2UgZmFpbGVkIHRvIGRlbGV0ZSwgYnV0IHdoeT9cbiAgICAvLyBkb2VzIGl0IGV4aXN0P1xuICAgIGlmICghdGlGaWxlLmV4aXN0cygpKSB7XG4gICAgICB0aHJvdyBub1N1Y2hGaWxlKCdybWRpcicsIHBhdGgpO1xuICAgIH0gLy8gaXMgaXQgYSBmaWxlP1xuXG5cbiAgICBpZiAodGlGaWxlLmlzRmlsZSgpKSB7XG4gICAgICB0aHJvdyBub3RBRGlyZWN0b3J5KCdybWRpcicsIHBhdGgpO1xuICAgIH0gLy8gaXMgaXQgbm90IGVtcHR5P1xuXG5cbiAgICB2YXIgc3ViRmlsZXMgPSB0aUZpbGUuZ2V0RGlyZWN0b3J5TGlzdGluZygpO1xuXG4gICAgaWYgKHN1YkZpbGVzICYmIHN1YkZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IGRpcmVjdG9yeU5vdEVtcHR5KCdybWRpcicsIHBhdGgpO1xuICAgIH1cbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iaWdpbnRdIHdoZXRoZXIgc3RhdCB2YWx1ZXMgc2hvdWxkIGJlIGJpZ2ludFxuICogQHBhcmFtIHtzdGF0c0NhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnMuc3RhdCA9IChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgY2FsbGJhY2sobnVsbCwgbmV3IGZzLlN0YXRzKHBhdGgpKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfGludGVnZXJ9IHBhdGggZmlsZXBhdGggb3IgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW19vcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtfb3B0aW9ucy5iaWdpbnRdIHdoZXRoZXIgc3RhdCB2YWx1ZXMgc2hvdWxkIGJlIGJpZ2ludFxuICogQHJldHVybnMge2ZzLlN0YXRzfVxuICovXG5cblxuZnMuc3RhdFN5bmMgPSAocGF0aCwgX29wdGlvbnMpID0+IG5ldyBmcy5TdGF0cyhwYXRoKTtcblxuZnMuc3ltbGluayA9ICh0YXJnZXQsIHBhdGgsIHR5cGUsIGNhbGxiYWNrKSA9PiBhc3luY1Vuc3VwcG9ydGVkTm9vcCgnZnMnLCAnc3ltbGluaycsIGNhbGxiYWNrKTtcblxuZnMuc3ltbGlua1N5bmMgPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ3N5bWxpbmtTeW5jJyk7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuPTBdIGJ5dGVzIHRvIHRyaW0gdG9cbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5mcy50cnVuY2F0ZSA9IChwYXRoLCBsZW4sIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayB8fCBsZW4pO1xuXG4gIGlmICh0eXBlb2YgbGVuICE9PSAnbnVtYmVyJykge1xuICAgIGxlbiA9IDA7XG4gIH1cblxuICBpZiAobGVuIDw9IDApIHtcbiAgICBmcy53cml0ZUZpbGUocGF0aCwgJycsIGNhbGxiYWNrKTsgLy8gZW1wdHkgdGhlIGZpbGVcblxuICAgIHJldHVybjtcbiAgfSAvLyB3ZSBoYXZlIHRvIHJldGFpbiBzb21lIG9mIHRoZSBmaWxlIVxuICAvLyB5dWNrLCBzbyBsZXQncyByZWFkIHdoYXQgd2UgbmVlZCB0byByZXRhaW4sIHRoZW4gb3ZlcndyaXRlIGZpbGUgd2l0aCBpdFxuXG5cbiAgZnMub3BlbihwYXRoLCAoZXJyLCBmZCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIH1cblxuICAgIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MobGVuKTtcbiAgICBmcy5yZWFkKGZkLCBidWZmZXIsIDAsIGxlbiwgbnVsbCwgKGVyciwgYnl0ZXNSZWFkLCBidWZmZXIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKGZkKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIGZzLmNsb3NlKGZkLCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBmcy53cml0ZUZpbGUocGF0aCwgYnVmZmVyLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2xlbj0wXSBieXRlcyB0byB0cmltIHRvXG4gKi9cblxuXG5mcy50cnVuY2F0ZVN5bmMgPSAocGF0aCwgbGVuID0gMCkgPT4ge1xuICBpZiAobGVuIDw9IDApIHtcbiAgICAvLyBlbXB0eSB0aGUgZmlsZVxuICAgIGZzLndyaXRlRmlsZVN5bmMocGF0aCwgJycpO1xuICAgIHJldHVybjtcbiAgfSAvLyB3ZSBoYXZlIHRvIHJldGFpbiBzb21lIG9mIHRoZSBmaWxlIVxuICAvLyB5dWNrLCBzbyBsZXQncyByZWFkIHdoYXQgd2UgbmVlZCB0byByZXRhaW4sIHRoZW4gb3ZlcndyaXRlIGZpbGUgd2l0aCBpdFxuXG5cbiAgdmFyIGZkID0gZnMub3BlblN5bmMocGF0aCk7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MobGVuKTtcbiAgZnMucmVhZFN5bmMoZmQsIGJ1ZmZlciwgMCwgbGVuLCBudWxsKTtcbiAgZnMuY2xvc2VTeW5jKGZkKTtcbiAgZnMud3JpdGVGaWxlU3luYyhwYXRoLCBidWZmZXIpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZzLnVubGluayA9IChwYXRoLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgZnMudW5saW5rU3luYyhwYXRoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2soKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5cbmZzLnVubGlua1N5bmMgPSBwYXRoID0+IHtcbiAgdmFyIHRpRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpO1xuXG4gIGlmICghdGlGaWxlLmRlbGV0ZUZpbGUoKSkge1xuICAgIC8vIHdlIGZhaWxlZCwgYnV0IHdoeT9cbiAgICBpZiAoIXRpRmlsZS5leGlzdHMoKSkge1xuICAgICAgdGhyb3cgbm9TdWNoRmlsZSgndW5saW5rJywgcGF0aCk7XG4gICAgfVxuXG4gICAgaWYgKHRpRmlsZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBpbGxlZ2FsT3BlcmF0aW9uT25BRGlyZWN0b3J5KCd1bmxpbmsnLCBwYXRoKTtcbiAgICB9XG4gIH1cbn07XG5cbmZzLnVud2F0Y2hGaWxlID0gdW5zdXBwb3J0ZWROb29wKCdmcycsICd1bndhdGNoRmlsZScpO1xuXG5mcy51dGltZXMgPSAocGF0aCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaykgPT4gYXN5bmNVbnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ3V0aW1lcycsIGNhbGxiYWNrKTtcblxuZnMudXRpbWVzU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAndXRpbWVzU3luYycpO1xuZnMud2F0Y2ggPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ3dhdGNoJyk7XG5mcy53YXRjaEZpbGUgPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ3dhdGNoRmlsZScpO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfGludGVnZXJ9IGZpbGUgZmlsZSBwYXRoIG9yIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxUeXBlZEFycmF5fERhdGFWaWV3fSBkYXRhIGRhdGEgdG8gd3JpdGVcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIG9wdGlvbnMsIGVuY29kaW5nIGlmIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gW29wdGlvbnMuZW5jb2Rpbmc9J3V0Zi04J10gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm1vZGU9MG82NjZdIG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5mbGFnPSd3J10gb3B0aW9uc1xuICogQHBhcmFtIHtlcnJvckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cbmZzLndyaXRlRmlsZSA9IChmaWxlLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgb3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIG1vZGU6IDBvNjY2LFxuICAgIGZsYWc6ICd3J1xuICB9KTsgLy8gVHVybiBpbnRvIGZpbGUgZGVzY3JpcHRvclxuXG4gIHZhciB3YXNGaWxlRGVzY3JpcHRvciA9IHR5cGVvZiBmaWxlID09PSAnbnVtYmVyJztcbiAgdmFyIGZpbGVEZXNjcmlwdG9yID0gZmlsZTsgLy8gbWF5IGJlIG92ZXJyaWRlbiBsYXRlclxuXG4gIHZhciBmaW5pc2ggPSBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHdhc0ZpbGVEZXNjcmlwdG9yKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZnMuY2xvc2UgaWYgaXQgd2FzIG5vdCBvcmlnaW5hbGx5IGEgZmlsZSBkZXNjcmlwdG9yXG5cblxuICAgIGZzLmNsb3NlKGZpbGVEZXNjcmlwdG9yLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgaWYgKCF3YXNGaWxlRGVzY3JpcHRvcikge1xuICAgIGZzLm9wZW4oZmlsZSwgb3B0aW9ucy5mbGFnLCBvcHRpb25zLm1vZGUsIChlcnIsIGZkKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZmlsZURlc2NyaXB0b3IgPSBmZDtcbiAgICAgIGZzLndyaXRlKGZpbGVEZXNjcmlwdG9yLCBkYXRhLCBmaW5pc2gpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGZzLndyaXRlKGZpbGVEZXNjcmlwdG9yLCBkYXRhLCBmaW5pc2gpO1xuICB9XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfGludGVnZXJ9IGZpbGUgZmlsZSBwYXRoIG9yIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxUeXBlZEFycmF5fERhdGFWaWV3fSBkYXRhIGRhdGEgdG8gd3JpdGVcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIG9wdGlvbnMsIGVuY29kaW5nIGlmIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPSd1dGYtOCddIG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5tb2RlPTBvNjY2XSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuZmxhZz0ndyddIG9wdGlvbnNcbiAqL1xuXG5cbmZzLndyaXRlRmlsZVN5bmMgPSAoZmlsZSwgZGF0YSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICBtb2RlOiAwbzY2NixcbiAgICBmbGFnOiAndydcbiAgfSk7IC8vIFR1cm4gaW50byBmaWxlIGRlc2NyaXB0b3JcblxuICB2YXIgd2FzRmlsZURlc2NyaXB0b3IgPSB0eXBlb2YgZmlsZSA9PT0gJ251bWJlcic7XG4gIHZhciBmaWxlRGVzY3JpcHRvciA9IHdhc0ZpbGVEZXNjcmlwdG9yID8gZmlsZSA6IGZzLm9wZW5TeW5jKGZpbGUsIG9wdGlvbnMuZmxhZywgb3B0aW9ucy5tb2RlKTsgLy8gaWYgZGF0YSBpcyBhIHN0cmluZywgbWFrZSBpdCBhIGJ1ZmZlciBmaXJzdFxuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKCcnICsgZGF0YSwgb3B0aW9ucy5lbmNvZGluZyk7IC8vIGZvcmNlIGRhdGEgdG8gYmUgYSBzdHJpbmcsIGhhbmRsZXMgY2FzZSB3aGVyZSBpdCdzIHVuZGVmaW5lZCBhbmQgd3JpdGVzICd1bmRlZmluZWQnIHRvIGZpbGUhXG4gIH1cblxuICBmcy53cml0ZVN5bmMoZmlsZURlc2NyaXB0b3IsIGRhdGEpOyAvLyBjbG9zZSBpZiB1c2VyIGRpZG4ndCBnaXZlIHVzIGZpbGUgZGVzY3JpcHRvclxuXG4gIGlmICghd2FzRmlsZURlc2NyaXB0b3IpIHtcbiAgICBmcy5jbG9zZVN5bmMoZmlsZURlc2NyaXB0b3IpO1xuICB9XG59O1xuLyoqXG4gKiBAY2FsbGJhY2sgd3JpdGVUaUZpbGVTdHJlYW1DYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdyaXR0ZW4gLSBieXRlcyB3cml0dGVuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1RpLkZpbGVzeXN0ZW0uRmlsZVN0cmVhbX0gdGlGaWxlU3RyZWFtIGZpbGUgc3RyZWFtXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIGJ1ZmZlciB3ZSdyZSB3cml0aW5nXG4gKiBAcGFyYW0ge3dyaXRlVGlGaWxlU3RyZWFtQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mdW5jdGlvbiB3cml0ZVRpRmlsZVN0cmVhbSh0aUZpbGVTdHJlYW0sIGJ1ZmZlciwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgVGkuU3RyZWFtLndyaXRlKHRpRmlsZVN0cmVhbSwgYnVmZmVyLnRvVGlCdWZmZXIoKSwgd3JpdGVPYmogPT4ge1xuICAgIGlmICghd3JpdGVPYmouc3VjY2Vzcykge1xuICAgICAgY2FsbGJhY2sobmV3IEVycm9yKHdyaXRlT2JqLmVycm9yKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgd3JpdGVPYmouYnl0ZXNQcm9jZXNzZWQpO1xuICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gYnVmZmVyIGNvbnRlbnRzIHRvIHdyaXRlOiBCdWZmZXIgb3Igc3RyaW5nXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXRdIG9mZnNldCB3aXRoaW4gQnVmZmVyIHRvIHdyaXRlOyBPUiBvZmZzZXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBmaWxlIHdoZXJlIHRoaXMgZGF0YSBzaG91bGQgYmUgd3JpdHRlbiAoaWYgc3RyaW5nKVxuICogQHBhcmFtIHtzdHJpbmd8aW50ZWdlcn0gW2xlbmd0aF0gbGVuZ3RoIG9mIGJ5dGVzIHRvIHdyaXRlIGlmIEJ1ZmZlcjsgT1IgZXhwZWN0ZWQgc3RyaW5nIGVuY29kaW5nXG4gKiBAcGFyYW0ge3dyaXRlQ2FsbGJhY2t8aW50ZWdlcn0gW3Bvc2l0aW9uXSBvZmZzZXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBmaWxlIHdoZXJlIHRoaXMgZGF0YSBzaG91bGQgYmUgd3JpdHRlbiAoaWYgQnVmZmVyKTsgT1IgYXN5bmMgY2FsbGJhY2sgaWYgc3RyaW5nXG4gKiBAcGFyYW0ge3dyaXRlQ2FsbGJhY2t9IFtjYWxsYmFja10gYXN5bmMgY2FsbGJhY2sgKGlmIEJ1ZmZlcilcbiAqL1xuXG5cbmZzLndyaXRlID0gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spID0+IHtcbiAgdmFyIGlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcik7XG5cbiAgaWYgKGlzQnVmZmVyKSB7XG4gICAgd3JpdGVCdWZmZXIoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVTdHJpbmcoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gYnVmZmVyIGNvbnRlbnRzIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXRdIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUgd2hlcmUgdGhpcyBkYXRhIHNob3VsZCBiZSB3cml0dGVuXG4gKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBbbGVuZ3RoXSAgZXhwZWN0ZWQgc3RyaW5nIGVuY29kaW5nXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gcG9zaXRpb25cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICovXG5cblxuZnMud3JpdGVTeW5jID0gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgPT4ge1xuICB2YXIgaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKTtcblxuICBpZiAoaXNCdWZmZXIpIHtcbiAgICByZXR1cm4gd3JpdGVCdWZmZXJTeW5jKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZVN0cmluZ1N5bmMoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpO1xufTsgLy8gVE9ETzogQWRkIEZpbGVIYW5kbGUgY2xhc3MgdG8gbWF0Y2ggTm9kZSdzIHdyYXBwZXIgZm9yIGZpbGUgZGVzY3JpcHRvcnMuIFJlLXB1cnBvc2Ugb3VyIG93biB3cmFwcGVyP1xuLy8gVE9ETzogQWRkIHRoZSBmcy5wcm9taXNlcyBBUEkhXG4vLyBUT0RPOiBEZWZpbmUgZnMuRGlyZW50IGNsYXNzLCB3aGljaCBjYW4gc2ltcGx5IHdyYXAgYSBUaS5GaWxlc3lzdGVtLkZpbGUgKGFuZCBpcyB2ZXJ5IHNpbWlsYXIgdG8gZnMuU3RhdHMhKVxuLy8gSGVscGVyIGZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBUcmFja3MgdGhlIHBhaXJpbmcgb2YgdGhlIG51bWJlciB3ZSB1c2UgdG8gcmVwcmVzZW50IHRoZSBmaWxlIGV4dGVybmFsbHksIHRoZSBmaWxlcGF0aCBpdCdzIHBvaW50aW5nIGF0LCBhbmQgdGhlIHN0cmVhbSBwb2ludGluZyBhdCBpdC5cbiAqL1xuXG5cbmNsYXNzIEZpbGVEZXNjcmlwdG9yIHtcbiAgY29uc3RydWN0b3IobnVtYmVyLCBwYXRoLCBzdHJlYW0pIHtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICB9XG5cbn1cbi8qKlxuICogQHBhcmFtIHtUaS5JT1N0cmVhbX0gc3JjU3RyZWFtIGlucHV0IHN0cmVhbSB3ZSdyZSByZWFkaW5nIGZyb21cbiAqIEBwYXJhbSB7VGkuSU9TdHJlYW19IGRlc3RTdHJlYW0gb3V0cHV0IHN0cmVhbSB3ZSdyZSB3cml0aW5nIHRvXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mdW5jdGlvbiBwaXBlKHNyY1N0cmVhbSwgZGVzdFN0cmVhbSwgY2FsbGJhY2spIHtcbiAgaWYgKGlzQW5kcm9pZCQxKSB7XG4gICAgLy8gQW5kcm9pZCBpcyBwcm9iYWJseSBiZXR0ZXIgb2ZmIHdpdGggVGkuU3RyZWFtLndyaXRlU3RyZWFtLCBsZXNzIG92ZXJoZWFkIGJhY2sgYW5kIGZvcnRoIHRoZSBicmlkZ2VcbiAgICAvLyBUaG91Z2ggQW5kcm9pZCBkb2VzIHN1cHBvcnQgdGhlIFRpLlN0cmVhbS5wdW1wL1RpLlN0cmVhbS53cml0ZSBwYXR0ZXJuIHVzaW5nIGJvdGggQVBJcyBhc3luY1xuICAgIHBpcGVWaWFXcml0ZVN0cmVhbShzcmNTdHJlYW0sIGRlc3RTdHJlYW0sIGNhbGxiYWNrKTtcbiAgICByZXR1cm47XG4gIH0gLy8gaU9TIGhhcyBzb21lLi4uIGlzc3VlcyB3aXRoIHdyaXRlU3RyZWFtIGNhbGxpbmcgdGhlIGNhbGxiYWNrIGV2ZXJ5IGl0ZXJhdGlvbiBvZiB0aGUgbG9vcCAqYW5kKiBhdCB0aGUgZW5kXG4gIC8vIGl0IGFsc28gZG9lc24ndCBwbGF5IGFzIGV4cGVjdGVkIHdoZW4gZG9pbmcgVGkuU3RyZWFtLnB1bXAgYW5kIFRpLlN0cmVhbS53cml0ZSBhc3luYyBlYWNoXG4gIC8vIGl0IGVuZHMgdXAgZG9pbmcgYWxsIHJlYWRzIGZpcnN0IGFuZCB0aGVuIGFsbCB3cml0ZXNcbiAgLy8gc28gd2UgaGF2ZSB0byBoYWNrIGhlcmUgYW5kIGRvIFRpLlN0cmVhbS5wdW1wIGFzeW5jLCBidXQgZWFjaCB0aW1lIHRoZSByZWFkIGNhbGxiYWNrIGhhcHBlbnMgd2UgZG8gYSAqc3luYyogd3JpdGUgaW5zaWRlIGl0XG4gIC8vIFNlZSBodHRwczovL2ppcmEuYXBwY2VsZXJhdG9yLm9yZy9icm93c2UvVElNT0ItMjczMjFcblxuXG4gIHBpcGVWaWFQdW1wKHNyY1N0cmVhbSwgZGVzdFN0cmVhbSwgY2FsbGJhY2spO1xufVxuLyoqXG4gKiBAcGFyYW0ge1RpLklPU3RyZWFtfSBzcmNTdHJlYW0gaW5wdXQgc3RyZWFtIHdlJ3JlIHJlYWRpbmcgZnJvbVxuICogQHBhcmFtIHtUaS5JT1N0cmVhbX0gZGVzdFN0cmVhbSBvdXRwdXQgc3RyZWFtIHdlJ3JlIHdyaXRpbmcgdG9cbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZ1bmN0aW9uIHBpcGVWaWFXcml0ZVN0cmVhbShzcmNTdHJlYW0sIGRlc3RTdHJlYW0sIGNhbGxiYWNrKSB7XG4gIFRpLlN0cmVhbS53cml0ZVN0cmVhbShzcmNTdHJlYW0sIGRlc3RTdHJlYW0sIENPUFlfRklMRV9DSFVOS19TSVpFLCByZXN1bHQgPT4ge1xuICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IocmVzdWx0LmVycm9yKSk7XG4gICAgfSAvLyBBbmRyb2lkIHdpbGwgb25seSBjYWxsIHRoaXMgYXQgdGhlIGVuZCBvciBlcnJvciwgc28gd2UgY2FuIHNhZmVseSBhc3N1bWUgd2UncmUgZG9uZSBoZXJlLlxuICAgIC8vIGlPUyB3aWxsIGNhbGwgcGVyIGxvb3AgaXRlcmF0aW9uLCBzZWUgaHR0cHM6Ly9qaXJhLmFwcGNlbGVyYXRvci5vcmcvYnJvd3NlL1RJTU9CLTI3MzIwXG5cblxuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge1RpLklPU3RyZWFtfSBzcmNTdHJlYW0gaW5wdXQgc3RyZWFtIHdlJ3JlIHJlYWRpbmcgZnJvbVxuICogQHBhcmFtIHtUaS5JT1N0cmVhbX0gZGVzdFN0cmVhbSBvdXRwdXQgc3RyZWFtIHdlJ3JlIHdyaXRpbmcgdG9cbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZ1bmN0aW9uIHBpcGVWaWFQdW1wKHNyY1N0cmVhbSwgZGVzdFN0cmVhbSwgY2FsbGJhY2spIHtcbiAgVGkuU3RyZWFtLnB1bXAoc3JjU3RyZWFtLCBvYmogPT4ge1xuICAgIGlmICghb2JqLnN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3Iob2JqLmVycm9yKSk7IC8vIFRPRE86IHNldCBjb2RlIHZpYSB3cml0ZU9iai5jb2RlP1xuICAgIH1cblxuICAgIGlmIChvYmouYnl0ZXNQcm9jZXNzZWQgPT09IC0xKSB7XG4gICAgICAvLyByZWFjaGVkIEVPRlxuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfSAvLyB3ZSByZWFkIHNvbWUgc2VnbWVudCBvZiB0aGUgaW5wdXQgc3RyZWFtIGFuZCBoYXZlIG5vdCByZWFjaGVkIEVPRiB5ZXRcblxuXG4gICAgdmFyIGJ5dGVzV3JpdHRlbiA9IDA7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IG9iai5ieXRlc1Byb2Nlc3NlZDtcblxuICAgIHRyeSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAvLyB0cnkgdG8gd3JpdGUgYWxsIG9mIHRoZSBjdXJyZW50IGJ1ZmZlclxuICAgICAgICB2YXIgYnl0ZXNXcml0dGVuVGhpc0NodW5rID0gZGVzdFN0cmVhbS53cml0ZShvYmouYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgIGJ5dGVzV3JpdHRlbiArPSBieXRlc1dyaXR0ZW5UaGlzQ2h1bms7XG5cbiAgICAgICAgaWYgKGJ5dGVzV3JpdHRlbiA9PT0gb2JqLmJ5dGVzUHJvY2Vzc2VkKSB7XG4gICAgICAgICAgLy8gd3JvdGUgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgd2UgcmVhZCwgbW92ZSBvblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIE5PVEU6IFRoaXMgc2hvdWxkbid0IGV2ZXIgaGFwcGVuIGJlY2F1c2Ugb3VyIEFQSXMgc2hvdWxkIHdyaXRlIHRoZSBlbnRpcmUgYnl0ZSBhcnJheSBvciBmYWlsLCBidXQganVzdCBpbiBjYXNlLi4uXG4gICAgICAgIC8vIHdlIGRpZG4ndCB3cml0ZSBpdCBhbGwsIHNvIG1vdmUgb24gdG8gdHJ5IGFuZCB3cml0ZSB0aGUgcmVzdCBvZiBidWZmZXIuLi5cblxuXG4gICAgICAgIG9mZnNldCA9IGJ5dGVzV3JpdHRlbjtcbiAgICAgICAgbGVuZ3RoID0gb2JqLmJ5dGVzUHJvY2Vzc2VkIC0gYnl0ZXNXcml0dGVuO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICB9XG4gIH0sIENPUFlfRklMRV9DSFVOS19TSVpFLCB0cnVlKTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7VGkuRmlsZXN5c3RlbS5GaWxlU3RyZWFtfSBmaWxlU3RyZWFtIGZpbGUgc3RyZWFtXG4gKiBAcmV0dXJucyB7aW50ZWdlcn0gZmlsZSBkZXNjcmlwdG9yXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVGaWxlRGVzY3JpcHRvcihwYXRoLCBmaWxlU3RyZWFtKSB7XG4gIHZhciBwb2ludGVyID0gZmlsZURlc2NyaXB0b3JDb3VudCsrOyAvLyBpbmNyZW1lbnQgZ2xvYmFsIGNvdW50ZXJcblxuICB2YXIgZmQgPSBuZXcgRmlsZURlc2NyaXB0b3IocG9pbnRlciwgcGF0aCwgZmlsZVN0cmVhbSk7XG4gIGZpbGVEZXNjcmlwdG9ycy5zZXQocG9pbnRlciwgZmQpOyAvLyB1c2UgaXQgdG8gcmVmZXIgdG8gdGhpcyBmaWxlIHN0cmVhbSBhcyB0aGUgXCJkZXNjcmlwdG9yXCJcblxuICByZXR1cm4gcG9pbnRlcjtcbn1cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtUaS5GaWxlc3lzdGVtLkZpbGVTdHJlYW19IG1hdGNoaW5nIHN0cmVhbVxuICovXG5cblxuZnVuY3Rpb24gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCkge1xuICB2YXIgd3JhcHBlciA9IGZpbGVEZXNjcmlwdG9ycy5nZXQoZmQpO1xuICByZXR1cm4gd3JhcHBlci5zdHJlYW07XG59XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBtYXRjaGluZyBzdHJlYW1cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhdGhGb3JGaWxlRGVzY3JpcHRvcihmZCkge1xuICB2YXIgd3JhcHBlciA9IGZpbGVEZXNjcmlwdG9ycy5nZXQoZmQpO1xuICByZXR1cm4gd3JhcHBlci5wYXRoO1xufVxuLyoqXG4gKiBVc2VkIHRvIG1lcmdlIHRoZSB1c2VyLXN1cHBsaWVkIG9wdGlvbnMgd2l0aCB0aGUgZGVmYXVsdHMgZm9yIGEgZnVuY3Rpb24uIFNwZWNpYWwgY2FzZXMgYSBzdHJpbmcgdG8gYmUgZW5jb2RpbmcuXG4gKiBAcGFyYW0geyp9IG9wdGlvbnMgdXNlci1zdXBwbGllZCBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gZGVmYXVsdHMgZGVmYXVsdHMgdG8gdXNlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cblxuXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gIGlmIChvcHRpb25zID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICB9XG5cbiAgdmFyIG9wdGlvbnNUeXBlID0gdHlwZW9mIG9wdGlvbnM7XG5cbiAgc3dpdGNoIChvcHRpb25zVHlwZSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIC8vIFVzZSBjb3B5IG9mIGRlZmF1bHRzIGJ1dCB3aXRoIGVuY29kaW5nIHNldCB0byB0aGUgJ29wdGlvbnMnIHZhbHVlIVxuICAgICAgdmFyIG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzKTtcbiAgICAgIG1lcmdlZC5lbmNvZGluZyA9IG9wdGlvbnM7XG4gICAgICByZXR1cm4gbWVyZ2VkO1xuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiBvcHRpb25zO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGFzc2VydEFyZ3VtZW50VHlwZShvcHRpb25zLCAnb3B0aW9ucycsICdvYmplY3QnKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIHNob3VsZCBuZXZlciBnZXQgcmVhY2hlZFxuICB9XG59XG4vKipcbiAqIEVuZm9yY2VzIHRoYXQgd2UgaGF2ZSBhIHZhbGlkIGNhbGxiYWNrIGZ1bmN0aW9uLiBUaHJvd3MgVHlwZUVycm9yIGlmIG5vdC5cbiAqIEBwYXJhbSB7Kn0gY2IgcG9zc2libGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIG1heWJlQ2FsbGJhY2soY2IpIHtcbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjYjtcbiAgfVxuXG4gIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKFwiQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uLiBSZWNlaXZlZCBcIi5jb25jYXQoY2IpKTtcbiAgZXJyLmNvZGUgPSAnRVJSX0lOVkFMSURfQ0FMTEJBQ0snO1xuICB0aHJvdyBlcnI7XG59XG4vKipcbiAqIHJldHVybnMgcmFuZG9tbHkgZ2VuZXJhdGVkIGNoYXJhY3RlcnMgb2YgZ2l2ZW4gbGVuZ3RoIDEtMTZcbiAqIEBwYXJhbSB7aW50ZWdlcn0gbGVuZ3RoIDEgLSAxNlxuICogQHBhcmFtIHtzdHJpbmd9IFtfZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyBvZiB0aGUgc3RyaW5nIGdlbmVyYXRlZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIHJhbmRvbUNoYXJhY3RlcnMobGVuZ3RoLCBfZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgLy8gRklYTUU6IHVzZSB0aGUgZW5jb2Rpbmcgc3BlY2lmaWVkIVxuICByZXR1cm4gKE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpICsgJzAwMDAwMDAwMDAwMDAwMDAwJykuc2xpY2UoMiwgbGVuZ3RoICsgMik7XG59XG5cbmZ1bmN0aW9uIG1ha2VFcnJvcihjb2RlLCBtZXNzYWdlLCBlcnJubywgc3lzY2FsbCwgcGF0aCkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJcIi5jb25jYXQoY29kZSwgXCI6IFwiKS5jb25jYXQobWVzc2FnZSwgXCIsIFwiKS5jb25jYXQoc3lzY2FsbCwgXCIgJ1wiKS5jb25jYXQocGF0aCwgXCInXCIpKTtcbiAgZXJyb3IuZXJybm8gPSBlcnJubztcbiAgZXJyb3Iuc3lzY2FsbCA9IHN5c2NhbGw7XG4gIGVycm9yLmNvZGUgPSBjb2RlO1xuICBlcnJvci5wYXRoID0gcGF0aDtcbiAgcmV0dXJuIGVycm9yO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2Rpbmcgd2hhdCB3ZSdyZSBlbmNvZGluZyB0b1xuICogQHBhcmFtIHtUaS5CdWZmZXJ9IHRpQnVmZmVyIFRpLkJ1ZmZlciBpbnN0YW5jZVxuICogQHJldHVybnMge0J1ZmZlcn0gbm9kZS1jb21wYXRpYmxlIEJ1ZmZlciBpbnN0YW5jZVxuICovXG5cblxuZnVuY3Rpb24gZW5jb2RlQnVmZmVyKGVuY29kaW5nLCB0aUJ1ZmZlcikge1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20odGlCdWZmZXIpO1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdidWZmZXInOlxuICAgIGNhc2UgbnVsbDpcbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIHJldHVybiBidWZmZXI7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyhlbmNvZGluZyk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge1RpLkZpbGVzeXN0ZW0uRmlsZX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpIHtcbiAgLy8gVGhpcyBpcyBhIGhhY2sgdGhhdCBpcyBsaWtlbHkgdG8gd29yayBpbiBtb3N0IGNhc2VzP1xuICAvLyBCYXNpY2FsbHkgYXNzdW1lcyBCdWZmZXIgaXMgaG9sZGluZyBhIHV0Zi04IHN0cmluZyBmaWxlbmFtZS9wYXRoXG4gIC8vIE5vZGUganVzdCBjb3BpZXMgdGhlIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlciBhcy1pcyBvbiB0aGUgbmF0aXZlIHNpZGUgYW5kIGFkZHMgYSBudWxsIHRlcm1pbmF0b3JcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihwYXRoKSkge1xuICAgIHBhdGggPSBwYXRoLnRvU3RyaW5nKCk7IC8vIGFzc3VtZXMgdXRmLTggc3RyaW5nXG4gIH0gLy8gRklYTUU6IEhhbmRsZSBVUkxzISBXZSBkb24ndCBoYXZlIGFuIFVSTCBzaGltIHlldCwgc28gbm8gd2F5IHRvIGhhbmRsZSB0aG9zZSB5ZXRcblxuXG4gIGFzc2VydEFyZ3VtZW50VHlwZShwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcbiAgcmV0dXJuIFRpLkZpbGVzeXN0ZW0uZ2V0RmlsZShwYXRoKTtcbn1cbi8qKlxuICogQGNhbGxiYWNrIHdyaXRlQnVmZmVyQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtpbnRlZ2VyfSB3cml0dGVuIC0gYnl0ZXMgd3JpdHRlblxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciAtIG9yaWdpbmFsIEJ1ZmZlciBiZWluZyB3cml0dGVuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBjb250ZW50cyB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0XSBvZmZzZXQgd2l0aGluIEJ1ZmZlciB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuZ3RoXSBsZW5ndGggb2YgYnl0ZXMgdG8gd3JpdGUgaWYgQnVmZmVyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqIEBwYXJhbSB7d3JpdGVCdWZmZXJDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZ1bmN0aW9uIHdyaXRlQnVmZmVyKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrIHx8IHBvc2l0aW9uIHx8IGxlbmd0aCB8fCBvZmZzZXQpO1xuXG4gIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJykge1xuICAgIG9mZnNldCA9IDA7XG4gIH1cblxuICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICBsZW5ndGggPSBidWZmZXIubGVuZ3RoIC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicpIHtcbiAgICBwb3NpdGlvbiA9IG51bGw7XG4gIH0gLy8gb2sgbm93IHdoYXQ/XG5cblxuICB2YXIgdGlGaWxlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7IC8vIE1ha2UgdXNlIG9mIHRoZSBidWZmZXIgc2xpY2UgdGhhdCdzIHNwZWNpZmllZCBieSBvZmZzZXQvbGVuZ3RoXG5cbiAgaWYgKG9mZnNldCAhPT0gMCB8fCBsZW5ndGggIT09IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBsZW5ndGgpO1xuICB9IC8vIFRPRE86IFN1cHBvcnQgdXNlIG9mIHBvc2l0aW9uIGFyZ3VtZW50LiBJIGFzc3VtZSB3ZSdkIG5lZWQgYSB3YXkgdG8gYWRkIGEgbWV0aG9kIHRvIG1vdmUgdG8gc3RyZWFtIHBvc2l0aW9uIHNvbWVob3dcblxuXG4gIHdyaXRlVGlGaWxlU3RyZWFtKHRpRmlsZVN0cmVhbSwgYnVmZmVyLCAoZXJyLCBieXRlc1Byb2Nlc3NlZCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgYnl0ZXNQcm9jZXNzZWQsIGJ1ZmZlcik7XG4gIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBjb250ZW50cyB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0XSBvZmZzZXQgd2l0aGluIEJ1ZmZlciB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuZ3RoXSBsZW5ndGggb2YgYnl0ZXMgdG8gd3JpdGUgaWYgQnVmZmVyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICovXG5cblxuZnVuY3Rpb24gd3JpdGVCdWZmZXJTeW5jKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicpIHtcbiAgICBvZmZzZXQgPSAwO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCAtIG9mZnNldDtcbiAgfVxuXG5cbiAgdmFyIHRpRmlsZVN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmQpOyAvLyBNYWtlIHVzZSBvZiB0aGUgYnVmZmVyIHNsaWNlIHRoYXQncyBzcGVjaWZpZWQgYnkgb2Zmc2V0L2xlbmd0aFxuXG4gIGlmIChvZmZzZXQgIT09IDAgfHwgbGVuZ3RoICE9PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgbGVuZ3RoKTtcbiAgfSAvLyBUT0RPOiBTdXBwb3J0IHVzZSBvZiBwb3NpdGlvbiBhcmd1bWVudC4gSSBhc3N1bWUgd2UnZCBuZWVkIGEgd2F5IHRvIGFkZCBhIG1ldGhvZCB0byBtb3ZlIHRvIHN0cmVhbSBwb3NpdGlvbiBzb21laG93XG5cblxuICByZXR1cm4gdGlGaWxlU3RyZWFtLndyaXRlKGJ1ZmZlci50b1RpQnVmZmVyKCkpO1xufVxuLyoqXG4gKiBAY2FsbGJhY2sgd3JpdGVTdHJpbmdDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdyaXR0ZW4gLSBieXRlcyB3cml0dGVuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gb3JpZ2luYWwgc3RyaW5nIGJlaW5nIHdyaXR0ZW5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIGNvbnRlbnRzIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBleHBlY3RlZCBzdHJpbmcgZW5jb2RpbmdcbiAqIEBwYXJhbSB7d3JpdGVTdHJpbmdDYWxsYmFja30gW2NhbGxiYWNrXSBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnVuY3Rpb24gd3JpdGVTdHJpbmcoZmQsIHN0cmluZywgcG9zaXRpb24sIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgZW5jb2RpbmcgfHwgcG9zaXRpb24pOyAvLyBwb3NpdGlvbiBjb3VsZCBiZTogbnVtYmVyLCBmdW5jdGlvbiAoY2FsbGJhY2spXG5cbiAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicpIHtcbiAgICBwb3NpdGlvbiA9IG51bGw7XG4gIH0gLy8gZW5jb2RpbmcgY291bGQgYmU6IGZ1bmN0aW9uIChjYWxsYmFjaykgb3Igc3RyaW5nXG5cblxuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICB9XG5cbiAgdmFyIHRpRmlsZVN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmQpO1xuICBzdHJpbmcgKz0gJyc7IC8vIGNvZXJjZSB0byBzdHJpbmdcblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oc3RyaW5nLCBlbmNvZGluZyk7IC8vIFRPRE86IFN1cHBvcnQgdXNlIG9mIHBvc2l0aW9uIGFyZ3VtZW50LiBJIGFzc3VtZSB3ZSdkIG5lZWQgYSB3YXkgdG8gYWRkIGEgbWV0aG9kIHRvIG1vdmUgdG8gc3RyZWFtIHBvc2l0aW9uIHNvbWVob3dcblxuICB3cml0ZVRpRmlsZVN0cmVhbSh0aUZpbGVTdHJlYW0sIGJ1ZmZlciwgKGVyciwgYnl0ZXNQcm9jZXNzZWQpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIGJ5dGVzUHJvY2Vzc2VkLCBzdHJpbmcpO1xuICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgY29udGVudHMgdG8gd3JpdGVcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3Bvc2l0aW9uXSBvZmZzZXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBmaWxlIHdoZXJlIHRoaXMgZGF0YSBzaG91bGQgYmUgd3JpdHRlblxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIGV4cGVjdGVkIHN0cmluZyBlbmNvZGluZ1xuICogQHJldHVybnMge2ludGVnZXJ9IG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gKi9cblxuXG5mdW5jdGlvbiB3cml0ZVN0cmluZ1N5bmMoZmQsIHN0cmluZywgcG9zaXRpb24sIGVuY29kaW5nKSB7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgfVxuXG4gIHZhciB0aUZpbGVTdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZkKTtcbiAgc3RyaW5nICs9ICcnOyAvLyBjb2VyY2UgdG8gc3RyaW5nXG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHN0cmluZywgZW5jb2RpbmcpOyAvLyBUT0RPOiBTdXBwb3J0IHVzZSBvZiBwb3NpdGlvbiBhcmd1bWVudC4gSSBhc3N1bWUgd2UnZCBuZWVkIGEgd2F5IHRvIGFkZCBhIG1ldGhvZCB0byBtb3ZlIHRvIHN0cmVhbSBwb3NpdGlvbiBzb21laG93XG5cbiAgcmV0dXJuIHRpRmlsZVN0cmVhbS53cml0ZShidWZmZXIudG9UaUJ1ZmZlcigpKTtcbn1cblxuLyoqXG4gKiBUaGlzIGZpbGUgaXMgdXNlZCB0byBoaWphY2sgdGhlIHN0YW5kYXJkIHJlcXVpcmUgdG8gYWxsb3cgZm9yIEpTXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgXCJjb3JlXCIgbW9kdWxlcy5cbiAqXG4gKiBZb3UgYWRkIGEgYmluZGluZyBmcm9tIHRoZSBcImNvcmVcIiBtb2R1bGUgaWQgdG8gdGhlIHVuZGVyIHRoZSBob29kIEpTXG4gKiBpbXBsZW1lbnRhdGlvbi4gV2UgdGhlbiBpbnRlcmNlcHQgcmVxdWlyZSBjYWxscyB0byBoYW5kbGUgcmVxdWVzdHMgZm9yIHRoZXNlIG1vZHVsZXNcbiAqIGFuZCBsYXppbHkgbG9hZCB0aGUgZmlsZS5cbiAqL1xuXG4vKipcbiAqIFVzZWQgYnkgQGZ1bmN0aW9uIGJpbmRPYmplY3RUb0NvcmVNb2R1bGVJZFxuICogQHR5cGUge21hcDxzdHJpbmcsIG9iamVjdD59XG4gKi9cbnZhciBiaW5kaW5ncyA9IG5ldyBNYXAoKTtcbi8qKlxuICogVXNlZCBieSBAZnVuY3Rpb24gcmVkaXJlY3RDb3JlTW9kdWxlSWRUb1BhdGhcbiAqIEB0eXBlIHttYXA8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5cbnZhciByZWRpcmVjdHMgPSBuZXcgTWFwKCk7XG4vKipcbiAqIERvZXMgdGhlIHJlcXVlc3QgbG9vayBsaWtlIGEgdHlwaWNhbCBjb3JlIG1vZHVsZT8gKG5vICcuJyBvciAnLycgY2hhcmFjdGVycylcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIG9yaWdpbmFsIHJlcXVpcmUgcGF0aC9pZFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNIaWphY2thYmxlTW9kdWxlSWQocGF0aCkge1xuICBpZiAoIXBhdGggfHwgcGF0aC5sZW5ndGggPCAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGZpcnN0Q2hhciA9IHBhdGguY2hhckF0KDApO1xuICByZXR1cm4gZmlyc3RDaGFyICE9PSAnLicgJiYgZmlyc3RDaGFyICE9PSAnLyc7XG59IC8vIEhhY2sgcmVxdWlyZSB0byBwb2ludCB0byB0aGlzIGFzIGEgY29yZSBtb2R1bGUgXCJiaW5kaW5nXCJcblxuXG52YXIgb3JpZ2luYWxSZXF1aXJlID0gZ2xvYmFsLnJlcXVpcmU7IC8vIFRoaXMgd29ya3MgZm9yIGlPUyBhcy1pcywgYW5kIGFsc28gaW50ZXJjZXB0cyB0aGUgY2FsbCBvbiBBbmRyb2lkIGZvciB0aS5tYWluLmpzICh0aGUgZmlyc3QgZmlsZSBleGVjdXRlZClcblxuZ2xvYmFsLnJlcXVpcmUgPSBmdW5jdGlvbiAobW9kdWxlSWQpIHtcbiAgaWYgKGJpbmRpbmdzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICByZXR1cm4gYmluZGluZ3MuZ2V0KG1vZHVsZUlkKTtcbiAgfVxuXG4gIGlmIChyZWRpcmVjdHMuaGFzKG1vZHVsZUlkKSkge1xuICAgIG1vZHVsZUlkID0gcmVkaXJlY3RzLmdldChtb2R1bGVJZCk7XG4gIH1cblxuICByZXR1cm4gb3JpZ2luYWxSZXF1aXJlKG1vZHVsZUlkKTtcbn07XG5cbmlmIChUaS5QbGF0Zm9ybS5uYW1lID09PSAnYW5kcm9pZCcpIHtcbiAgLy8gLi4uIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvIGhhY2sgaXQgd2hlbiByZXF1aXJpbmcgZnJvbSBvdGhlciBmaWxlcyBmb3IgQW5kcm9pZFxuICB2YXIgb3JpZ2luYWxNb2R1bGVSZXF1aXJlID0gZ2xvYmFsLk1vZHVsZS5wcm90b3R5cGUucmVxdWlyZTtcblxuICBnbG9iYWwuTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlID0gZnVuY3Rpb24gKHBhdGgsIGNvbnRleHQpIHtcbiAgICBpZiAoYmluZGluZ3MuaGFzKHBhdGgpKSB7XG4gICAgICByZXR1cm4gYmluZGluZ3MuZ2V0KHBhdGgpO1xuICAgIH1cblxuICAgIGlmIChyZWRpcmVjdHMuaGFzKHBhdGgpKSB7XG4gICAgICBwYXRoID0gcmVkaXJlY3RzLmdldChwYXRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3JpZ2luYWxNb2R1bGVSZXF1aXJlLmNhbGwodGhpcywgcGF0aCwgY29udGV4dCk7XG4gIH07XG59XG4vKipcbiAqIFJlZ2lzdGVycyBhIGJpbmRpbmcgZnJvbSBhIHNob3J0IG1vZHVsZSBpZCB0byBhbiBhbHJlYWR5IGxvYWRlZC9jb25zdHJ1Y3RlZCBvYmplY3QvdmFsdWUgdG8gZXhwb3J0IGZvciB0aGF0IGNvcmUgbW9kdWxlIGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZUlkIHRoZSBtb2R1bGUgaWQgdG8gXCJoaWphY2tcIlxuICogQHBhcmFtIHsqfSBiaW5kaW5nIGFuIGFscmVhZHkgY29uc3RydWN0dXJlZCB2YWx1ZS9vYmplY3QgdG8gcmV0dXJuXG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3Rlcihtb2R1bGVJZCwgYmluZGluZykge1xuICBpZiAoIWlzSGlqYWNrYWJsZU1vZHVsZUlkKG1vZHVsZUlkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZWdpc3RlciBmb3IgcmVsYXRpdmUvYWJzb2x1dGUgZmlsZSBwYXRoczsgbm8gbGVhZGluZyAnLicgb3IgJy8nIGFsbG93ZWQgKHdhcyBnaXZlbiBcIi5jb25jYXQobW9kdWxlSWQsIFwiKVwiKSk7XG4gIH1cblxuICBpZiAocmVkaXJlY3RzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICBUaS5BUEkud2FybihcIkFub3RoZXIgYmluZGluZyBoYXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBtb2R1bGUgaWQ6ICdcIi5jb25jYXQobW9kdWxlSWQsIFwiJywgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi4uLlwiKSk7XG4gICAgcmVkaXJlY3RzLmRlbGV0ZShtb2R1bGVJZCk7XG4gIH0gZWxzZSBpZiAoYmluZGluZ3MuaGFzKG1vZHVsZUlkKSkge1xuICAgIFRpLkFQSS53YXJuKFwiQW5vdGhlciBiaW5kaW5nIGhhcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIG1vZHVsZSBpZDogJ1wiLmNvbmNhdChtb2R1bGVJZCwgXCInLCBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuLi4uXCIpKTtcbiAgfVxuXG4gIGJpbmRpbmdzLnNldChtb2R1bGVJZCwgYmluZGluZyk7XG59XG4vKipcbiAqIFJlZ2lzdGVycyBhIGJpbmRpbmcgZnJvbSBhIHNob3J0IG1vZHVsZSBpZCB0byB0aGUgZnVsbCB1bmRlciB0aGUgaG9vZCBmaWxlcGF0aCBpZiBnaXZlbiBhIHN0cmluZy5cbiAqIFRoaXMgYWxsb3dzIGZvciBsYXp5IGluc3RhbnRpYXRpb24gb2YgdGhlIG1vZHVsZSBvbi1kZW1hbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlSWQgdGhlIG1vZHVsZSBpZCB0byBcImhpamFja1wiXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZXBhdGggdGhlIGZ1bGwgZmlsZXBhdGggdG8gcmVxdWlyZSB1bmRlciB0aGUgaG9vZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBzaG91bGQgYmUgYW4gYWxyZWFkeSByZXNvbHZlZCBhYnNvbHV0ZSBwYXRoLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyBvdGhlcndpc2UgdGhlIGNvbnRleHQgb2YgdGhlIGNhbGwgY291bGQgY2hhbmdlIHdoYXQgZ2V0cyBsb2FkZWQhXG4gKi9cblxuZnVuY3Rpb24gcmVkaXJlY3QobW9kdWxlSWQsIGZpbGVwYXRoKSB7XG4gIGlmICghaXNIaWphY2thYmxlTW9kdWxlSWQobW9kdWxlSWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlZ2lzdGVyIGZvciByZWxhdGl2ZS9hYnNvbHV0ZSBmaWxlIHBhdGhzOyBubyBsZWFkaW5nICcuJyBvciAnLycgYWxsb3dlZCAod2FzIGdpdmVuIFwiLmNvbmNhdChtb2R1bGVJZCwgXCIpXCIpKTtcbiAgfVxuXG4gIGlmIChiaW5kaW5ncy5oYXMobW9kdWxlSWQpKSB7XG4gICAgVGkuQVBJLndhcm4oXCJBbm90aGVyIGJpbmRpbmcgaGFzIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgbW9kdWxlIGlkOiAnXCIuY29uY2F0KG1vZHVsZUlkLCBcIicsIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uLi5cIikpO1xuICAgIGJpbmRpbmdzLmRlbGV0ZShtb2R1bGVJZCk7XG4gIH0gZWxzZSBpZiAocmVkaXJlY3RzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICBUaS5BUEkud2FybihcIkFub3RoZXIgYmluZGluZyBoYXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBtb2R1bGUgaWQ6ICdcIi5jb25jYXQobW9kdWxlSWQsIFwiJywgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi4uLlwiKSk7XG4gIH1cblxuICByZWRpcmVjdHMuc2V0KG1vZHVsZUlkLCBmaWxlcGF0aCk7XG59XG52YXIgYmluZGluZyA9IHtcbiAgcmVnaXN0ZXIsXG4gIHJlZGlyZWN0XG59O1xuZ2xvYmFsLmJpbmRpbmcgPSBiaW5kaW5nO1xuXG4vLyBMb2FkIGFsbCB0aGUgbm9kZSBjb21wYXRpYmxlIGNvcmUgbW9kdWxlc1xucmVnaXN0ZXIoJ3BhdGgnLCBwYXRoJDEpO1xucmVnaXN0ZXIoJ29zJywgT1MpO1xucmVnaXN0ZXIoJ3R0eScsIHR0eSk7XG5yZWdpc3RlcigndXRpbCcsIHV0aWwpO1xucmVnaXN0ZXIoJ2Fzc2VydCcsIGFzc2VydCQxKTtcbnJlZ2lzdGVyKCdldmVudHMnLCBFdmVudEVtaXR0ZXIpO1xucmVnaXN0ZXIoJ2J1ZmZlcicsIEJ1ZmZlck1vZHVsZSk7XG5yZWdpc3Rlcignc3RyaW5nX2RlY29kZXInLCBTdHJpbmdEZWNvZGVyJDEpO1xucmVnaXN0ZXIoJ2ZzJywgZnMpOyAvLyBSZWdpc3RlciByZXF1aXJlKCdidWZmZXInKS5CdWZmZXIgYXMgZ2xvYmFsXG5cbmdsb2JhbC5CdWZmZXIgPSBCdWZmZXJNb2R1bGUuQnVmZmVyO1xuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBBeHdheSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqXG4gKiBEZXNjcmlwdGlvbjpcbiAqIFRoaXMgc2NyaXB0IGxvYWRzIGFsbCBKYXZhU2NyaXB0IGZpbGVzIGVuZGluZyB3aXRoIHRoZSBuYW1lIFwiKi5ib290c3RyYXAuanNcIiBhbmQgdGhlbiBleGVjdXRlcyB0aGVtLlxuICogVGhlIG1haW4gaW50ZW50aW9uIG9mIHRoaXMgZmVhdHVyZSBpcyB0byBhbGxvdyBKYXZhU2NyaXB0IGZpbGVzIHRvIGtpY2stb2ZmIGZ1bmN0aW9uYWxpdHkgb3JcbiAqIGRpc3BsYXkgVUkgdG8gdGhlIGVuZC11c2VyIGJlZm9yZSB0aGUgXCJhcHAuanNcIiBnZXRzIGxvYWRlZC4gVGhpcyBmZWF0dXJlIGlzIHRoZSBDb21tb25KU1xuICogZXF1aXZhbGVudCB0byBUaXRhbml1bSdzIEFuZHJvaWQgbW9kdWxlIG9uQXBwQ3JlYXRlKCkgb3IgaU9TIG1vZHVsZSBsb2FkKCkgZmVhdHVyZXMuXG4gKlxuICogVXNlLUNhc2VzOlxuICogLSBBdXRvbWF0aWNhbGx5IGtpY2stb2ZmIGFuYWx5dGljcyBmdW5jdGlvbmFsaXR5IG9uIGFwcCBzdGFydHVwLlxuICogLSBFbnN1cmUgXCJHb29nbGUgUGxheSBTZXJ2aWNlc1wiIGlzIGluc3RhbGxlZC91cGRhdGVkIG9uIGFwcCBzdGFydHVwIG9uIEFuZHJvaWQuXG4gKi9cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBsb2FkIGFsbCBib290c3RyYXBzIGZyb20gYSBcImJvb3RzdHJhcC5qc29uXCIgZmlsZSBjcmVhdGVkIGJ5IHRoZSBhcHAgYnVpbGQgc3lzdGVtLlxuICogVGhpcyBpcyBhbiBvcHRpb25hbCBmZWF0dXJlIGFuZCBpcyB0aGUgZmFzdGVzdCBtZXRob2Qgb2YgYWNxdWlyaW5nIGJvb3N0cmFwcyBjb25maWd1cmVkIGZvciB0aGUgYXBwLlxuICogVGhpcyBKU09OIGZpbGUsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGluIHRoZSBzYW1lIGRpcmVjdG9yeSBhcyB0aGlzIHNjcmlwdC5cbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgcmVxdWlyZSgpIGNvbXBhdGlibGUgc3RyaW5ncyBpZiBib290c3RyYXBzIHdlcmUgc3VjY2Vzc2Z1bGx5IGxvYWRlZCBmcm9tIEpTT04uXG4gKiBSZXR1cm5zIGFuIGVtcHR5IGFycmF5IGlmIEpTT04gZmlsZSB3YXMgZm91bmQsIGJ1dCBubyBib290c3RyYXBzIHdlcmUgY29uZmlndXJlZCBmb3IgdGhlIGFwcC5cbiAqIFJldHVybnMgbnVsbCBpZiBKU09OIGZpbGUgd2FzIG5vdCBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gZmV0Y2hTY3JpcHRzRnJvbUpzb24oKSB7XG4gIHZhciBKU09OX0ZJTEVfTkFNRSA9ICdib290c3RyYXAuanNvbic7XG5cbiAgdHJ5IHtcbiAgICB2YXIganNvbkZpbGUgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoVGkuRmlsZXN5c3RlbS5yZXNvdXJjZXNEaXJlY3RvcnksIFwidGkuaW50ZXJuYWwvXCIuY29uY2F0KEpTT05fRklMRV9OQU1FKSk7XG5cbiAgICBpZiAoanNvbkZpbGUuZXhpc3RzKCkpIHtcbiAgICAgIHZhciBzZXR0aW5ncyA9IEpTT04ucGFyc2UoanNvbkZpbGUucmVhZCgpLnRleHQpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXR0aW5ncy5zY3JpcHRzKSkge1xuICAgICAgICByZXR1cm4gc2V0dGluZ3Muc2NyaXB0cztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBUaS5BUEkuZXJyb3IoXCJGYWlsZWQgdG8gcmVhZCBcXFwiXCIuY29uY2F0KEpTT05fRklMRV9OQU1FLCBcIlxcXCIuIFJlYXNvbjogXCIpLmNvbmNhdChlcnJvci5tZXNzYWdlKSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgc2VhcmNoZXMgdGhlIFwiUmVzb3VyY2VzXCIgZGlyZWN0b3J5IGZvciBhbGwgXCIqLmJvb3RzdHJhcC5qc1wiIGZpbGVzLlxuICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fVxuICogUmV0dXJucyBhbiBhcnJheSBvZiByZXF1aXJlKCkgY29tcGF0aWJsZSBzdHJpbmdzIGZvciBlYWNoIGJvb3RzdHJhcCBmb3VuZCBpbiB0aGUgc2VhcmNoLlxuICogUmV0dXJucyBhbiBlbXB0eSBhcnJheSBpZiBubyBib290c3RyYXAgZmlsZXMgd2VyZSBmb3VuZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZldGNoU2NyaXB0c0Zyb21SZXNvdXJjZXNEaXJlY3RvcnkoKSB7XG4gIHZhciByZXNvdXJjZURpcmVjdG9yeSA9IFRpLkZpbGVzeXN0ZW0uZ2V0RmlsZShUaS5GaWxlc3lzdGVtLnJlc291cmNlc0RpcmVjdG9yeSk7XG4gIHZhciByZXNvdXJjZURpcmVjdG9yeVBhdGhMZW5ndGggPSByZXNvdXJjZURpcmVjdG9yeS5uYXRpdmVQYXRoLmxlbmd0aDtcbiAgdmFyIGJvb3RzdHJhcFNjcmlwdHMgPSBbXTtcblxuICBmdW5jdGlvbiBsb2FkRnJvbShmaWxlKSB7XG4gICAgaWYgKGZpbGUpIHtcbiAgICAgIGlmIChmaWxlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGRpcmVjdG9yeS4gUmVjdXJzaXZlbHkgbG9vayBmb3IgYm9vdHN0cmFwIGZpbGVzIHVuZGVyIGl0LlxuICAgICAgICB2YXIgZmlsZU5hbWVBcnJheSA9IGZpbGUuZ2V0RGlyZWN0b3J5TGlzdGluZygpO1xuXG4gICAgICAgIGlmIChmaWxlTmFtZUFycmF5KSB7XG4gICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGZpbGVOYW1lQXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBsb2FkRnJvbShUaS5GaWxlc3lzdGVtLmdldEZpbGUoZmlsZS5uYXRpdmVQYXRoLCBmaWxlTmFtZUFycmF5W2luZGV4XSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmaWxlLm5hbWUuc2VhcmNoKC8uYm9vdHN0cmFwLmpzJC8pID49IDApIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGJvb3RzdHJhcCBmaWxlLlxuICAgICAgICAvLyBDb252ZXJ0IGl0cyBwYXRoIHRvIHNvbWV0aGluZyBsb2FkYWJsZSB2aWEgcmVxdWlyZSgpIGFuZCBhZGQgaXQgdG8gdGhlIGFycmF5LlxuICAgICAgICB2YXIgYm9vdHN0cmFwUGF0aCA9IGZpbGUubmF0aXZlUGF0aDtcbiAgICAgICAgYm9vdHN0cmFwUGF0aCA9IGJvb3RzdHJhcFBhdGguc3Vic3RyKHJlc291cmNlRGlyZWN0b3J5UGF0aExlbmd0aCwgYm9vdHN0cmFwUGF0aC5sZW5ndGggLSByZXNvdXJjZURpcmVjdG9yeVBhdGhMZW5ndGggLSAnLmpzJy5sZW5ndGgpO1xuICAgICAgICBib290c3RyYXBTY3JpcHRzLnB1c2goYm9vdHN0cmFwUGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbG9hZEZyb20ocmVzb3VyY2VEaXJlY3RvcnkpO1xuICByZXR1cm4gYm9vdHN0cmFwU2NyaXB0cztcbn1cbi8qKlxuICogTm9uLWJsb2NraW5nIGZ1bmN0aW9uIHdoaWNoIGxvYWRzIGFuZCBleGVjdXRlcyBhbGwgYm9vdHN0cmFwIHNjcmlwdHMgY29uZmlndXJlZCBmb3IgdGhlIGFwcC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZpbmlzaGVkIENhbGxiYWNrIHRvIGJlIGludm9rZWQgb25jZSBhbGwgYm9vdHN0cmFwcyBoYXZlIGZpbmlzaGVkIGV4ZWN1dGluZy4gQ2Fubm90IGJlIG51bGwuXG4gKi9cblxuXG5mdW5jdGlvbiBsb2FkQXN5bmMoZmluaXNoZWQpIHtcbiAgLy8gQWNxdWlyZSBhbiBhcnJheSBvZiBhbGwgYm9vdHN0cmFwIHNjcmlwdHMgaW5jbHVkZWQgd2l0aCB0aGUgYXBwLlxuICAvLyAtIEZvciBiZXN0IHBlcmZvcm1hbmNlLCBhdHRlbXB0IHRvIGZldGNoIHNjcmlwdHMgdmlhIGFuIG9wdGlvbmFsIEpTT04gZmlsZSBjcmVhdGVkIGJ5IHRoZSBidWlsZCBzeXN0ZW0uXG4gIC8vIC0gSWYgSlNPTiBmaWxlIG5vdCBmb3VuZCAod2lsbCByZXR1cm4gbnVsbCksIHRoZW4gc2VhcmNoIFwiUmVzb3VyY2VzXCIgZGlyZWN0b3J5IGZvciBib290c3RyYXAgZmlsZXMuXG4gIHZhciBib290c3RyYXBTY3JpcHRzID0gZmV0Y2hTY3JpcHRzRnJvbUpzb24oKTtcblxuICBpZiAoIWJvb3RzdHJhcFNjcmlwdHMpIHtcbiAgICBib290c3RyYXBTY3JpcHRzID0gZmV0Y2hTY3JpcHRzRnJvbVJlc291cmNlc0RpcmVjdG9yeSgpO1xuICB9IC8vIERvIG5vdCBjb250aW51ZSBpZiBubyBib290c3RyYXBzIHdlcmUgZm91bmQuXG5cblxuICBpZiAoIWJvb3RzdHJhcFNjcmlwdHMgfHwgYm9vdHN0cmFwU2NyaXB0cy5sZW5ndGggPD0gMCkge1xuICAgIGZpbmlzaGVkKCk7XG4gICAgcmV0dXJuO1xuICB9IC8vIFNvcnQgdGhlIGJvb3RzdHJhcHMgc28gdGhhdCB0aGV5J2xsIGJlIGxvYWRlZCBpbiBhIGNvbnNpc3RlbnQgb3JkZXIgYmV0d2VlbiBwbGF0Zm9ybXMuXG5cblxuICBib290c3RyYXBTY3JpcHRzLnNvcnQoKTsgLy8gTG9hZHMgYWxsIGJvb3RzdHJhcCBzY3JpcHRzIGZvdW5kLlxuXG4gIGZ1bmN0aW9uIGxvYWRCb290c3RyYXBTY3JpcHRzKGZpbmlzaGVkKSB7XG4gICAgdmFyIGJvb3RzdHJhcEluZGV4ID0gMDtcblxuICAgIGZ1bmN0aW9uIGRvTG9hZCgpIHtcbiAgICAgIC8vIEF0dGVtcHQgdG8gbG9hZCBhbGwgYm9vdHN0cmFwIHNjcmlwdHMuXG4gICAgICB3aGlsZSAoYm9vdHN0cmFwSW5kZXggPCBib290c3RyYXBTY3JpcHRzLmxlbmd0aCkge1xuICAgICAgICAvLyBMb2FkIHRoZSBuZXh0IGJvb3RzdHJhcC5cbiAgICAgICAgdmFyIGZpbGVOYW1lID0gYm9vdHN0cmFwU2NyaXB0c1tib290c3RyYXBJbmRleF07XG5cbiAgICAgICAgdmFyIGJvb3RzdHJhcCA9IHJlcXVpcmUoZmlsZU5hbWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHNlY3VyaXR5L2RldGVjdC1ub24tbGl0ZXJhbC1yZXF1aXJlXG4gICAgICAgIC8vIEludm9rZSB0aGUgYm9vdHN0cmFwJ3MgZXhlY3V0ZSgpIG1ldGhvZCBpZiBpdCBoYXMgb25lLiAoVGhpcyBpcyBvcHRpb25hbC4pXG4gICAgICAgIC8vIFdlIG11c3Qgd2FpdCBmb3IgdGhlIGdpdmVuIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYmVmb3JlIGxvYWRpbmcgdGhlIG5leHQgc2NyaXB0LlxuICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIGV4cGVjdGVkIHRvIGJlIHVzZWQgdG8gZGlzcGxheSBVSSB0byB0aGUgZW5kLXVzZXIuXG5cblxuICAgICAgICBpZiAoYm9vdHN0cmFwLmV4ZWN1dGUpIHtcbiAgICAgICAgICBib290c3RyYXAuZXhlY3V0ZShvbkJvb3RzdHJhcEV4ZWN1dGlvbkZpbmlzaGVkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gV2UncmUgZG9uZSB3aXRoIHRoZSBjdXJyZW50IGJvb3RzdHJhcC4gVGltZSB0byBsb2FkIHRoZSBuZXh0IG9uZS5cblxuXG4gICAgICAgIGJvb3RzdHJhcEluZGV4Kys7XG4gICAgICB9IC8vIEludm9rZSBnaXZlbiBjYWxsYmFjayB0byBpbmZvcm0gY2FsbGVyIHRoYXQgYWxsIGxvYWRpbmcgaXMgZG9uZS5cblxuXG4gICAgICBmaW5pc2hlZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQm9vdHN0cmFwRXhlY3V0aW9uRmluaXNoZWQoKSB7XG4gICAgICAvLyBMYXN0IGJvb3RzdHJhcCBoYXMgZmluaXNoZWQgZXhlY3V0aW9uLiBUaW1lIHRvIGxvYWQgdGhlIG5leHQgb25lLlxuICAgICAgLy8gTm90ZTogQWRkIGEgdGlueSBkZWxheSBzbyB3aGF0ZXZlciBVSSB0aGUgbGFzdCBib290c3RyYXAgbG9hZGVkIGhhcyB0aW1lIHRvIGNsb3NlLlxuICAgICAgYm9vdHN0cmFwSW5kZXgrKztcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gZG9Mb2FkKCksIDEpO1xuICAgIH1cblxuICAgIGRvTG9hZCgpO1xuICB9IC8vIFdlJ3ZlIGZpbmlzaGVkIGxvYWRpbmcvZXhlY3V0aW5nIGFsbCBib290c3RyYXAgc2NyaXB0cy5cbiAgLy8gSW5mb3JtIGNhbGxlciBieSBpbnZva2luZyB0aGUgY2FsbGJhY2sgZ2l2ZW4gdG8gbG9hZEFzeW5jKCkuXG5cblxuICBsb2FkQm9vdHN0cmFwU2NyaXB0cyhmaW5pc2hlZCk7XG59XG5cbi8qKlxuICogQXBwY2VsZXJhdG9yIFRpdGFuaXVtIE1vYmlsZVxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICpcbiAqIFRoaXMgc2NyaXB0IGlzIGxvYWRlZCBvbiBhcHAgc3RhcnR1cCBvbiBhbGwgcGxhdGZvcm1zLiBJdCBpcyB1c2VkIHRvIGRvIHRoZSBmb2xsb3dpbmc6XG4gKiAtIFByb3ZpZGUgY29uc2lzdGVudCBzdGFydHVwIGJlaGF2aW9yIGJldHdlZW4gcGxhdGZvcm1zLCBzdWNoIGFzIGxvZ2dpbmcgVGl0YW5pdW0gdmVyc2lvbi5cbiAqIC0gTG9hZCBUaXRhbml1bSdzIGNvcmUgSmF2YVNjcmlwdCBleHRlbnNpb25zIHNoYXJlZCBieSBhbGwgcGxhdGZvcm1zLlxuICogLSBQcm92aWRlIFwiKi5ib290c3RyYXAuanNcIiBzY3JpcHQgc3VwcG9ydC4gKFNpbWlsYXIgdG8gbmF0aXZlIG1vZHVsZSBvbkFwcENyZWF0ZSgpL2xvYWQoKSBzdXBwb3J0LilcbiAqIC0gTG9hZCB0aGUgYXBwIGRldmVsb3BlcidzIG1haW4gXCJhcHAuanNcIiBzY3JpcHQgYWZ0ZXIgZG9pbmcgYWxsIG9mIHRoZSBhYm92ZS5cbiAqL1xuLy8gTG9nIHRoZSBhcHAgbmFtZSwgYXBwIHZlcnNpb24sIGFuZCBUaXRhbml1bSB2ZXJzaW9uIG9uIHN0YXJ0dXAuXG5UaS5BUEkuaW5mbyhcIlwiLmNvbmNhdChUaS5BcHAubmFtZSwgXCIgXCIpLmNvbmNhdChUaS5BcHAudmVyc2lvbiwgXCIgKFBvd2VyZWQgYnkgVGl0YW5pdW0gXCIpLmNvbmNhdChcIjkuMS4wXCIsIFwiLlwiKS5jb25jYXQoXCJiOGU5NjZkMGM5XCIsIFwiKVwiKSk7IC8vIEF0dGVtcHQgdG8gbG9hZCBjcmFzaCBhbmFseXRpY3MgbW9kdWxlLlxuLy8gTk9URTogVGhpcyBzaG91bGQgYmUgdGhlIGZpcnN0IG1vZHVsZSB0aGF0IGxvYWRzIG9uIHN0YXJ0dXAuXG5cbnRyeSB7XG4gIHJlcXVpcmUoJ2NvbS5hcHBjZWxlcmF0b3IuYWNhJyk7XG59IGNhdGNoIChlKSB7fSAvLyBDb3VsZCBub3QgbG9hZCBtb2R1bGUsIHNpbGVudGx5IGlnbm9yZSBleGNlcHRpb24uXG5sb2FkQXN5bmMoZnVuY3Rpb24gKCkge1xuICAvLyBXZSd2ZSBmaW5pc2hlZCBsb2FkaW5nL2V4ZWN1dGluZyBhbGwgYm9vdHN0cmFwIHNjcmlwdHMuXG4gIC8vIFdlIGNhbiBub3cgcHJvY2VlZCB0byBydW4gdGhlIG1haW4gXCJhcHAuanNcIiBzY3JpcHQuXG4gIHJlcXVpcmUoJy4vYXBwJyk7IC8vIFRoaXMgZXZlbnQgaXMgdG8gYmUgZmlyZWQgYWZ0ZXIgXCJhcHAuanNcIiBleGVjdXRpb24uIFJlYXNvbnM6XG4gIC8vIC0gQWxsb3cgc3lzdGVtIHRvIHF1ZXVlIHN0YXJ0dXAgcmVsYXRlZCBldmVudHMgdW50aWwgXCJhcHAuanNcIiBoYXMgaGFkIGEgY2hhbmNlIHRvIGFkZCBsaXN0ZW5lcnMuXG4gIC8vIC0gRm9yIEFsbG95IGFwcHMsIHdlIG5vdyBrbm93IHRoYXQgQWxsb3kgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgYW5kIGl0cyBnbG9iYWxzIHdlcmUgYWRkZWQuXG5cblxuICBUaS5BcHAuZmlyZUV2ZW50KCdzdGFydGVkJyk7XG59KTtcbiJdLCJzb3VyY2VSb290IjoiL1VzZXJzL3Znb3lhbC9MaWJyYXJ5L0FwcGxpY2F0aW9uIFN1cHBvcnQvVGl0YW5pdW0vbW9iaWxlc2RrL29zeC85LjEuMC52MjAyMDAyMTkwNjI2NDcvY29tbW9uL1Jlc291cmNlcy9pb3MifQ==
